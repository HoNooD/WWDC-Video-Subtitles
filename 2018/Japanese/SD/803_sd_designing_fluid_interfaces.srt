
1
00:00:07,040 --> 00:00:16,315
(音楽)

2
00:00:27,694 --> 00:00:28,862
こんにちは

3
00:00:28,962 --> 00:00:32,031
(拍手)

4
00:00:32,131 --> 00:00:33,367
どうも

5
00:00:33,967 --> 00:00:35,936
ようこそいらっしゃいました

6
00:00:36,570 --> 00:00:39,206
今日のお話は“Designing
Fluid Interfaces”です

7
00:00:39,306 --> 00:00:40,574
私はチャン

8
00:00:40,674 --> 00:00:43,544
ヒューマンインターフェイス
チーム所属です

9
00:00:43,710 --> 00:00:46,113
私の最新の研究は―

10
00:00:46,213 --> 00:00:49,483
iPhone Xのfluid gestural
インターフェイスです

11
00:00:49,750 --> 00:00:53,120
私 マーコス ネイサンの
３人は

12
00:00:53,520 --> 00:00:57,124
これら一連の開発を
してきました

13
00:00:57,224 --> 00:00:59,626
そのお話をしましょう

14
00:00:59,826 --> 00:01:04,031
私たちが自らに
何度も問いかけたのは―

15
00:00:59,826 --> 00:01:04,031
私たちが自らに
何度も問いかけたのは―

16
00:01:04,131 --> 00:01:07,334
滑らかな
インターフェイスとは何か？

17
00:01:08,168 --> 00:01:12,039
その表現方法は
人によって様々です

18
00:01:12,139 --> 00:01:15,876
私たちがデモを行うと
それを見た人は

19
00:01:15,976 --> 00:01:18,178
実際に手に取り 使います

20
00:01:18,345 --> 00:01:22,649
“速い”と言う人
“スムーズ”と言う人

21
00:01:22,816 --> 00:01:26,587
感覚がぴったり合い
“ナチュラル”と言う人

22
00:01:26,687 --> 00:01:27,888
“魔法だ”とも

23
00:01:28,255 --> 00:01:29,990
結局のところ―

24
00:01:30,290 --> 00:01:34,895
こういう物は
実際に触ってみることです

25
00:01:34,995 --> 00:01:36,563
良さを実感できます

26
00:01:36,997 --> 00:01:39,066
ジェスチャUIを試せます

27
00:01:39,166 --> 00:01:42,069
多くのジェスチャUIの中で

28
00:01:42,169 --> 00:01:45,606
出来が良くないものは
何か違うと感じます

29
00:01:45,706 --> 00:01:49,009
指がしっくりこないのは
なぜか？

30
00:01:49,309 --> 00:01:51,411
フレームレートの問題？

31
00:01:51,512 --> 00:01:55,616
１秒間に60フレームで
サクサク動いても

32
00:01:55,716 --> 00:01:59,887
何かが違うこの感覚は
何なのか？

33
00:02:00,554 --> 00:02:03,023
行きつくところは―

34
00:02:03,123 --> 00:02:06,360
“道具を心の延長のように
感じられるか”

35
00:02:06,793 --> 00:02:08,862
心とつながっているかです

36
00:02:09,062 --> 00:02:11,064
なぜ それが大切なのか？

37
00:02:11,865 --> 00:02:14,968
iPhoneは道具ですよね？

38
00:02:15,068 --> 00:02:18,639
情報通信のための
手道具で―

39
00:02:18,739 --> 00:02:23,610
触覚と視覚が密接に
結び付いて機能します

40
00:02:24,144 --> 00:02:28,549
手道具の長い歴史を
受け継いでおり

41
00:02:28,649 --> 00:02:31,451
起源は数千年前に
さかのぼります

42
00:02:31,885 --> 00:02:36,857
左側の道具は 15万年前
骨髄の抽出に使用されました

43
00:02:36,957 --> 00:02:39,459
指に沿うように
鋭く伸びています

44
00:02:39,593 --> 00:02:42,796
人々は手道具を
作り続けてきました

45
00:02:42,896 --> 00:02:47,067
最も驚くべきことは
私たちの手は進化し―

46
00:02:47,167 --> 00:02:49,670
道具に順応してきたのです

47
00:02:49,770 --> 00:02:54,308
大きな進化を遂げた
筋肉や神経 血管などが

48
00:02:54,408 --> 00:02:58,612
繊細な動きを表現し
軽い接触も感知できます

49
00:02:59,112 --> 00:03:03,717
私たちはこの触知性の時代に
順応してきました

50
00:02:59,112 --> 00:03:03,717
私たちはこの触知性の時代に
順応してきました

51
00:03:04,051 --> 00:03:07,054
コンピュータの歴史を見ると

52
00:03:07,187 --> 00:03:12,025
以前は動かすための
手順がいくつもありました

53
00:03:12,125 --> 00:03:15,262
操作には様々な知識が
必要だったため

54
00:03:15,362 --> 00:03:18,265
多くの人にとって
遠い存在でした

55
00:03:19,233 --> 00:03:22,236
しかし この20～30年の間に

56
00:03:22,336 --> 00:03:26,540
最初は間接操作だった多くの
手順が省かれました

57
00:03:26,640 --> 00:03:30,210
個人が直接扱えるものに
近付いたのです

58
00:03:30,344 --> 00:03:31,912
そして 現在―

59
00:03:32,012 --> 00:03:36,049
コンテンツに
直接アクセスできるよう

60
00:03:36,149 --> 00:03:38,752
全手順を
省こうとしています

61
00:03:38,852 --> 00:03:43,657
コンピュータと感じなくなる
魔法の要素です

62
00:03:43,757 --> 00:03:49,429
自然界の延長のように
感じ始めるのです

63
00:03:49,796 --> 00:03:53,033
つまり インターフェイスと
人とのつながりは

64
00:03:53,133 --> 00:03:57,604
これまでよりも
古代の形に近付いたのです

65
00:03:57,704 --> 00:04:00,274
それでいて高水準です

66
00:03:57,704 --> 00:04:00,274
それでいて高水準です

67
00:04:00,374 --> 00:04:04,411
少しでも違うと感じると
期待は打ち砕かれます

68
00:04:04,711 --> 00:04:10,450
しかし うまくいけば
自分の分身のように感じます

69
00:04:10,551 --> 00:04:12,753
あなたの考えと共鳴して

70
00:04:12,853 --> 00:04:17,757
楽しく 人との摩擦も少なく
遊び心さえ感じます

71
00:04:18,125 --> 00:04:20,160
なぜ そう感じるのか？

72
00:04:20,260 --> 00:04:23,297
しっくりこない時には
どうするか？

73
00:04:23,397 --> 00:04:25,899
その答えが今日のお話です

74
00:04:26,833 --> 00:04:32,206
今から４つのお話をします
まず 動作原理の策定

75
00:04:32,306 --> 00:04:36,476
そして自身の延長のような
インターフェイスの構築

76
00:04:37,244 --> 00:04:42,983
人の体や 様々な物の動きに
合った動作の設計方法

77
00:04:43,550 --> 00:04:47,654
優雅で知性を感じる
ジェスチャの設計

78
00:04:49,022 --> 00:04:52,559
これらの原理の上に
どう相互作用を構築し

79
00:04:52,659 --> 00:04:57,965
どうやって体の一部のように
感じてもらうか？

80
00:04:59,233 --> 00:05:00,734
では 始めましょう

81
00:04:59,233 --> 00:05:00,734
では 始めましょう

82
00:05:00,834 --> 00:05:05,339
分身のようなインターフェイスを
どう設計するか？

83
00:05:05,606 --> 00:05:08,208
私たちが考えた方法は―

84
00:05:08,308 --> 00:05:13,046
考え方や動き方に
インターフェイスを合わせること

85
00:05:13,447 --> 00:05:15,682
ここで最も重要な点は―

86
00:05:15,816 --> 00:05:20,787
心は常に 変化や刺激や
思考に反応するということ

87
00:05:21,255 --> 00:05:25,425
心と体は常に
動的変化の状態にあります

88
00:05:25,526 --> 00:05:28,962
インターフェイスは
人の滑らかな動きに

89
00:05:29,062 --> 00:05:31,865
反応できる必要があります

90
00:05:32,833 --> 00:05:36,069
そう 反応から始まるのです

91
00:05:36,970 --> 00:05:39,840
道具は反応時間の
早さが大切です

92
00:05:40,107 --> 00:05:42,376
道具や楽器を使う際

93
00:05:42,476 --> 00:05:46,747
反応に遅れが出ては
使いづらく大変です

94
00:05:47,047 --> 00:05:50,484
人々は反応時間に
実に敏感です

95
00:05:50,584 --> 00:05:53,353
タイムラグが発生したり

96
00:05:54,087 --> 00:05:57,824
突然 反応しなくなったりしたら？

97
00:05:57,925 --> 00:06:01,828
かみ合わなさに
ストレスを感じます

98
00:05:57,925 --> 00:06:01,828
かみ合わなさに
ストレスを感じます

99
00:06:01,929 --> 00:06:04,264
もはや 分身とは思えません

100
00:06:04,531 --> 00:06:07,434
そこで 懸命に
反応時間を削りました

101
00:06:07,534 --> 00:06:11,772
最新のiPhoneでは
反応がより早くなり

102
00:06:11,872 --> 00:06:16,076
微妙な動きも
即座に検知できます

103
00:06:16,476 --> 00:06:20,047
iPhoneを
気に入ってほしいので

104
00:06:20,681 --> 00:06:23,684
遅れがないか
入念に探すのです

105
00:06:23,784 --> 00:06:28,255
スワイプやタップだけでなく
全ての作用に対して

106
00:06:28,388 --> 00:06:30,824
即時の反応が必要なのです

107
00:06:31,291 --> 00:06:35,062
この製品を設計する過程で
頻繁に―

108
00:06:36,330 --> 00:06:38,699
微妙な遅れが出ました

109
00:06:38,799 --> 00:06:45,005
慎重に意識的に 遅れに
注意を払うことが大切です

110
00:06:45,105 --> 00:06:48,008
インターフェイスに
タイマーを仕込み

111
00:06:48,108 --> 00:06:50,210
常に反応する設定にも
できます

112
00:06:51,345 --> 00:06:56,884
インターフェイスを活発にする
反応について話してきました

113
00:06:58,852 --> 00:06:59,653
次に―

114
00:07:00,621 --> 00:07:06,293
方向転換や中断について
考慮することも大切です

115
00:07:06,460 --> 00:07:10,364
私たちの心と体は
絶えず方向転換しています

116
00:07:10,597 --> 00:07:12,933
思考の変化に反応します

117
00:07:13,333 --> 00:07:17,871
ステージ脇に歩いていて
忘れ物に気付いたら

118
00:07:17,971 --> 00:07:22,009
端にたどり着く前に
引き返すでしょう

119
00:07:22,109 --> 00:07:23,977
端まで行かないですよね？

120
00:07:24,077 --> 00:07:29,550
インターフェイスは方向転換に
即応することが重要です

121
00:07:29,683 --> 00:07:31,818
つながっていると
感じられます

122
00:07:32,052 --> 00:07:36,823
そこで iPhone Xに
リダイレクト機能を構築しました

123
00:07:37,090 --> 00:07:38,492
それは何か？

124
00:07:39,893 --> 00:07:45,032
２つのアプリケーションを
行き来できる機能です

125
00:07:45,132 --> 00:07:46,800
ホームにも すぐ戻れます

126
00:07:46,900 --> 00:07:50,370
戻る途中で
２つを同時に見て

127
00:07:50,470 --> 00:07:53,607
どちらに行くかを
決められます

128
00:07:53,841 --> 00:07:57,678
どちらもやめて
ホームにも戻れます

129
00:07:58,078 --> 00:08:00,414
重要と思えないかも
しれません

130
00:07:58,078 --> 00:08:00,414
重要と思えないかも
しれません

131
00:08:00,514 --> 00:08:03,784
しかし この機能がないと
どうなるか？

132
00:08:05,118 --> 00:08:10,657
２つのアプリケーションの
行き来だけであれば

133
00:08:10,757 --> 00:08:15,929
ホームに戻れば終了で
それ以上 何もできません

134
00:08:16,430 --> 00:08:20,434
その場合 指を動かす前に

135
00:08:20,534 --> 00:08:23,370
したいことを
考えなくてはいけません

136
00:08:23,804 --> 00:08:26,073
イベントは
１本の線上に並びます

137
00:08:26,173 --> 00:08:29,543
ホームに戻るか
マルチタスクをするか―

138
00:08:29,643 --> 00:08:33,313
決めてから指を動かし
命令を発します

139
00:08:34,014 --> 00:08:36,884
リダイレクト機能の
素晴らしい点は

140
00:08:36,984 --> 00:08:40,020
並行する思考とジェスチャに
対応できること

141
00:08:40,220 --> 00:08:43,624
考えると同時に行動するほうが

142
00:08:43,789 --> 00:08:47,060
行動する前に考えるより速い

143
00:08:47,161 --> 00:08:52,065
マルチ画面をジェスチャで
操作できるのです

144
00:08:52,166 --> 00:08:53,700
別々のジェスチャではなく

145
00:08:53,800 --> 00:08:57,538
１つのジェスチャで
全てできるのです

146
00:08:57,638 --> 00:09:00,507
別々のものと
考えなくていい

147
00:08:57,638 --> 00:09:00,507
別々のものと
考えなくていい

148
00:09:01,008 --> 00:09:01,942
そして―

149
00:09:02,509 --> 00:09:07,915
操作していく中で 新たな
ジェスチャを発見できます

150
00:09:08,382 --> 00:09:12,686
思考と同時に ジェスチャを
重ねていけるのです

151
00:09:13,053 --> 00:09:14,588
どういう意味か？

152
00:09:14,688 --> 00:09:16,590
例を挙げてみましょう

153
00:09:16,690 --> 00:09:21,795
シミュレーションを
見やすくゆっくり再生します

154
00:09:22,296 --> 00:09:25,699
スワイプで
ホームに戻りながら

155
00:09:25,799 --> 00:09:28,869
次のページに移動できます

156
00:09:28,969 --> 00:09:32,039
同時に ２つのジェスチャが
できるのです

157
00:09:33,040 --> 00:09:37,611
他にも アプリケーションを
起動させながら

158
00:09:37,711 --> 00:09:42,549
マルチタスキングを
開くことができます

159
00:09:43,417 --> 00:09:45,552
他にもあります

160
00:09:46,320 --> 00:09:49,590
間違ってアプリケーションを
起動した場合

161
00:09:49,690 --> 00:09:52,593
起動完了前に終了できます

162
00:09:53,861 --> 00:09:57,531
さらに
こんなこともできます

163
00:09:57,965 --> 00:10:02,669
起動中のアプリケーションを
操作できるのです

164
00:09:57,965 --> 00:10:02,669
起動中のアプリケーションを
操作できるのです

165
00:10:03,203 --> 00:10:06,173
インターフェイスが
常に反応するのは

166
00:10:06,273 --> 00:10:10,043
非常に重要なことだと
分かりました

167
00:10:10,143 --> 00:10:14,014
常にユーザを
理解することが重要です

168
00:10:14,314 --> 00:10:18,919
インターフェイスが
ユーザを理解することは

169
00:10:19,019 --> 00:10:23,357
快適な使い心地のために
とても重要です

170
00:10:26,193 --> 00:10:31,064
操作開始時だけではなく
操作の途中でも

171
00:10:31,164 --> 00:10:34,268
反応することが求められます

172
00:10:34,401 --> 00:10:37,704
割り込みにも
反応できるのが大事です

173
00:10:37,805 --> 00:10:40,874
iPhone Xで
マルチタスキングを開くには

174
00:10:41,208 --> 00:10:46,313
画面の下部から
上にスワイプして指を止めます

175
00:10:46,413 --> 00:10:50,717
このモーションの変化を
検知するためには

176
00:10:50,818 --> 00:10:53,654
どうすればいいでしょうか？

177
00:10:53,754 --> 00:10:55,022
タイマーを使う？

178
00:10:55,122 --> 00:10:58,525
ある速度を一定期間
下回ったら

179
00:10:58,625 --> 00:11:02,663
マルチタスキングを
開けばいいでしょうか？

180
00:10:58,625 --> 00:11:02,663
マルチタスキングを
開けばいいでしょうか？

181
00:11:02,763 --> 00:11:04,898
それでは遅すぎます

182
00:11:04,998 --> 00:11:08,302
ユーザが期待するくらい
迅速に

183
00:11:08,602 --> 00:11:12,739
マルチタスキングを
開く方法が必要です

184
00:11:14,007 --> 00:11:16,643
そこで指の加速に注目します

185
00:11:17,077 --> 00:11:21,515
指を止めたい時 人は
指を迅速に動かします

186
00:11:21,615 --> 00:11:25,419
止まるのが速いほど
鋭く検出できます

187
00:11:25,586 --> 00:11:28,255
モーションの変化に
反応したほうが

188
00:11:28,355 --> 00:11:31,925
タイマーを使うより
早いのです

189
00:11:32,893 --> 00:11:37,231
リダイレクションに
素早く反応する例でした

190
00:11:39,566 --> 00:11:42,569
割り込みと
リダイレクションにより

191
00:11:42,903 --> 00:11:46,507
直感的に
操作できるようになります

192
00:11:47,407 --> 00:11:48,175
次です

193
00:11:49,710 --> 00:11:53,247
インターフェイスの
配置について―

194
00:11:53,347 --> 00:11:54,681
紹介します

195
00:11:55,582 --> 00:12:00,487
動作を通して 空間的一貫性を
保つことが重要です

196
00:11:55,582 --> 00:12:00,487
動作を通して 空間的一貫性を
保つことが重要です

197
00:12:01,021 --> 00:12:02,089
その意味は？

198
00:12:02,322 --> 00:12:06,760
実世界での物体の動作を
まねることで

199
00:12:06,860 --> 00:12:11,031
スムーズに出入りするように
見せるのです

200
00:12:11,732 --> 00:12:16,370
何かが消えたら
消えた場所から現れますよね

201
00:12:16,470 --> 00:12:20,908
もし私があっちに消えたのに
逆から現れたら

202
00:12:21,141 --> 00:12:22,609
驚くでしょう

203
00:12:22,709 --> 00:12:24,978
道理に合いません

204
00:12:25,245 --> 00:12:31,451
そこで 人間が持つ一貫した
空間感覚に合わせようとしました

205
00:12:33,120 --> 00:12:38,058
つまり 何かが視界から消えて
また現れる場合

206
00:12:38,158 --> 00:12:43,330
画面外への出入りは
同じ経路をたどるべきです

207
00:12:43,730 --> 00:12:47,000
iOSの画面遷移が良い例です

208
00:12:47,100 --> 00:12:50,737
項目をタップすると
ページは右から現れ

209
00:12:51,004 --> 00:12:55,275
戻る時は同じ経路をたどり
右に戻ります

210
00:12:55,375 --> 00:12:59,446
項目ごとに
場所が決まっているのです

211
00:12:59,746 --> 00:13:03,917
場所を把握していれば
自分でスライドして

212
00:12:59,746 --> 00:13:03,917
場所を把握していれば
自分でスライドして

213
00:13:04,017 --> 00:13:06,753
戻すこともできます

214
00:13:07,321 --> 00:13:08,856
この機能がなかったら？

215
00:13:08,956 --> 00:13:12,092
スライドインしたものが

216
00:13:12,192 --> 00:13:16,997
下に行ったら
一貫性がなく混乱しますよね

217
00:13:17,264 --> 00:13:19,299
送るような感覚です

218
00:13:19,399 --> 00:13:23,837
どこかに送るような動作に
見えてしまいます

219
00:13:24,571 --> 00:13:27,441
空間的一貫性を保つことで

220
00:13:27,908 --> 00:13:32,045
ジェスチャと同調するように
感じるのです

221
00:13:33,580 --> 00:13:37,885
次は ジェスチャの
ヒントについてです

222
00:13:38,585 --> 00:13:43,490
人間は常に 次に起こることを
予測しています

223
00:13:43,590 --> 00:13:49,530
これまでの経験を利用して
次の動きを予想するのです

224
00:13:50,164 --> 00:13:54,101
インターフェイスでも
それができたらいいですよね

225
00:13:54,334 --> 00:13:59,006
例えば 初期と最後の
ステートがあったら

226
00:13:59,139 --> 00:14:03,710
中間のトランジションが
あるはずです

227
00:13:59,139 --> 00:14:03,710
中間のトランジションが
あるはずです

228
00:14:03,810 --> 00:14:08,015
オブジェクトは
初期から最後のステートに

229
00:14:08,115 --> 00:14:11,552
スムーズに拡大するのです

230
00:14:12,452 --> 00:14:14,688
コントロールセンターが
良い例です

231
00:14:15,022 --> 00:14:20,494
モジュールを長押しすると
徐々に大きくなって

232
00:14:20,828 --> 00:14:24,631
最終的にポップアップします

233
00:14:26,300 --> 00:14:31,338
この効果によって
ジェスチャを予測できるのです

234
00:14:33,407 --> 00:14:39,012
次は 軽快なタッチ操作の
重要性についてです

235
00:14:39,346 --> 00:14:43,750
Multi-Touchの軽さは
過小評価されがちですが

236
00:14:43,851 --> 00:14:49,823
軽い力でスワイプなどができるのは
そのおかげです

237
00:14:49,923 --> 00:14:54,628
課題は 軽さを残して
動きの幅を増やすこと

238
00:14:54,728 --> 00:14:58,031
小さな入力で
大きな出力を得ることです

239
00:14:58,131 --> 00:15:03,403
何かを投げるような感覚で
操作できるのが理想です

240
00:14:58,131 --> 00:15:03,403
何かを投げるような感覚で
操作できるのが理想です

241
00:15:04,204 --> 00:15:08,742
インターフェイスでは
短い操作から始まります

242
00:15:09,042 --> 00:15:11,245
軽く短い操作です

243
00:15:11,712 --> 00:15:16,817
ジェスチャのプロファイルを
生成するために

244
00:15:16,917 --> 00:15:22,089
我々の全てのセンサーや技術を
利用します

245
00:15:23,023 --> 00:15:27,027
位置や速度 強さなど
全てを用いて

246
00:15:27,127 --> 00:15:32,466
ジェスチャのプロファイルを
生成するのです

247
00:15:32,566 --> 00:15:36,169
そしてそれを増幅すると

248
00:15:36,503 --> 00:15:39,640
体の延長のように感じます

249
00:15:39,873 --> 00:15:44,144
軽い操作で満足のいく
使用感が得られるのです

250
00:15:44,912 --> 00:15:47,614
スクロールが良い例です

251
00:15:47,714 --> 00:15:51,084
画面上に指があるのは
短い間ですが

252
00:15:51,451 --> 00:15:57,424
強さや推進力が保存され
インターフェイスに送られます

253
00:15:58,025 --> 00:15:59,927
この機能がなかったら？

254
00:16:00,394 --> 00:16:03,831
スワイプしても
あまり動きません

255
00:16:05,866 --> 00:16:10,504
スクロールするには
長くスワイプしなければならず

256
00:16:10,604 --> 00:16:14,575
大きな力が求められ
使いにくいでしょう

257
00:16:15,676 --> 00:16:18,412
ホームへ戻るのも良い例です

258
00:16:18,879 --> 00:16:22,249
画面に触れるのは短時間です

259
00:16:22,549 --> 00:16:27,855
流れるような軽いジェスチャで
操作でき―

260
00:16:27,955 --> 00:16:31,058
Multi-Touch特有と
感じられます

261
00:16:31,291 --> 00:16:34,228
画面の下部から指を動かせば

262
00:16:34,328 --> 00:16:37,865
SpringBoardに戻ります

263
00:16:40,634 --> 00:16:44,404
スワイプだけではなく
タップでも

264
00:16:44,705 --> 00:16:48,842
全ての操作に
高い反応性が必要です

265
00:16:48,942 --> 00:16:52,045
インターフェイスと
つながっている感覚

266
00:16:52,146 --> 00:16:56,083
その感覚こそが
大事だからです

267
00:16:56,750 --> 00:16:59,953
動きの軽さと幅
についてでした

268
00:17:01,722 --> 00:17:04,358
次は
ラバーバンド効果という―

269
00:17:04,892 --> 00:17:09,061
インターフェイスの境界を
示す演出についてです

270
00:17:10,230 --> 00:17:15,202
インターフェイスは
ページの終わりが近付くと

271
00:17:15,301 --> 00:17:17,738
暗に知らせてきます

272
00:17:17,838 --> 00:17:20,507
ユーザを理解しているのです

273
00:17:20,807 --> 00:17:22,509
この機能がなかったら？

274
00:17:22,809 --> 00:17:26,813
雑な印象で
壁に当たったかのようです

275
00:17:26,914 --> 00:17:31,885
まるで故障のようで
フリーズとの区別もつきません

276
00:17:31,985 --> 00:17:35,055
画面の最上部で
止まるだけです

277
00:17:35,155 --> 00:17:39,593
境界を伝えるのは
大事なことなのです

278
00:17:40,561 --> 00:17:44,164
トランジションの場合も
同様です

279
00:17:44,264 --> 00:17:49,870
ある動作から別の動作に
移る時もスムーズです

280
00:17:50,070 --> 00:17:55,075
Dockをスワイプして
アプリケーションを開く時

281
00:17:55,342 --> 00:17:59,246
ぶつかったりせずに
別の動作に移動できます

282
00:17:59,346 --> 00:18:02,483
引き継ぎの動きは
スムーズで―

283
00:17:59,346 --> 00:18:02,483
引き継ぎの動きは
スムーズで―

284
00:18:02,583 --> 00:18:08,355
別の動作に移る時に
不快感を与えません

285
00:18:09,790 --> 00:18:13,460
次はスムーズな
動きについてです

286
00:18:14,261 --> 00:18:19,199
上下に動くオブジェクトが
あるとします

287
00:18:19,433 --> 00:18:23,871
これは 実際に
動いているわけではなく

288
00:18:24,104 --> 00:18:26,406
そう見えるだけです

289
00:18:26,507 --> 00:18:32,713
大量のフレームを見て
動いていると錯覚するのです

290
00:18:32,880 --> 00:18:38,719
フレームを展開して
時間の推移の中で見てみましょう

291
00:18:39,386 --> 00:18:43,423
懸念するのは
ハイライトされた部分です

292
00:18:43,524 --> 00:18:48,328
隣接するフレーム間に
大きな変化があります

293
00:18:48,428 --> 00:18:53,000
ここではインターフェイスが
ぎこちなくなり

294
00:18:53,100 --> 00:18:55,035
ちらつきが起こります

295
00:18:55,569 --> 00:19:00,274
２つのフレームの違いが
大きすぎるからです

296
00:18:55,569 --> 00:19:00,274
２つのフレームの違いが
大きすぎるからです

297
00:19:00,841 --> 00:19:03,443
だから ちらつくのです

298
00:19:03,544 --> 00:19:07,981
この例では 両方とも
１秒30フレームですが

299
00:19:08,081 --> 00:19:10,517
左のほうがスムーズです

300
00:19:10,617 --> 00:19:15,022
右のほうは速すぎて
ちらついています

301
00:19:15,122 --> 00:19:19,660
視覚認識が
追いつかないので

302
00:19:19,760 --> 00:19:22,996
スムーズには見えません

303
00:19:23,297 --> 00:19:27,201
つまり重要なのは
フレームレートだけではなく

304
00:19:27,367 --> 00:19:29,303
フレームの内容です

305
00:19:29,536 --> 00:19:31,839
では スムーズさを
保ちながら

306
00:19:31,939 --> 00:19:35,375
どこまで速く
できるでしょうか？

307
00:19:35,843 --> 00:19:40,647
１秒30フレームから
60フレームにすると

308
00:19:40,747 --> 00:19:46,320
スムーズさを保ちながら
もう少し速くできます

309
00:19:46,420 --> 00:19:48,822
ちらつきもありません

310
00:19:49,356 --> 00:19:52,359
モーションブラーも使えます

311
00:19:52,459 --> 00:19:58,632
それぞれのフレームに
動きに関する情報を足すのです

312
00:19:58,732 --> 00:20:01,368
人間の目は
このように機能します

313
00:19:58,732 --> 00:20:01,368
人間の目は
このように機能します

314
00:20:02,102 --> 00:20:06,607
2Dアニメーションや
ゲームからも学べます

315
00:20:06,707 --> 00:20:10,677
モーションストレッチという
技術を使えば

316
00:20:11,111 --> 00:20:15,649
オブジェクトを伸び縮み
させることができます

317
00:20:17,117 --> 00:20:20,387
動かすと こんな感じです

318
00:20:20,487 --> 00:20:23,090
それぞれの異なる技術が

319
00:20:23,190 --> 00:20:29,162
動きについて より多くの情報を
エンコードしようとします

320
00:20:29,396 --> 00:20:32,099
モーションストレッチの
技術は

321
00:20:32,199 --> 00:20:34,434
iPhone Xで使われています

322
00:20:34,668 --> 00:20:36,803
アプリケーションを
起動すると

323
00:20:37,671 --> 00:20:41,909
アイコンが拡大しながら
起動します

324
00:20:42,209 --> 00:20:45,679
そして終了する時は
逆に縮みます

325
00:20:45,779 --> 00:20:51,151
スムーズに見えるように
情報を補っているのです

326
00:20:53,053 --> 00:20:57,925
最後に アニメーションと
ビヘイビアについてです

327
00:20:58,025 --> 00:21:03,597
物体は常に動的な状態にあり
外界の作用を受けます

328
00:20:58,025 --> 00:21:03,597
物体は常に動的な状態にあり
外界の作用を受けます

329
00:21:03,697 --> 00:21:07,067
アニメーションは違います

330
00:21:07,167 --> 00:21:11,104
アニメーションは
現実の影響を受けませんからね

331
00:21:11,205 --> 00:21:14,608
そこでアニメーションや
ビヘイビアを

332
00:21:14,708 --> 00:21:17,544
会話と考えてみましょう

333
00:21:17,711 --> 00:21:22,349
静的なものから
アニメートされたものへの移行を

334
00:21:22,449 --> 00:21:24,151
考えるのです

335
00:21:24,284 --> 00:21:28,755
ネイサンが後で説明しますので
ここでは簡単に

336
00:21:30,991 --> 00:21:34,761
さて 写真は―

337
00:21:35,062 --> 00:21:38,999
概念上は軽いため
容量が少ないです

338
00:21:39,099 --> 00:21:43,971
一方 アプリケーションは
重く大きいので

339
00:21:44,071 --> 00:21:46,106
容量が当てられています

340
00:21:48,742 --> 00:21:54,047
(拍手)

341
00:21:54,915 --> 00:21:58,218
人間のように考える
インターフェイスについて

342
00:21:58,318 --> 00:22:00,254
お話ししました

343
00:21:58,318 --> 00:22:00,254
お話ししました

344
00:22:03,123 --> 00:22:05,092
レスポンスから始まり

345
00:22:05,292 --> 00:22:10,497
ユーザとつながっているように
感じさせること

346
00:22:10,998 --> 00:22:12,966
空間的一貫性を保って

347
00:22:13,066 --> 00:22:16,069
空間感覚に合わせること

348
00:22:16,503 --> 00:22:18,839
同じ経路で移動すること

349
00:22:19,273 --> 00:22:24,278
予測を助けるため
ジェスチャのヒントを出すこと

350
00:22:24,711 --> 00:22:29,249
軽い操作で
最大の出力を得ること

351
00:22:29,349 --> 00:22:34,021
少ない力で
十分なレスポンスを得ること

352
00:22:35,389 --> 00:22:39,226
インターフェイスの境界を
暗に示し

353
00:22:39,326 --> 00:22:42,963
端に来ても
常に反応すること

354
00:22:43,063 --> 00:22:45,966
トランジションが自然なこと

355
00:22:47,634 --> 00:22:52,239
そしてスムーズな
動的ビヘイビアを設計すること

356
00:22:55,409 --> 00:22:58,979
インターフェイスを
心の一部にするための

357
00:22:59,079 --> 00:23:01,081
原則をお話ししました

358
00:22:59,079 --> 00:23:01,081
原則をお話ししました

359
00:23:01,615 --> 00:23:05,485
ここで同僚のネイサンに
代わります

360
00:23:05,586 --> 00:23:10,157
ユーザや自然界の動きに
合った方法で

361
00:23:10,257 --> 00:23:13,260
設計することについて
お話しします

362
00:23:15,062 --> 00:23:21,869
(拍手)

363
00:23:22,336 --> 00:23:23,237
どうも　チャン

364
00:23:24,004 --> 00:23:25,572
私はネイサンです

365
00:23:25,672 --> 00:23:30,878
動的モーションを使った
デザインについてお話しします

366
00:23:31,979 --> 00:23:37,084
人間の心と体
そして 私たちを取り巻く世界は

367
00:23:37,184 --> 00:23:39,753
常に変化の状態にあります

368
00:23:39,853 --> 00:23:45,893
そのため インターフェイスも
同様のビヘイビアを期待されます

369
00:23:45,993 --> 00:23:51,932
触覚的になるにつれ
高い忠実性が要求されるのです

370
00:23:52,833 --> 00:23:58,005
インターフェイスでは
アニメーションが使われてきました

371
00:23:58,105 --> 00:24:00,073
ボタンがタップされると

372
00:23:58,105 --> 00:24:00,073
ボタンがタップされると

373
00:24:00,174 --> 00:24:03,744
手綱はデザイナーに渡されます

374
00:24:04,077 --> 00:24:09,349
デザイナーの役割は 完璧な
アニメーションを作ることです

375
00:24:09,449 --> 00:24:15,656
完成すると 手綱は
インターフェイスのユーザに戻され

376
00:24:15,756 --> 00:24:17,958
操作が続行されます

377
00:24:18,091 --> 00:24:22,062
いわば
アニメーションと操作は

378
00:24:22,162 --> 00:24:26,567
時系列に沿って
交互に行われるのです

379
00:24:27,968 --> 00:24:32,539
fluidインターフェイスでは
人の持つ動的性質により

380
00:24:32,639 --> 00:24:36,643
デザイナーの手から
主導権が離れます

381
00:24:37,010 --> 00:24:39,580
デザイナーは代わりに

382
00:24:39,680 --> 00:24:44,051
操作時に どのような動きをするか
設計します

383
00:24:45,385 --> 00:24:49,056
そして一連の
動的ビヘイビアとして

384
00:24:49,156 --> 00:24:51,892
常に有効にするのです

385
00:24:53,227 --> 00:24:57,965
今日はこの動的ビヘイビアについて
お話しします

386
00:24:59,099 --> 00:25:03,003
まず
シームレスモーションです

387
00:24:59,099 --> 00:25:03,003
まず
シームレスモーションです

388
00:25:03,270 --> 00:25:05,939
この要素のおかげで

389
00:25:06,039 --> 00:25:09,877
動的モーションが
体の延長のように感じられます

390
00:25:10,878 --> 00:25:12,679
特徴も見ていきます

391
00:25:12,780 --> 00:25:16,850
アニメーションなしでも
インターフェイスに

392
00:25:16,950 --> 00:25:23,590
遊びの要素や特徴 触感を
取り入れることができます

393
00:25:24,491 --> 00:25:30,731
最後に ユーザの動きから
どのように意図を解釈するか

394
00:25:30,831 --> 00:25:32,132
お話しします

395
00:25:32,232 --> 00:25:36,136
ジェスチャを
よく分析することで

396
00:25:36,236 --> 00:25:39,807
不確実性を排除し
意図を読み解きます

397
00:25:41,775 --> 00:25:43,577
では まず始めに―

398
00:25:43,844 --> 00:25:47,815
シームレスモーションとは
何でしょうか？

399
00:25:48,482 --> 00:25:53,020
概念をつかむために
例を見てみましょう

400
00:25:54,354 --> 00:25:58,425
車が一定の速度で
進んでいます

401
00:25:58,525 --> 00:26:02,329
ブレーキをかけると
減速して止まります

402
00:25:58,525 --> 00:26:02,329
ブレーキをかけると
減速して止まります

403
00:26:04,331 --> 00:26:09,169
今度は 位置を描写しながら
見てみましょう

404
00:26:11,305 --> 00:26:15,843
まず 曲線は直線的に
右上に向かいます

405
00:26:15,943 --> 00:26:19,746
速度が一定であることを
意味します

406
00:26:19,847 --> 00:26:21,148
不変です

407
00:26:21,515 --> 00:26:25,986
しかし その後
ゆっくりと曲がり始め

408
00:26:26,320 --> 00:26:28,188
直線と離れます

409
00:26:28,288 --> 00:26:33,627
ブレーキが かかったので
摩擦により減速するのです

410
00:26:34,194 --> 00:26:37,364
曲線の終わりは水平になり

411
00:26:37,464 --> 00:26:41,935
位置が不変になったことを
示します

412
00:26:44,037 --> 00:26:48,976
この曲線はシームレスモーションを
視覚化しています

413
00:26:49,076 --> 00:26:54,681
曲線に切れ目がなく
突然の方向変換もありません

414
00:26:56,049 --> 00:26:58,118
スムーズでシームレスです

415
00:26:58,218 --> 00:27:03,156
ブレーキのような
新しい動的ビヘイビアが加わり

416
00:26:58,218 --> 00:27:03,156
ブレーキのような
新しい動的ビヘイビアが加わり

417
00:27:03,257 --> 00:27:06,760
車に摩擦が
かかった時でもです

418
00:27:08,161 --> 00:27:10,497
車が完全に止まる時も

419
00:27:10,597 --> 00:27:13,333
曲線はスムーズです

420
00:27:13,433 --> 00:27:18,772
車がいつ止まったのか
正確には判別できません

421
00:27:19,773 --> 00:27:24,978
fluidインターフェイスの話で
なぜ車の例なのか？

422
00:27:25,612 --> 00:27:29,817
なぜなら 物質界の特性を
応用できると

423
00:27:29,917 --> 00:27:32,019
考えるからです

424
00:27:32,453 --> 00:27:35,823
車の例は
分かりやすいですよね

425
00:27:35,923 --> 00:27:39,693
車のような物体が
どのように動くか

426
00:27:39,827 --> 00:27:42,996
共通認識があるからです

427
00:27:43,764 --> 00:27:45,899
この点が参考になりました

428
00:27:47,034 --> 00:27:53,273
車の動きを完全に
模倣するわけではありませんが

429
00:27:53,373 --> 00:27:56,076
車の動きを応用できます

430
00:27:56,176 --> 00:28:00,514
物質界での物体の動きを
応用するのです

431
00:27:56,176 --> 00:28:00,514
物質界での物体の動きを
応用するのです

432
00:28:00,948 --> 00:28:06,120
それを動的ビヘイビアで使えば
自然な動きになり

433
00:28:06,220 --> 00:28:10,524
共感や信頼感も
生まれやすくなります

434
00:28:11,758 --> 00:28:16,663
物質界を参照して
動的ビヘイビアを設計することは

435
00:28:16,763 --> 00:28:20,100
以前からiPhoneで
行われています

436
00:28:20,801 --> 00:28:25,272
おもちゃの車を押すのと
同じくらい簡単に

437
00:28:25,439 --> 00:28:28,742
子供でも簡単に
スクロールできます

438
00:28:30,644 --> 00:28:36,250
スクロールについて
主な特徴は何でしょうか？

439
00:28:37,518 --> 00:28:42,956
１つは 我々の共通認識を
利用していることです

440
00:28:43,056 --> 00:28:48,095
物体の動きや物体への
作用に関する共通認識です

441
00:28:49,429 --> 00:28:52,900
コンテンツの動きは
シームレスです

442
00:28:53,000 --> 00:28:56,737
操作時や
コンテンツをドラッグする時

443
00:28:56,904 --> 00:29:01,542
体は滑らかなので
動きにも流動性があります

444
00:28:56,904 --> 00:29:01,542
体は滑らかなので
動きにも流動性があります

445
00:29:02,276 --> 00:29:04,645
コンテンツを離すと

446
00:29:04,745 --> 00:29:07,581
減速し やがて止まります

447
00:29:07,848 --> 00:29:13,187
インターフェイスに置く時の
推進力が維持されるためです

448
00:29:14,621 --> 00:29:18,959
スクロールの際の
摩擦量は一定なので

449
00:29:19,059 --> 00:29:22,396
予測可能で
簡単に習得できます

450
00:29:23,430 --> 00:29:27,601
最後に コンテンツは
ゆっくりと止まるので

451
00:29:27,701 --> 00:29:31,839
正確には いつ止まったか
分かりません

452
00:29:32,372 --> 00:29:35,776
終わりという感覚がないので

453
00:29:35,876 --> 00:29:41,381
常に コンテンツを
動かせるという感覚があります

454
00:29:41,482 --> 00:29:45,786
スクロールが際限なく
続くような感覚があるので

455
00:29:45,886 --> 00:29:49,423
何かが終わるのを
待つ必要はありません

456
00:29:51,658 --> 00:29:53,994
実世界のビヘイビアは

457
00:29:54,094 --> 00:29:57,798
無数の特徴により作られます

458
00:29:57,931 --> 00:30:01,568
今回は １つの
特徴を取り上げます

459
00:29:57,931 --> 00:30:01,568
今回は １つの
特徴を取り上げます

460
00:30:01,668 --> 00:30:06,406
我々の設計作業で
不可欠となる要素です

461
00:30:07,841 --> 00:30:10,444
花の質感にご注目を

462
00:30:10,611 --> 00:30:14,581
自然が生み出す
この繊維の特徴は

463
00:30:14,948 --> 00:30:18,685
元へ戻ろうとする
回復力を持つ点です

464
00:30:19,853 --> 00:30:25,993
圧力や張力がかかっても
この回復力があることで

465
00:30:26,093 --> 00:30:28,529
花は元の状態に戻ります

466
00:30:29,429 --> 00:30:32,666
人間の体も
高い回復力を持ちます

467
00:30:33,033 --> 00:30:37,171
我々が 驚くほど長時間
動けるのは

468
00:30:37,271 --> 00:30:42,609
筋力のためではなく
力を抜く能力があるためです

469
00:30:43,076 --> 00:30:45,612
回復できるということです

470
00:30:46,079 --> 00:30:49,583
筋肉を
リラックスさせることで

471
00:30:49,683 --> 00:30:54,121
エネルギーを維持し
自然な感覚を得ます

472
00:30:55,556 --> 00:30:59,359
iPhone Xも
同様の回復力を有します

473
00:30:59,760 --> 00:31:05,399
アイコンをタップすると
アプリケーションが起動し

474
00:30:59,760 --> 00:31:05,399
アイコンをタップすると
アプリケーションが起動し

475
00:31:05,799 --> 00:31:08,268
スクリーンに表示されます

476
00:31:08,368 --> 00:31:10,204
下部からスワイプすると

477
00:31:10,304 --> 00:31:14,374
ホーム画面の
元の位置に戻ります

478
00:31:16,610 --> 00:31:19,046
スクロールも同様で

479
00:31:19,146 --> 00:31:22,850
やりすぎると
ゴムのように動きます

480
00:31:23,083 --> 00:31:25,052
指を画面から離すと

481
00:31:25,285 --> 00:31:29,123
コンテンツが
画面内に収まります

482
00:31:29,223 --> 00:31:33,927
これにより 次の
スクロールに備えるのです

483
00:31:35,429 --> 00:31:41,034
では スクリーンの裏側で
何が起きているか見てみます

484
00:31:42,603 --> 00:31:47,908
バネがついたボールを
コンテンツだとしましょう

485
00:31:49,610 --> 00:31:51,979
接続しているほうの端が

486
00:31:52,079 --> 00:31:55,849
画面に表示される
“現在地”です

487
00:31:56,417 --> 00:32:01,455
元に戻ろうとする力により
この現在地は

488
00:31:56,417 --> 00:32:01,455
元に戻ろうとする力により
この現在地は

489
00:32:01,555 --> 00:32:05,826
反対側の端“ターゲット”に
引っ張られます

490
00:32:05,926 --> 00:32:09,630
これがコンテンツの場所に
影響します

491
00:32:10,964 --> 00:32:15,769
バネが現在地を
ターゲットに引き寄せました

492
00:32:16,403 --> 00:32:19,773
バネが見せる
シームレスな動きは

493
00:32:19,873 --> 00:32:24,144
このビヘイビアに備わった
固有の特徴です

494
00:32:24,845 --> 00:32:30,384
滑らかなインターフェイスに
有用な特徴と言えます

495
00:32:30,717 --> 00:32:35,889
ビヘイビア自体に備わり
無料で手に入る特徴です

496
00:32:37,791 --> 00:32:41,595
我々も このビヘイビアを
活用します

497
00:32:41,695 --> 00:32:46,467
ボールに ターゲットの
場所さえ示せば

498
00:32:46,567 --> 00:32:49,136
シームレスに動くのです

499
00:32:49,403 --> 00:32:52,706
一方で スピードや
オーバーシュートについて

500
00:32:52,806 --> 00:32:56,310
コントロールするには
どうすれば？

501
00:32:56,977 --> 00:33:01,615
ボールを大きく
重くする手があります

502
00:32:56,977 --> 00:33:01,615
ボールを大きく
重くする手があります

503
00:33:02,082 --> 00:33:05,819
ボールの慣性に
変化を与えるでしょう

504
00:33:05,919 --> 00:33:08,789
動き出したり
停止するタイミングを

505
00:33:08,889 --> 00:33:12,326
遅らせることになります

506
00:33:12,426 --> 00:33:15,195
オーバーシュートも
抑えられます

507
00:33:16,530 --> 00:33:21,768
バネの引っ張る力を
大きくする方法もあります

508
00:33:22,002 --> 00:33:25,973
ボールに適用される力が
大きくなり

509
00:33:26,073 --> 00:33:28,742
ターゲットに速く近付きます

510
00:33:30,010 --> 00:33:33,480
または車のブレーキのように

511
00:33:33,714 --> 00:33:39,419
ボール表面の減衰力や
摩擦力を変える手もあります

512
00:33:39,553 --> 00:33:43,457
ボールのスピードに
ブレーキをかけ

513
00:33:43,557 --> 00:33:46,226
オーバーシュートも
抑制します

514
00:33:47,528 --> 00:33:51,165
ボールやバネの
物理的性質は

515
00:33:51,265 --> 00:33:55,536
科学の法則に
従っていると言えます

516
00:33:55,636 --> 00:33:59,606
しかしスクリーン上での
ビヘイビアに関しては

517
00:33:59,706 --> 00:34:04,678
不便な面もあり
設計上 調整が必要です

518
00:33:59,706 --> 00:34:04,678
不便な面もあり
設計上 調整が必要です

519
00:34:05,679 --> 00:34:10,484
そこでツールを使用する
設計者のニーズに応え

520
00:34:10,583 --> 00:34:14,121
インターフェイスに
手を加えます

521
00:34:14,688 --> 00:34:21,128
設計上 使いやすくするには
どう簡易化すべきでしょうか

522
00:34:22,295 --> 00:34:28,902
バネの基本的な要素である
質量と減衰力は保持し

523
00:34:29,002 --> 00:34:32,739
２つのシンプルな
法則に絞りました

524
00:34:33,239 --> 00:34:38,045
１つはオーバーシュートを
コントロールする減衰力

525
00:34:38,145 --> 00:34:41,348
オーバーシュートがない
減衰力100％から

526
00:34:41,447 --> 00:34:45,518
バネが不安定に揺れる
０％までコントロールします

527
00:34:46,920 --> 00:34:51,024
２つ目の要素は
“反応”です

528
00:34:51,891 --> 00:34:56,530
現在地がターゲットに達する
速さを決めます

529
00:34:56,730 --> 00:35:00,134
元に戻ろうとする力について
話す時

530
00:34:56,730 --> 00:35:00,134
元に戻ろうとする力について
話す時

531
00:35:00,234 --> 00:35:05,038
“持続時間”という言葉を
我々は使いません

532
00:35:05,138 --> 00:35:09,476
持続的な変化を
強調してしまうためです

533
00:35:09,576 --> 00:35:13,547
バネはどこでも
持続的に動くものです

534
00:35:14,248 --> 00:35:19,052
技術的には“減衰比”や
“周波数応答”と呼ばれます

535
00:35:19,153 --> 00:35:22,723
もし そのほうが
分かりやすければ

536
00:35:22,823 --> 00:35:25,459
専門用語を使ってください

537
00:35:27,561 --> 00:35:32,499
回復力をコントロールする
２つの要素を与えました

538
00:35:33,801 --> 00:35:38,305
しかし他にも
可能性は無数にあります

539
00:35:38,405 --> 00:35:43,811
２つの要素を取り入れるにも
多くの方法があり

540
00:35:43,911 --> 00:35:46,113
ビヘイビアも変わります

541
00:35:46,914 --> 00:35:50,484
アプリケーションの
特徴を作るための

542
00:35:50,584 --> 00:35:52,820
取り入れ方とは？

543
00:35:54,054 --> 00:35:59,827
“デバイスはツールである”を
念頭に置きます

544
00:36:00,127 --> 00:36:05,799
ツールは目的にかなった
使用法をするものです

545
00:36:06,533 --> 00:36:12,406
不要な動きをさせることは
望ましくありません

546
00:36:13,140 --> 00:36:15,642
シンプルに考えましょう

547
00:36:15,976 --> 00:36:20,614
バネのオーバーシュートは
避けるべきです

548
00:36:21,715 --> 00:36:24,718
減衰力100％で始めるか

549
00:36:24,818 --> 00:36:28,489
オーバーシュートが
起きないよう調整します

550
00:36:28,589 --> 00:36:32,459
スムーズでシームレスな
動きを得られ

551
00:36:32,593 --> 00:36:37,231
作業中のタスクを
妨げることもありません

552
00:36:39,266 --> 00:36:44,438
では弾む動きは
どこで使われるのが適切か？

553
00:36:45,072 --> 00:36:49,877
動かすジェスチャ自体に
推進力があるなら

554
00:36:50,144 --> 00:36:53,280
オーバーシュートとして
反映すべきです

555
00:36:54,381 --> 00:36:59,153
ジェスチャに推進力があり
オーバーシュートがない場合

556
00:36:59,253 --> 00:37:05,626
正しい反応がないという
不満感を覚えるでしょう

557
00:36:59,253 --> 00:37:05,626
正しい反応がないという
不満感を覚えるでしょう

558
00:37:07,227 --> 00:37:09,997
例えば
ミュージックAppです

559
00:37:10,297 --> 00:37:15,335
画面下部に現在 再生中の
曲名などが表示され

560
00:37:15,469 --> 00:37:18,672
タップすると
全画面に現れます

561
00:37:20,207 --> 00:37:25,879
タップ自体には 方向を伴う
推進力は発生しないので

562
00:37:25,979 --> 00:37:29,717
100％の減衰力を使い
オーバーシュートを防ぎます

563
00:37:31,018 --> 00:37:36,723
スワイプで再生中画面を
閉じると 推進力が発生

564
00:37:36,823 --> 00:37:40,627
減衰力80％で
弾力ある動きを生み

565
00:37:40,728 --> 00:37:43,364
ジェスチャに反応します

566
00:37:46,533 --> 00:37:51,104
機能的な面でも
弾む動きは有用です

567
00:37:51,271 --> 00:37:55,509
例えば ユーザに
ヒントを与える場合です

568
00:37:57,111 --> 00:38:01,281
iPhone Xの
ロック画面にあるのは

569
00:37:57,111 --> 00:38:01,281
iPhone Xの
ロック画面にあるのは

570
00:38:01,548 --> 00:38:04,785
フラッシュライトと
カメラのボタンです

571
00:38:06,453 --> 00:38:09,456
誤操作による起動を防ぐため

572
00:38:09,556 --> 00:38:14,161
フラッシュライトの起動には
意図的な動作が必要です

573
00:38:14,862 --> 00:38:19,133
しかし その方法を
知らなかったとします

574
00:38:19,500 --> 00:38:22,002
タップするとボタンが弾み

575
00:38:22,102 --> 00:38:26,306
ボタンが機能していることを
示します

576
00:38:26,940 --> 00:38:31,345
また操作に対し
反応していると分かります

577
00:38:31,445 --> 00:38:36,049
これによりユーザは
もっとしっかり押すことで

578
00:38:36,417 --> 00:38:40,320
起動するという
ヒントを得るのです

579
00:38:40,487 --> 00:38:44,458
弾む動きは
何かを暗示するのに便利です

580
00:38:47,361 --> 00:38:51,431
ここまで“動き”によって
物を動かし

581
00:38:51,531 --> 00:38:55,736
質量や画面上での表示を
変化させました

582
00:38:56,370 --> 00:38:59,907
動きは より多様な
変化を起こします

583
00:39:00,007 --> 00:39:05,746
例えば光や色
感触や感覚 音さえもです

584
00:39:05,846 --> 00:39:09,883
我々が感知できる
多くの変化に起因します

585
00:39:11,552 --> 00:39:14,888
我々は この“動き”を
もっと活用し

586
00:39:14,988 --> 00:39:18,892
アプリケーションに
適用できると考えます

587
00:39:19,760 --> 00:39:22,296
動きへの動的ビヘイビアと

588
00:39:22,396 --> 00:39:26,033
音や触覚への
動的ビヘイビアを結合

589
00:39:26,166 --> 00:39:30,604
インターフェイスの表情を
根本から変えます

590
00:39:35,375 --> 00:39:40,948
ユーザが感知する
ジェスチャの結果を変えます

591
00:39:41,048 --> 00:39:44,418
ただのスクロールという
挙動から

592
00:39:44,518 --> 00:39:48,989
感触のある
インターフェイスになります

593
00:39:51,725 --> 00:39:56,630
アプリケーションを作る際
考えるべき最後の１点は

594
00:39:57,164 --> 00:40:01,401
特徴に結合性を
感じられるかどうかです

595
00:39:57,164 --> 00:40:01,401
特徴に結合性を
感じられるかどうかです

596
00:40:02,402 --> 00:40:03,737
説明します

597
00:40:04,938 --> 00:40:08,275
同じアプリケーションや
システム内で

598
00:40:08,375 --> 00:40:12,512
同種のビヘイビアが
保たれることは大切です

599
00:40:12,980 --> 00:40:15,416
例えばスクロールです

600
00:40:15,516 --> 00:40:19,353
ページを下に送るのは
スクロールビヘイビアです

601
00:40:19,453 --> 00:40:21,088
ステータスバーをタップし

602
00:40:21,188 --> 00:40:24,625
上部にスクロールするのは
回復のビヘイビア

603
00:40:24,758 --> 00:40:29,563
２つの場合で 動きに
差が出てはいけません

604
00:40:29,663 --> 00:40:33,133
異なる２つの
ビヘイビアを用いて

605
00:40:33,233 --> 00:40:35,869
動きを起こす場合も同様です

606
00:40:36,870 --> 00:40:40,841
１つの相互作用だけでなく
アプリケーション全体に

607
00:40:41,175 --> 00:40:42,943
適用されるべきです

608
00:40:43,043 --> 00:40:46,580
設定したアプリケーションの
特徴を

609
00:40:46,680 --> 00:40:49,550
全体を通じて踏襲します

610
00:40:49,650 --> 00:40:52,786
そうすればユーザは
ビヘイビアを

611
00:40:52,886 --> 00:40:55,188
簡単に習得できます

612
00:40:55,289 --> 00:41:01,428
我々は繰り返しから学び
それを他に適用するからです

613
00:40:55,289 --> 00:41:01,428
我々は繰り返しから学び
それを他に適用するからです

614
00:41:06,133 --> 00:41:08,869
続いて お話しするのは

615
00:41:09,169 --> 00:41:13,374
意図を伴う
動的モーションについてです

616
00:41:17,377 --> 00:41:20,180
例えばボタンの場合

617
00:41:20,914 --> 00:41:23,984
ジェスチャの意図は
明らかです

618
00:41:24,084 --> 00:41:28,589
画面に異なる
３つのアイコンがあります

619
00:41:29,056 --> 00:41:32,426
何を意図するか明らかですね

620
00:41:33,961 --> 00:41:36,030
スワイプはどうでしょう

621
00:41:36,363 --> 00:41:39,166
意図が 即座には
分かりません

622
00:41:39,466 --> 00:41:43,971
モーションは意図を
記号化しています

623
00:41:44,171 --> 00:41:46,573
ですから意図を解釈し

624
00:41:46,673 --> 00:41:51,311
そのモーションへの
対応を決めることが大切です

625
00:41:52,412 --> 00:41:53,947
例を見てみます

626
00:41:54,848 --> 00:41:58,552
FaceTime通話を
かけるとします

627
00:41:58,952 --> 00:42:05,092
画面の端に 自分が映った
小さなウインドウが現れます

628
00:41:58,952 --> 00:42:05,092
画面の端に 自分が映った
小さなウインドウが現れます

629
00:42:05,192 --> 00:42:08,729
これが 相手に
見えている映像です

630
00:42:09,563 --> 00:42:13,634
“ピクチャ･イン･ピクチャ”
略して“PIP”です

631
00:42:14,701 --> 00:42:19,473
浮いているように見せ
移動できることを暗示

632
00:42:19,807 --> 00:42:25,379
軽いフリックで 好きな
コーナーへ移動できます

633
00:42:27,781 --> 00:42:32,152
“再生”“停止”など
先ほどの３つのボタンと比べ

634
00:42:32,452 --> 00:42:34,021
何が違うでしょう

635
00:42:35,055 --> 00:42:40,260
この場合 目に見えない
４つの区画が存在します

636
00:42:40,427 --> 00:42:45,799
タップできるような
明らかな表示はありません

637
00:42:45,899 --> 00:42:50,304
ジェスチャを通して
起きたモーションに注目し

638
00:42:50,404 --> 00:42:54,842
どの区画へ行くべきか
意図を読み取ります

639
00:42:55,476 --> 00:42:59,980
３つの区画は
“ジェスチャの終点”です

640
00:43:00,314 --> 00:43:04,084
PIPにおける我々の目標は

641
00:43:04,184 --> 00:43:07,021
正しい終点を見つけること

642
00:43:07,254 --> 00:43:12,593
そして意図に応じた終点と
結び付けることです

643
00:43:15,095 --> 00:43:20,901
１つ目は PIPをドラッグし
１番近い終点と結ぶ方法

644
00:43:22,035 --> 00:43:26,640
隣の区画に
PIPを移動できました

645
00:43:27,307 --> 00:43:32,312
しかし場所が少し遠くなると
問題が発生します

646
00:43:33,547 --> 00:43:38,385
希望の区画と結ぶため
PIPを画面の半分以上

647
00:43:38,485 --> 00:43:41,155
ドラッグする必要があります

648
00:43:41,255 --> 00:43:45,025
これではユーザの意図を
読めていません

649
00:43:45,125 --> 00:43:47,394
ここでフリックしてみると

650
00:43:47,995 --> 00:43:52,332
意に反し １番近い区画に
戻ってしまいます

651
00:43:53,300 --> 00:43:56,070
問題は 位置だけを見て

652
00:43:56,170 --> 00:43:59,807
PIPの推進力を
無視している点です

653
00:43:59,907 --> 00:44:02,509
速度も考慮していません

654
00:43:59,907 --> 00:44:02,509
速度も考慮していません

655
00:44:03,277 --> 00:44:06,013
正しい終点を見極めるのに

656
00:44:06,113 --> 00:44:09,883
推進力を活用する方法を
考えます

657
00:44:11,485 --> 00:44:17,191
いったん終点は忘れて
一歩引いて見てみましょう

658
00:44:17,624 --> 00:44:20,527
問題をシンプルに考えます

659
00:44:22,229 --> 00:44:27,201
画面上でコンテンツを
移動するのが最終目的なら

660
00:44:27,634 --> 00:44:32,840
スクロールという強力で
最適なビヘイビアがあります

661
00:44:34,174 --> 00:44:37,478
使わない手はありません

662
00:44:38,445 --> 00:44:43,650
スクロール時に どこまで
コンテンツを動かすか

663
00:44:43,951 --> 00:44:46,186
直観的に理解しています

664
00:44:47,287 --> 00:44:52,059
そこで今度は
PIPをスクロールしてみると

665
00:44:52,292 --> 00:44:54,595
滑るように動き 止まります

666
00:44:54,695 --> 00:45:00,033
スクロールと同じ
減速の方法を使っています

667
00:44:54,695 --> 00:45:00,033
スクロールと同じ
減速の方法を使っています

668
00:45:00,834 --> 00:45:04,338
他で習得した特徴を
適用するという

669
00:45:04,638 --> 00:45:07,941
メリットを利用しています

670
00:45:08,042 --> 00:45:12,079
同一システムで
同じビヘイビアを用いる―

671
00:45:12,646 --> 00:45:13,814
メリットですね

672
00:45:15,382 --> 00:45:21,355
このPIPの位置の話は
実際の話ではありませんから

673
00:45:21,455 --> 00:45:23,991
インターフェイスを
お見せしません

674
00:45:24,091 --> 00:45:26,160
ここでは“予測”を行います

675
00:45:26,894 --> 00:45:29,196
PIPがフリックされると

676
00:45:29,296 --> 00:45:33,567
その速度と減速率を
掛け合わせます

677
00:45:33,667 --> 00:45:38,972
スクロールで進むであろう
位置を予測するのです

678
00:45:40,974 --> 00:45:44,745
１番近い終点を
探すのではなく

679
00:45:44,845 --> 00:45:50,350
予測される位置を計算し
移動する方法を使いました

680
00:45:51,652 --> 00:45:56,523
これにより対角の区画へも
軽いフリックで

681
00:45:57,124 --> 00:46:00,027
期待通りに移動します

682
00:45:57,124 --> 00:46:00,027
期待通りに移動します

683
00:46:03,297 --> 00:46:08,502
推進力を予測する考え方は
かなり有用です

684
00:46:08,602 --> 00:46:12,873
コーディングの一例を
ご紹介しますので

685
00:46:12,973 --> 00:46:15,275
ぜひお試しください

686
00:46:16,143 --> 00:46:20,147
PIPの初期速度と
減速率を―

687
00:46:20,514 --> 00:46:22,282
まずは与えます

688
00:46:22,783 --> 00:46:28,555
それらの値を元に
動きの終点が取得できます

689
00:46:28,889 --> 00:46:30,157
簡単ですね

690
00:46:31,625 --> 00:46:36,630
FaceTimeでのパン操作の
コーディング例です

691
00:46:37,698 --> 00:46:41,301
“UIScrollView.
DecelerationRate”を使っています

692
00:46:41,401 --> 00:46:47,407
一般的なスクロールの感覚に
合わせているわけです

693
00:46:48,075 --> 00:46:51,912
それを使って
予測を行っています

694
00:46:52,012 --> 00:46:58,218
PIPの速度と減速率から
PIPの位置を仮想し―

695
00:46:59,486 --> 00:47:05,459
得られた位置から
最寄りのコーナーを特定します

696
00:46:59,486 --> 00:47:05,459
得られた位置から
最寄りのコーナーを特定します

697
00:47:06,060 --> 00:47:08,729
そしてそこに
PIPを送ります

698
00:47:11,365 --> 00:47:15,469
今のように移動の終点を
算出する際に―

699
00:47:16,236 --> 00:47:20,374
予測を行う手法は
とても便利です

700
00:47:20,474 --> 00:47:25,245
ジェスチャの推進力を
尊重できます

701
00:47:26,213 --> 00:47:30,918
この予測の関数は
“位置”だけでなく―

702
00:47:31,018 --> 00:47:37,057
“スケール”や“回転”
２つの組み合わせにも使えます

703
00:47:37,658 --> 00:47:40,394
かなり万能なツールです

704
00:47:40,494 --> 00:47:44,231
これを使えば
動的モーションが

705
00:47:44,331 --> 00:47:49,436
自分の延長のように
感じられるはずです

706
00:47:52,139 --> 00:47:56,110
以上が動的モーションを
意識した設計です

707
00:47:56,643 --> 00:47:59,646
ビヘイビアと
インタラクションは

708
00:47:59,747 --> 00:48:03,350
シームレスであるのが
理想です

709
00:47:59,747 --> 00:48:03,350
シームレスであるのが
理想です

710
00:48:05,419 --> 00:48:10,591
みんなが持っている
物理的な直感を頼りましょう

711
00:48:10,691 --> 00:48:15,429
子供の頃に学んだ
“物体はどう動くか”こそが

712
00:48:15,529 --> 00:48:19,600
動的なインターフェイスの
要となります

713
00:48:21,201 --> 00:48:24,405
弾む動きは
目的を持って使い―

714
00:48:24,705 --> 00:48:27,841
本当に必要か
見極めてください

715
00:48:28,142 --> 00:48:32,045
何か特徴や感触を
付け加える際は

716
00:48:32,146 --> 00:48:34,581
実用性を考慮します

717
00:48:36,083 --> 00:48:38,919
最後に
推進力の予測でしたね

718
00:48:39,019 --> 00:48:42,756
位置以外にも
使える情報を全て使い

719
00:48:42,856 --> 00:48:49,196
ユーザの意思に沿った
モーションを実現させましょう

720
00:48:50,931 --> 00:48:55,702
もう少し深く
滑らかなレスポンスについて

721
00:48:55,802 --> 00:48:58,705
同僚のマーコスが
掘り下げます

722
00:48:58,805 --> 00:48:59,940
ありがとうございました

723
00:49:00,040 --> 00:49:03,110
(拍手)

724
00:49:05,379 --> 00:49:06,346
良かったよ

725
00:49:07,548 --> 00:49:08,682
ありがとう ネイサン

726
00:49:13,287 --> 00:49:14,421
こんにちは

727
00:49:14,822 --> 00:49:16,123
マーコスです

728
00:49:16,557 --> 00:49:21,328
滑らかさがいかに大切かを
これまで見てきました

729
00:49:21,628 --> 00:49:25,866
その多くは
インタラクションから生じます

730
00:49:26,567 --> 00:49:28,135
そこで 私からは―

731
00:49:28,235 --> 00:49:32,806
ジェスチャの検出方法を
紹介したいと思います

732
00:49:33,240 --> 00:49:38,679
続いて効果的なジェスチャの
設計方法を説明します

733
00:49:42,149 --> 00:49:47,187
まずは主要なジェスチャの
設計ポイントを見てから―

734
00:49:47,754 --> 00:49:53,193
インタラクションの
原則についてお話しします

735
00:49:53,994 --> 00:49:58,932
ジェスチャが複数の時の
処理法も説明します

736
00:50:00,234 --> 00:50:05,172
手始めに 極めてシンプルな
タップの設計です

737
00:50:05,572 --> 00:50:10,544
“タップに設計など
必要ない”と思いますよね？

738
00:50:10,644 --> 00:50:13,981
意外とそうでもないんです

739
00:50:14,681 --> 00:50:18,418
ボタンのタップを例に
見てみます

740
00:50:18,519 --> 00:50:21,088
おなじみの計算機ですね

741
00:50:24,591 --> 00:50:29,563
タッチされた瞬間に
ボタンはハイライトされます

742
00:50:30,030 --> 00:50:34,268
ボタンが問題なく
反応している証しです

743
00:50:34,601 --> 00:50:38,605
でも指を離さないと
タップは検知されません

744
00:50:40,073 --> 00:50:44,344
タップ領域には
余裕を持たせています

745
00:50:44,445 --> 00:50:47,848
タップが
より快適になりますし

746
00:50:47,948 --> 00:50:52,085
誤操作によるキャンセルも
回避できます

747
00:50:53,220 --> 00:50:55,322
チャンも言っていましたが

748
00:50:55,422 --> 00:50:58,759
操作途中で考えが
変わることもあります

749
00:50:58,859 --> 00:51:03,997
タップ領域の外で指を離せば
タップは中止できます

750
00:50:58,859 --> 00:51:03,997
タップ領域の外で指を離せば
タップは中止できます

751
00:51:05,165 --> 00:51:07,868
逆に
スワイプで領域内に戻れば

752
00:51:07,968 --> 00:51:10,804
タップ操作は継続されます

753
00:51:13,040 --> 00:51:15,008
次のジェスチャは―

754
00:51:15,676 --> 00:51:17,911
スワイプです

755
00:51:18,479 --> 00:51:21,248
iOSの主要なジェスチャの
１つであり

756
00:51:21,348 --> 00:51:25,486
スクロールを始め
多くの動作に使われています

757
00:51:26,420 --> 00:51:29,623
しかし
使い道や呼び方に関係なく

758
00:51:29,723 --> 00:51:32,459
根本的な原則は同じです

759
00:51:33,427 --> 00:51:37,331
画像のドラッグに
スワイプを使った例です

760
00:51:38,298 --> 00:51:42,870
画像に触れた瞬間
インタラクションが始まります

761
00:51:46,840 --> 00:51:51,879
でも このジェスチャが
スワイプだと認識させるには

762
00:51:51,979 --> 00:51:55,115
一定の距離の移動が必要です

763
00:51:55,649 --> 00:52:00,220
“ヒステリシス”と呼ぶ距離で
iOSでは10ポイントです

764
00:51:55,649 --> 00:52:00,220
“ヒステリシス”と呼ぶ距離で
iOSでは10ポイントです

765
00:52:01,221 --> 00:52:05,225
この距離に届くと
スワイプが始まります

766
00:52:06,060 --> 00:52:09,196
この時 スワイプの向きも
判断します

767
00:52:09,296 --> 00:52:12,199
横か縦かといった具合です

768
00:52:12,299 --> 00:52:16,904
例は挙げませんが
時として非常に役立ちます

769
00:52:18,005 --> 00:52:22,209
スワイプが検出され
開始位置が定まりました

770
00:52:22,643 --> 00:52:27,881
以降は指と画像が
一緒に動く必要があります

771
00:52:28,082 --> 00:52:33,387
ドラッグポイントは
画像の真ん中ではありません

772
00:52:34,087 --> 00:52:37,958
ドラッグ中は
位置を記録しておきます

773
00:52:38,058 --> 00:52:41,161
終了時に
最終位置は使いません

774
00:52:41,261 --> 00:52:47,134
動きの履歴を使って
滑らかな動きを実現します

775
00:52:50,437 --> 00:52:54,141
大事なのは
指の動きとコンテンツを

776
00:52:54,241 --> 00:52:56,777
１対１で連動させることです

777
00:52:57,211 --> 00:53:01,582
コンテンツがジェスチャを
離れてはいけません

778
00:52:57,211 --> 00:53:01,582
コンテンツがジェスチャを
離れてはいけません

779
00:53:02,549 --> 00:53:04,751
iOSの原則の１つです

780
00:53:04,885 --> 00:53:08,689
スクロールできるデバイスは
快適ですね

781
00:53:10,157 --> 00:53:15,095
１対１の連動が途絶えれば
私たちは瞬時に

782
00:53:15,195 --> 00:53:16,864
それに気付きます

783
00:53:16,964 --> 00:53:18,232
スクロール中なら―

784
00:53:18,332 --> 00:53:22,102
それはコンテンツの
終わりを意味します

785
00:53:24,171 --> 00:53:27,374
タッチスクリーン以外でも
同じです

786
00:53:27,474 --> 00:53:32,746
Apple TVのインターフェイスが
良い例です

787
00:53:33,280 --> 00:53:36,417
指で直接
触れなくても大丈夫

788
00:53:36,517 --> 00:53:39,820
操作とインターフェイスが
連動していれば

789
00:53:39,920 --> 00:53:43,424
快適な動作が
実現されるのです

790
00:53:47,394 --> 00:53:52,633
もう１つ大事なのは 常に
フィードバックを行うこと

791
00:53:52,733 --> 00:53:57,738
あらゆるインタラクションに
言えることです

792
00:53:58,205 --> 00:54:01,542
フラッシュライトボタンを
再度 見てみます

793
00:53:58,205 --> 00:54:01,542
フラッシュライトボタンを
再度 見てみます

794
00:54:01,642 --> 00:54:05,412
指の圧力に応じて
大きさが変化します

795
00:54:05,646 --> 00:54:10,718
システムがジェスチャに
反応していることと―

796
00:54:10,818 --> 00:54:15,489
強く押せばライトが
つくことを教えています

797
00:54:16,990 --> 00:54:21,729
Apple TVのフォーカスエンジンも
良い例です

798
00:54:22,429 --> 00:54:26,600
Siri Remote上の動きは
常に画面に反映されます

799
00:54:26,833 --> 00:54:29,903
おかげで
選択中のアイテムや―

800
00:54:30,104 --> 00:54:35,042
選択対象の変化 動きの向きも
ひと目で分かります

801
00:54:37,544 --> 00:54:42,750
ジェスチャ中は必ず
反応を返す必要があります

802
00:54:42,950 --> 00:54:47,121
そのため
ジェスチャの検出が遅れる―

803
00:54:47,221 --> 00:54:51,792
UISwipeGestureRecognizerの
使用は避けましょう

804
00:54:52,092 --> 00:54:54,294
代わりに UITouchや

805
00:54:54,395 --> 00:54:59,633
他のジェスチャリコグナイザを
使いましょう

806
00:55:00,367 --> 00:55:05,739
位置 速度 強さなど
あらゆる情報を使うためです

807
00:55:07,875 --> 00:55:13,013
でも 大抵の場合
ジェスチャは複数ですよね

808
00:55:13,347 --> 00:55:15,516
充実した
アプリケーションほど

809
00:55:15,616 --> 00:55:18,819
ジェスチャが多くて複雑です

810
00:55:19,920 --> 00:55:22,823
例えばScroll Viewを使う時

811
00:55:22,923 --> 00:55:27,194
大抵 他のジェスチャも
併用します

812
00:55:27,294 --> 00:55:30,430
この例では
連絡先のスクロールや

813
00:55:30,531 --> 00:55:33,100
プレビューが可能です

814
00:55:35,102 --> 00:55:39,773
フィードバックなしに
最後のジェスチャを待つと

815
00:55:39,873 --> 00:55:41,875
遅延が生じます

816
00:55:42,142 --> 00:55:45,446
もはや
レスポンシブとは言えません

817
00:55:46,680 --> 00:55:51,752
だから ジェスチャは
開始時点で全て検出し―

818
00:55:51,985 --> 00:55:56,323
意図が読めた時点で
不要な分を止めます

819
00:55:58,692 --> 00:56:00,594
連絡先の例です

820
00:55:58,692 --> 00:56:00,594
連絡先の例です

821
00:56:00,694 --> 00:56:04,365
１件押し始めてから
スクロールしたくなりました

822
00:56:04,665 --> 00:56:10,137
直ちに3D Touchを中止し
ジェスチャを切り替えます

823
00:56:13,841 --> 00:56:17,277
ただ
防げない遅延もあります

824
00:56:17,711 --> 00:56:22,916
例えば ダブルタップと
タップが共存する場合です

825
00:56:23,417 --> 00:56:28,155
どちらか判断するため
待つしかないのです

826
00:56:30,390 --> 00:56:34,228
この例では ダブルタップで
拡大や縮小ができる分―

827
00:56:34,328 --> 00:56:38,899
タップによるメニュー表示が
約0.5秒遅れています

828
00:56:39,633 --> 00:56:41,935
こういったケースも
考慮しつつ

829
00:56:42,035 --> 00:56:46,306
可能な限り
遅延を防ぐ努力をしましょう

830
00:56:49,376 --> 00:56:50,544
まとめます

831
00:56:50,644 --> 00:56:55,082
主要なジェスチャの
設計法を説明しました

832
00:56:55,282 --> 00:56:57,284
コンテンツと指の動きは―

833
00:56:57,951 --> 00:57:02,990
１対１で連動させるのが
iOSの原則でしたね

834
00:56:57,951 --> 00:57:02,990
１対１で連動させるのが
iOSの原則でしたね

835
00:57:03,223 --> 00:57:06,994
フィードバックは
常に行い―

836
00:57:07,094 --> 00:57:12,099
ジェスチャが複数の時は
全て始めから検出します

837
00:57:13,700 --> 00:57:19,373
それでは そろそろ
チャンにマイクを戻します

838
00:57:19,673 --> 00:57:20,574
ありがとうございました

839
00:57:20,674 --> 00:57:25,379
(拍手)

840
00:57:25,479 --> 00:57:26,313
お疲れ

841
00:57:28,248 --> 00:57:30,150
皆さん ただいま

842
00:57:30,517 --> 00:57:33,921
滑らかでインタラクティブな

843
00:57:34,021 --> 00:57:38,158
インターフェイスの
作り方を見てきました

844
00:57:38,559 --> 00:57:42,629
だいぶ分かってきたところで
ここからは

845
00:57:42,729 --> 00:57:45,866
fluidインターフェイスの
使い方です

846
00:57:45,966 --> 00:57:48,035
まずは“教える”ことです

847
00:57:48,469 --> 00:57:51,338
ジェスチャ中心の
インターフェイスの弱点は

848
00:57:51,438 --> 00:57:55,476
瞬時に操作方法が
見えないことです

849
00:57:55,576 --> 00:57:57,678
優しく魅力的な形で

850
00:57:57,778 --> 00:58:01,615
賢くユーザを導く必要が
あるのです

851
00:57:57,778 --> 00:58:01,615
賢くユーザを導く必要が
あるのです

852
00:58:02,649 --> 00:58:05,886
１つは“視覚的な
ヒントを示す”手法です

853
00:58:06,053 --> 00:58:09,423
そこら中で見かける
この物体

854
00:58:09,523 --> 00:58:13,193
どこにあっても
上手に使えますね

855
00:58:13,360 --> 00:58:16,396
ひと目で使い方が
分かるからです

856
00:58:17,431 --> 00:58:20,834
iOSでも
同じことを目指しました

857
00:58:20,934 --> 00:58:22,503
例を挙げます

858
00:58:22,970 --> 00:58:27,141
スクロール画面では
あえて最後を隠し―

859
00:58:27,241 --> 00:58:31,912
続きの存在をほのめかし
下へ誘導しています

860
00:58:32,546 --> 00:58:34,982
複数ページのコンテンツでは

861
00:58:35,082 --> 00:58:39,820
インジケータを使って
ページの存在を示します

862
00:58:40,154 --> 00:58:44,958
画面をつかんで
スライドできることを示すには

863
00:58:45,526 --> 00:58:48,128
このようなバーを使います

864
00:58:49,196 --> 00:58:54,301
インタラクティブな要素を
“別の次元で示す”のも手です

865
00:58:54,401 --> 00:59:00,641
１つ上の平面に引き上げて
他の要素と差別化します

866
00:58:54,401 --> 00:59:00,641
１つ上の平面に引き上げて
他の要素と差別化します

867
00:59:01,375 --> 00:59:04,177
オン／オフスイッチが
良い例です

868
00:59:04,278 --> 00:59:07,247
白い丸は動かせると
示すため

869
00:59:07,347 --> 00:59:09,650
丸を少し浮かせました

870
00:59:09,850 --> 00:59:14,021
視覚的に分離することで
性質を示したのです

871
00:59:14,521 --> 00:59:18,625
インターフェイス上の
浮き上がった要素は

872
00:59:18,726 --> 00:59:21,195
“動かせる要素”なわけです

873
00:59:22,629 --> 00:59:23,564
次です

874
00:59:24,231 --> 00:59:30,104
使い方を“教える代わりに
見せる”手法もあります

875
00:59:30,204 --> 00:59:34,341
アニメーションで
ジェスチャを伝えるのです

876
00:59:34,775 --> 00:59:36,777
Safariの例です

877
00:59:37,077 --> 00:59:40,814
Safariでは
タブ左上の“X”を押すと

878
00:59:40,914 --> 00:59:44,818
タブが左にスライドして
消えます

879
00:59:45,385 --> 00:59:48,656
“スライドで消せる”と
ヒントを与え

880
00:59:48,756 --> 00:59:52,826
ジェスチャを
習得させることができます

881
00:59:53,193 --> 00:59:57,097
アニメーションと
ジェスチャを並べれば

882
00:59:57,197 --> 00:59:59,633
“お手本”を示せるのです

883
01:00:02,135 --> 01:00:05,205
あとは
“説明する”手法ですね

884
01:00:05,305 --> 01:00:08,809
使い方を
ストレートに教えるんです

885
01:00:09,376 --> 01:00:11,411
この方法は多用を避け―

886
01:00:11,511 --> 01:00:15,983
頻出するジェスチャにのみ
使いましょう

887
01:00:16,083 --> 01:00:21,321
そして 一度使ったら
使い続けて効果を高めること

888
01:00:21,688 --> 01:00:26,193
レアなジェスチャに使っても
記憶に残りません

889
01:00:26,760 --> 01:00:27,694
ここで…

890
01:00:28,128 --> 01:00:32,199
楽しみと遊び心について
少し話します

891
01:00:32,299 --> 01:00:36,170
fluidインターフェイスが
もたらす―

892
01:00:36,270 --> 01:00:39,339
重要な産物だからです

893
01:00:40,140 --> 01:00:42,843
でも
それらが得られるのは―

894
01:00:42,943 --> 01:00:48,382
今日たくさんご説明した
fluidインターフェイスが

895
01:00:48,482 --> 01:00:52,119
確実に実現できた時だけです

896
01:00:52,219 --> 01:00:57,791
インターフェイスとの
一体感が生まれてくると

897
01:00:57,891 --> 01:01:02,796
学んでいる意識が消え
発見する喜びを感じ始めます

898
01:00:57,891 --> 01:01:02,796
学んでいる意識が消え
発見する喜びを感じ始めます

899
01:01:03,597 --> 01:01:08,736
遊びながらインターフェイスを
発見できたら最高です

900
01:01:08,836 --> 01:01:11,839
とにかく“楽しい”はず

901
01:01:12,639 --> 01:01:15,843
人は何かで
遊ぶのが大好きです

902
01:01:15,943 --> 01:01:20,180
天性の娯楽好きな素質を
利用すればいい

903
01:01:20,480 --> 01:01:24,952
“遊び”こそが心と
インターフェイスをつなぐ鍵です

904
01:01:25,119 --> 01:01:29,223
まずは とにかく
作ってみることです

905
01:01:29,323 --> 01:01:34,061
自分で遊んでみて
人が遊ぶ様子も見てください

906
01:01:34,161 --> 01:01:40,100
そして何を追加すれば
より良くなるか考えるんです

907
01:01:41,101 --> 01:01:47,274
遊べるインターフェイスは
多くの可能性を秘めています

908
01:01:49,276 --> 01:01:55,282
道具としての滑らかさは
どのように構築するのか？

909
01:01:55,482 --> 01:02:00,888
インタラクションを適切に
設計する必要があります

910
01:01:55,482 --> 01:02:00,888
インタラクションを適切に
設計する必要があります

911
01:02:02,156 --> 01:02:07,327
まず 両者の関係は
切り離せないものにします

912
01:02:07,427 --> 01:02:12,900
インタラクションを
後付けにするのではなく―

913
01:02:13,000 --> 01:02:16,637
インターフェイスと
同時に設計します

914
01:02:17,271 --> 01:02:19,673
デモを作ることも大切です

915
01:02:19,773 --> 01:02:23,610
人に見せる目的もありますが

916
01:02:23,710 --> 01:02:29,750
インターフェイスの本質を
自ら確認するためでもあります

917
01:02:30,818 --> 01:02:34,121
見本を用意しておくことで

918
01:02:34,221 --> 01:02:39,126
作り込みながら
新たな発見もできるのです

919
01:02:39,493 --> 01:02:42,963
iPhone Xも
同じ手法で設計しました

920
01:02:43,831 --> 01:02:47,568
実装への
目標設定にも役立ちます

921
01:02:47,668 --> 01:02:52,072
優秀なエンジニアが多い
Appleだからこそ

922
01:02:52,172 --> 01:02:54,107
なせる技ではあります

923
01:02:55,476 --> 01:02:58,312
見本は本当に貴重な存在です

924
01:02:58,412 --> 01:03:02,616
自分で作ったものが
実際はどんな感じか

925
01:02:58,412 --> 01:03:02,616
自分で作ったものが
実際はどんな感じか

926
01:03:02,816 --> 01:03:05,486
知ることができるのです

927
01:03:05,586 --> 01:03:10,691
それって実はすごく
大事なことだったりします

928
01:03:11,725 --> 01:03:12,659
さらに…

929
01:03:13,227 --> 01:03:17,631
形になったアプリケーションは
コピーされにくく

930
01:03:17,731 --> 01:03:20,134
独自性も守られます

931
01:03:22,536 --> 01:03:23,337
ところで…

932
01:03:24,471 --> 01:03:29,376
みんな Multi-Touchが
大好きですよね

933
01:03:29,977 --> 01:03:34,281
触るだけでコンピュータと
やり取りできる

934
01:03:34,548 --> 01:03:36,383
素晴らしいですよね

935
01:03:38,018 --> 01:03:41,321
本日お話した指針は
いずれも―

936
01:03:41,855 --> 01:03:46,026
iPhone Xの設計の
中核を成すものです

937
01:03:46,126 --> 01:03:49,496
操作に機敏に反応する
インターフェイス

938
01:03:49,596 --> 01:03:53,133
動的モーションと
洗練されたジェスチャ

939
01:03:53,434 --> 01:03:57,871
fluidインターフェイス
そのものなのです

940
01:03:58,772 --> 01:04:02,776
インターフェイスが
思考や動きと一致すると

941
01:03:58,772 --> 01:04:02,776
インターフェイスが
思考や動きと一致すると

942
01:04:03,110 --> 01:04:05,546
不思議なことが起きます

943
01:04:05,779 --> 01:04:08,615
コンピュータの感覚は
消え―

944
01:04:08,849 --> 01:04:12,186
自分の延長のように
感じ始めます

945
01:04:14,922 --> 01:04:17,691
これからの
インターフェイスには

946
01:04:17,891 --> 01:04:23,030
人間らしさを取り込むことが
大事だと思うんです

947
01:04:23,430 --> 01:04:26,166
それは決して
負担ではなく―

948
01:04:26,266 --> 01:04:30,337
楽しみと喜びに
満ちたことなのです

949
01:04:30,704 --> 01:04:32,139
ありがとうございました

950
01:04:32,239 --> 01:04:35,275
(拍手)