
1
00:00:07,107 --> 00:00:16,283
(音楽)

2
00:00:22,422 --> 00:00:24,491
おはようございます

3
00:00:25,526 --> 00:00:29,196
(拍手)

4
00:00:29,296 --> 00:00:32,031
エンジニアの
マシュー･バディンです

5
00:00:32,432 --> 00:00:34,635
AccelerateとSIMDの
セッションへようこそ

6
00:00:36,870 --> 00:00:39,439
同僚のチャンと
私が担当します

7
00:00:39,840 --> 00:00:44,478
Accelerateが可能にする
APIについてお話しします

8
00:00:45,312 --> 00:00:50,651
まずはAccelerateの
ハイレベルな概要から始め

9
00:00:51,552 --> 00:00:54,555
ライブラリを
詳しく紹介します

10
00:00:55,489 --> 00:00:57,691
まずはvDSPの例を

11
00:00:58,592 --> 00:01:00,093
２つ紹介します

12
00:00:58,592 --> 00:01:00,093
２つ紹介します

13
00:01:00,928 --> 00:01:03,797
ノイズから信号を
取り出す方法

14
00:01:04,131 --> 00:01:08,302
画像のアーティファクトを
取り除く方法です

15
00:01:09,903 --> 00:01:11,505
次にSIMDへ目を向け

16
00:01:11,972 --> 00:01:15,843
四元数を用いた
三次元回転を紹介します

17
00:01:18,579 --> 00:01:21,248
その後 ルーク･チャンが

18
00:01:21,348 --> 00:01:24,418
Vimageの機能を紹介します

19
00:01:25,185 --> 00:01:27,354
では早速始めましょう

20
00:01:29,323 --> 00:01:31,458
まず最初の議題は

21
00:01:31,558 --> 00:01:33,293
“Accelerateとは何か？”

22
00:01:35,796 --> 00:01:41,034
Accelerateは大量の
プリミティブを提供します

23
00:01:41,368 --> 00:01:44,204
全プラットフォームが
対象です

24
00:01:44,771 --> 00:01:49,076
iOSやmacOS
watchOSやtvOSも含みます

25
00:01:51,445 --> 00:01:55,616
これらはマイクロ
アーキテクチャに組み込まれ

26
00:01:56,049 --> 00:01:58,418
快適な動作を実現します

27
00:01:59,853 --> 00:02:03,290
また省エネにも
役立っています

28
00:01:59,853 --> 00:02:03,290
また省エネにも
役立っています

29
00:02:04,491 --> 00:02:07,494
Accelerate
フレームワークを使えば

30
00:02:07,594 --> 00:02:11,331
アプリケーションは速くなり
バッテリーも長く持ちます

31
00:02:11,798 --> 00:02:14,601
ユーザの満足度も
上がるでしょう

32
00:02:18,338 --> 00:02:20,941
多くのプリミティブを
扱う場合

33
00:02:21,041 --> 00:02:25,779
各ドメインに
グループ分けすると便利です

34
00:02:26,947 --> 00:02:31,418
例えば信号処理された
プリミティブはvDSPへ

35
00:02:32,085 --> 00:02:35,589
例えばFFT
またはDFTとDCTですね

36
00:02:35,689 --> 00:02:38,826
高速フーリエ変換や
離散コサイン変換です

37
00:02:41,094 --> 00:02:43,964
画像処理の
プリミティブもあります

38
00:02:44,631 --> 00:02:47,267
色空間変換で使う
ライブラリです

39
00:02:49,570 --> 00:02:52,239
vForceは
ベクトル型超越関数

40
00:02:52,339 --> 00:02:54,208
サインやコサインです

41
00:02:56,543 --> 00:02:58,812
また高度の線型代数学と

42
00:02:59,813 --> 00:03:01,481
疎行列も可能です

43
00:02:59,813 --> 00:03:01,481
疎行列も可能です

44
00:03:02,983 --> 00:03:06,420
BNNSという
ニューラルネットワークは

45
00:03:06,520 --> 00:03:08,922
ライブラリで管理します

46
00:03:09,656 --> 00:03:12,059
Accelerateではありませんが

47
00:03:12,192 --> 00:03:14,928
関連の深いライブラリです

48
00:03:15,028 --> 00:03:16,930
SIMDもこれに含まれます

49
00:03:17,297 --> 00:03:19,499
CPU用のベクトル計画法です

50
00:03:20,400 --> 00:03:24,538
Compressionには
可逆圧縮機能があります

51
00:03:26,373 --> 00:03:29,610
まずはvDSPについて
説明します

52
00:03:31,345 --> 00:03:36,950
信号処理プリミティブを含む
最新のライブラリであり

53
00:03:37,618 --> 00:03:42,256
足し算や引き算などの
基本的な算術演算

54
00:03:42,956 --> 00:03:45,692
より複雑な演算の例は

55
00:03:46,160 --> 00:03:48,262
畳み込みやフーリエ変換です

56
00:03:49,363 --> 00:03:53,767
アプリケーション開発者にとって
フーリエ変換は厄介ですが

57
00:03:53,867 --> 00:03:56,069
Accelerateを使えば簡単です

58
00:03:56,203 --> 00:03:58,672
いくつかの
コード行を入れるだけ

59
00:03:59,139 --> 00:04:00,307
例があります

60
00:03:59,139 --> 00:04:00,307
例があります

61
00:04:00,707 --> 00:04:02,976
ノイズから
信号を取り出します

62
00:04:14,821 --> 00:04:16,589
これはオーディオ信号です

63
00:04:17,024 --> 00:04:19,892
まだノイズは加えていません

64
00:04:20,293 --> 00:04:22,296
下にスライダがあります

65
00:04:22,963 --> 00:04:25,132
左下でノイズを加えます

66
00:04:28,001 --> 00:04:28,969
入りました

67
00:04:30,437 --> 00:04:33,507
右下でノイズの除去が
可能です

68
00:04:34,541 --> 00:04:35,676
しきい値です

69
00:04:37,211 --> 00:04:39,613
右下にトグルスイッチがあり

70
00:04:40,914 --> 00:04:43,317
異なるドメインを表示します

71
00:04:43,417 --> 00:04:46,920
今はタイムドメインでの
表示ですが

72
00:04:47,020 --> 00:04:51,391
周波数ドメインで
信号を見てみましょう

73
00:04:53,060 --> 00:04:55,195
左側に山形があります

74
00:04:55,329 --> 00:04:57,497
これらが周波数成分です

75
00:04:59,900 --> 00:05:01,902
青の直線もあります

76
00:04:59,900 --> 00:05:01,902
青の直線もあります

77
00:05:02,503 --> 00:05:05,973
しきい値なので
動かしてみます

78
00:05:08,542 --> 00:05:12,112
これから信号に
ノイズを加えます

79
00:05:13,046 --> 00:05:14,915
もっと加えましょう

80
00:05:18,385 --> 00:05:21,288
私が注目しているのは

81
00:05:21,388 --> 00:05:23,423
左にある山形です

82
00:05:23,524 --> 00:05:27,160
一番高い
山形ともいえます

83
00:05:27,628 --> 00:05:31,098
加えたノイズは背景雑音です

84
00:05:31,298 --> 00:05:35,435
低い山形が
ほぼ均等に並びました

85
00:05:37,037 --> 00:05:39,473
ではノイズを取り除きます

86
00:05:39,573 --> 00:05:42,776
しきい値を
少しだけ上げます

87
00:05:44,077 --> 00:05:47,347
何が起きているのかというと

88
00:05:47,447 --> 00:05:52,519
しきい値よりも低い
周波数成分が削除されます

89
00:05:52,619 --> 00:05:57,191
青い直線よりも
低い山形があれば

90
00:05:57,391 --> 00:05:59,393
ノイズと認識されます

91
00:06:01,261 --> 00:06:02,863
さらに上げます

92
00:06:06,200 --> 00:06:08,001
ノイズが消えました

93
00:06:10,003 --> 00:06:13,941
タイムドメインでも
ノイズは消えています

94
00:06:14,041 --> 00:06:17,477
ここで しきい値を外すと

95
00:06:17,911 --> 00:06:21,415
元のノイズ入りの
信号が表示されます

96
00:06:22,716 --> 00:06:24,084
やり方を解説します

97
00:06:29,690 --> 00:06:33,560
最初にすることは
信号の解析です

98
00:06:33,760 --> 00:06:35,195
スイッチを使います

99
00:06:36,163 --> 00:06:40,968
それから周波数成分の
ノイズを見つけ除去します

100
00:06:41,869 --> 00:06:45,038
最後にオーディオ信号を
再構築します

101
00:06:45,372 --> 00:06:46,707
次はコードです

102
00:06:50,177 --> 00:06:54,147
使うのはDCT
離散コサイン変換です

103
00:06:55,415 --> 00:06:57,751
DCT CreateSetupが
見えますね

104
00:06:59,453 --> 00:07:05,259
コンテキストでタイプと
空き容量が分かります

105
00:06:59,453 --> 00:07:05,259
コンテキストでタイプと
空き容量が分かります

106
00:07:06,326 --> 00:07:08,729
今回はDCT
タイプ２を使います

107
00:07:10,497 --> 00:07:13,834
コンテキストを実行すると

108
00:07:16,870 --> 00:07:18,739
解析が行われます

109
00:07:21,408 --> 00:07:24,711
解析後はノイズを除去します

110
00:07:24,845 --> 00:07:26,680
ここがポイントです

111
00:07:27,748 --> 00:07:31,618
しきい値よりも
低い周波数成分を探し

112
00:07:32,219 --> 00:07:34,822
ゼロにしてしまいます

113
00:07:36,690 --> 00:07:39,193
最後は
オーディオ信号の再構築

114
00:07:43,330 --> 00:07:46,300
再びCreateSetupを使います

115
00:07:48,969 --> 00:07:53,407
今度はDCTタイプ３で
再構築を行います

116
00:07:57,044 --> 00:08:00,214
コンテキストを実行すると

117
00:07:57,044 --> 00:08:00,214
コンテキストを実行すると

118
00:08:00,314 --> 00:08:03,550
オーディオ信号が
再構築されます

119
00:08:05,619 --> 00:08:06,920
一例として

120
00:08:08,055 --> 00:08:12,626
オーディオ信号から
ノイズを取り除きました

121
00:08:13,160 --> 00:08:18,232
次に画像からノイズを
除去する方法をお見せします

122
00:08:20,868 --> 00:08:24,805
古い新聞の写真の
復元を試みます

123
00:08:32,044 --> 00:08:33,847
画像を取り込み

124
00:08:35,349 --> 00:08:38,150
白黒のスクリーンを
適用します

125
00:08:39,785 --> 00:08:41,822
古い新聞の写真と同じです

126
00:08:41,922 --> 00:08:45,025
これからスクリーンを
取り除きます

127
00:08:45,125 --> 00:08:47,761
アーティファクトの除去です

128
00:08:48,295 --> 00:08:50,797
今は何もしていません

129
00:08:51,732 --> 00:08:54,334
まずはサンプルを取り出し

130
00:08:54,468 --> 00:08:59,173
マスクを作成して
画像に適用させます

131
00:08:59,606 --> 00:09:01,341
やってみましょう

132
00:08:59,606 --> 00:09:01,341
やってみましょう

133
00:09:04,778 --> 00:09:10,050
今は周波数成分を
認識しているところです

134
00:09:10,384 --> 00:09:14,054
しきい値よりも高い
周波数成分を

135
00:09:15,088 --> 00:09:16,023
除去します

136
00:09:17,024 --> 00:09:18,792
しきい値が低いと

137
00:09:19,893 --> 00:09:24,198
アーティファクトに加え
画像も消えてしまいます

138
00:09:27,968 --> 00:09:29,469
次は高くします

139
00:09:32,239 --> 00:09:34,174
変化がありません

140
00:09:38,912 --> 00:09:40,280
中間にすると

141
00:09:40,981 --> 00:09:44,651
アーティファクトだけが
除去されます

142
00:09:44,952 --> 00:09:48,055
画像には
ダメージを与えません

143
00:09:48,689 --> 00:09:50,057
まとめます

144
00:09:55,262 --> 00:10:00,300
画像とサンプルに
高速フーリエ変換を施します

145
00:09:55,262 --> 00:10:00,300
画像とサンプルに
高速フーリエ変換を施します

146
00:10:01,168 --> 00:10:05,505
サンプルからマスクを作成し
画像に適用させ

147
00:10:07,341 --> 00:10:10,477
オリジナル画像を
再構築します

148
00:10:10,677 --> 00:10:12,446
次にコードです

149
00:10:14,948 --> 00:10:16,250
FFTを使います

150
00:10:18,418 --> 00:10:21,855
パワー２なので
ログ２を呼び出します

151
00:10:22,856 --> 00:10:25,626
画像のサイズは
1024×1024です

152
00:10:28,662 --> 00:10:32,399
これをfft2d zropに
落とします

153
00:10:32,900 --> 00:10:35,602
opは“置き違い”です

154
00:10:35,702 --> 00:10:39,072
このため仮の
スペースを作ります

155
00:10:41,542 --> 00:10:47,781
複雑な数列構造を２つの
列に分けて保管するのです

156
00:10:48,182 --> 00:10:51,618
実際の成分と架空の成分です

157
00:10:52,753 --> 00:10:54,621
方向も指示します

158
00:10:54,788 --> 00:10:56,723
今回はforwardです

159
00:11:01,695 --> 00:11:06,033
アーティファクト除去は
さらに複雑なので

160
00:11:06,133 --> 00:11:08,702
上級者向けにお話しします

161
00:11:09,069 --> 00:11:12,539
サンプルはオンラインで
取得できます

162
00:11:12,773 --> 00:11:18,545
vDSPの項目に工程を解説した
ドキュメントもあります

163
00:11:20,480 --> 00:11:26,520
まずサンプルの周波数成分の
大きさを割り出してから

164
00:11:27,921 --> 00:11:30,357
除去する成分も確認します

165
00:11:33,026 --> 00:11:35,562
そこからマスクを作成し

166
00:11:36,964 --> 00:11:39,833
元の画像に適用させます

167
00:11:41,101 --> 00:11:43,704
除去したい成分に０を掛け

168
00:11:43,837 --> 00:11:47,407
残したい成分に１を掛けます

169
00:11:52,312 --> 00:11:54,882
zropで画像を再構築します

170
00:11:54,982 --> 00:11:57,718
FFTはコンテキストを
再利用できます

171
00:12:01,321 --> 00:12:06,260
重要なのは２つの配列に
画像を保存すること

172
00:12:06,360 --> 00:12:07,928
それほど複雑です

173
00:12:08,028 --> 00:12:12,466
偶数画素は実際の列
奇数画素は架空の列です

174
00:12:15,068 --> 00:12:18,872
今回は逆高速
フーリエ変換を行います

175
00:12:19,873 --> 00:12:21,675
少し話を移します

176
00:12:21,975 --> 00:12:24,411
２つの例を見せましたね

177
00:12:26,046 --> 00:12:28,882
先にvDSPの活用例を見せ

178
00:12:29,283 --> 00:12:34,454
それらの作成方法を
あとから説明しました

179
00:12:34,555 --> 00:12:37,057
結果と説明が逆でしたね

180
00:12:37,858 --> 00:12:41,094
次は基本的な
成分から始めます

181
00:12:41,195 --> 00:12:43,030
結果は最後です

182
00:12:43,130 --> 00:12:44,898
今度はSIMDです

183
00:12:45,566 --> 00:12:49,970
低水準の基本的な
プリミティブを回転させます

184
00:12:50,070 --> 00:12:52,172
3D物体の回転です

185
00:12:54,575 --> 00:12:55,709
SIMDの特性は

186
00:12:57,110 --> 00:12:59,813
ベクトル処理ユニットの
抽象化です

187
00:13:00,514 --> 00:13:04,918
ベクトルおよびマトリクス
対象を宣言させ

188
00:13:05,385 --> 00:13:10,824
対象を編集可能にし
ハードウェアへ導きます

189
00:13:11,992 --> 00:13:13,627
コードを見せます

190
00:13:16,063 --> 00:13:20,200
２つの配列を使い
成分の平均を割り出し

191
00:13:20,534 --> 00:13:25,506
成分を繰り返し足しては
２で割っていくのです

192
00:13:27,574 --> 00:13:28,976
大変な作業です

193
00:13:31,078 --> 00:13:35,048
配列をSIMD float4
ベクトルタイプに

194
00:13:36,550 --> 00:13:41,788
宣言することで対象物の
計算が可能になります

195
00:13:43,023 --> 00:13:48,695
算出が滑らかになり
高速計算が可能となります

196
00:13:49,830 --> 00:13:52,132
全プラットフォームで
可能です

197
00:13:55,969 --> 00:13:58,172
他にも機能があります

198
00:13:58,839 --> 00:14:01,542
ベクトルおよび
マトリクス対象物の

199
00:13:58,839 --> 00:14:01,542
ベクトルおよび
マトリクス対象物の

200
00:14:02,709 --> 00:14:06,947
高度な計算を可能に
するだけではありません

201
00:14:08,749 --> 00:14:12,419
例えばドット積と
clamp関数です

202
00:14:14,188 --> 00:14:17,825
サイン コサインなどの
超越関数や

203
00:14:19,726 --> 00:14:21,161
四元数もです

204
00:14:21,562 --> 00:14:25,232
四元数は３次元での
回転に利用できます

205
00:14:25,332 --> 00:14:27,801
詳しく解説しましょう

206
00:14:29,870 --> 00:14:32,206
コードの例を見ていきます

207
00:14:33,674 --> 00:14:35,142
少し複雑です

208
00:14:35,843 --> 00:14:37,211
まずは右から

209
00:14:37,511 --> 00:14:40,013
グレーの
単位球面があります

210
00:14:40,280 --> 00:14:41,915
赤い点が見えますね

211
00:14:43,150 --> 00:14:44,985
ベクトルの先端です

212
00:14:46,019 --> 00:14:47,988
SIMD float3を宣言し

213
00:14:48,088 --> 00:14:51,892
ｘとｙを０に
ｚを１に設定します

214
00:14:52,059 --> 00:14:53,494
こちらに出てきますね

215
00:14:54,428 --> 00:14:57,297
赤い点はベクトルの先端です

216
00:14:58,932 --> 00:15:02,236
四元数を使って
ベクトルを回転させます

217
00:14:58,932 --> 00:15:02,236
四元数を使って
ベクトルを回転させます

218
00:15:03,670 --> 00:15:08,575
実際は全体を回しますが
ここではベクトルとします

219
00:15:10,010 --> 00:15:14,715
四元数を使うため
軸と角度を設定します

220
00:15:15,649 --> 00:15:19,286
何をどれだけ
回転させるかということです

221
00:15:20,154 --> 00:15:24,792
ｘを軸に３ラジアン分のπ
上昇させましょう

222
00:15:27,594 --> 00:15:30,364
act functionを呼び出し

223
00:15:31,899 --> 00:15:36,003
四元数を実行すると
ベクトルが回転します

224
00:15:37,137 --> 00:15:38,605
やってみます

225
00:15:47,147 --> 00:15:52,986
皆さんは複数の軸を使っての
回転に興味があるでしょう

226
00:15:54,521 --> 00:15:57,925
通常の回転
マトリクスと同様に

227
00:16:00,127 --> 00:16:03,063
掛け算を用いて
回転させます

228
00:16:03,163 --> 00:16:06,700
また掛け算は
可換ではありません

229
00:16:06,833 --> 00:16:11,038
演算対象を変更する際
位数も変えます

230
00:16:13,373 --> 00:16:16,643
３ラジアン分のπ
上方に動かし

231
00:16:17,144 --> 00:16:18,946
同様に右へ動かします

232
00:16:19,046 --> 00:16:21,281
これを１つの動きにします

233
00:16:26,854 --> 00:16:30,791
四元数でできることに
補間があります

234
00:16:30,891 --> 00:16:33,527
２つのタイプの補間です

235
00:16:34,828 --> 00:16:36,129
まずはSlerp

236
00:16:37,865 --> 00:16:40,100
球面線形補間のことで

237
00:16:42,035 --> 00:16:43,770
異体が２つあります

238
00:16:47,174 --> 00:16:52,646
simd slerpは最短の弧で
青と緑を結んだもの

239
00:16:53,747 --> 00:16:58,452
simd slerp longestは
最長で背面に回っています

240
00:17:07,127 --> 00:17:08,896
次はSplineで

241
00:17:09,762 --> 00:17:13,000
複数の回転を行うのに
便利です

242
00:17:13,099 --> 00:17:17,371
では複数の回転の
配列を補間します

243
00:17:17,971 --> 00:17:21,842
Splineのコードだけに
注目してください

244
00:17:24,645 --> 00:17:29,650
個々の回転を反復して
Splineに適用させます

245
00:17:34,421 --> 00:17:40,094
従って補間したい２つの
回転だけではなく

246
00:17:40,194 --> 00:17:42,496
前後の回転を含めます

247
00:17:44,498 --> 00:17:45,933
こうなります

248
00:17:51,939 --> 00:17:57,678
ゲーム開発者であれば
対象物を回転させたいはず

249
00:17:57,911 --> 00:17:59,146
それも可能です

250
00:17:59,279 --> 00:18:02,983
複数のベクトルで
表された立方体が

251
00:17:59,279 --> 00:18:02,983
複数のベクトルで
表された立方体が

252
00:18:03,083 --> 00:18:05,252
８種の回転を行います

253
00:18:05,485 --> 00:18:10,257
左はSlerpを右はSplineを
使ったものです

254
00:18:10,357 --> 00:18:12,159
まずはSlerpから

255
00:18:19,800 --> 00:18:25,005
線形補間のため
動きが角ばっています

256
00:18:25,239 --> 00:18:26,874
次はSplineです

257
00:18:35,082 --> 00:18:39,520
前後の回転も認識し
なめらかな動きです

258
00:18:39,620 --> 00:18:40,821
ではもう一度

259
00:18:52,666 --> 00:18:54,701
少し駆け足でしたが

260
00:18:55,502 --> 00:18:56,737
振り返ります

261
00:18:58,272 --> 00:19:01,575
最初にvDSPの
２つの例を見ました

262
00:18:58,272 --> 00:19:01,575
最初にvDSPの
２つの例を見ました

263
00:19:01,675 --> 00:19:03,944
ノイズから信号を取り出し

264
00:19:04,545 --> 00:19:07,881
画像からアーティファクトを
除去しました

265
00:19:08,916 --> 00:19:14,288
次にSIMDで四元数を用い
３次元での回転を見せました

266
00:19:15,289 --> 00:19:18,025
次はルーク･チャンが
担当します

267
00:19:18,158 --> 00:19:20,727
Vimageの活用法についてです

268
00:19:21,462 --> 00:19:26,600
(拍手)

269
00:19:26,700 --> 00:19:27,701
ありがとう

270
00:19:30,170 --> 00:19:32,372
私はルーク･チャン

271
00:19:32,473 --> 00:19:34,775
Vector and Numericsの
エンジニアです

272
00:19:35,142 --> 00:19:38,946
今回は
Vimageについてお話しします

273
00:19:39,046 --> 00:19:41,882
機能と利便性についてです

274
00:19:42,349 --> 00:19:47,221
わずかなコード行で
動画にエフェクトを入れます

275
00:19:47,421 --> 00:19:48,522
始めましょう

276
00:19:50,791 --> 00:19:53,694
Vimageは
画像処理ライブラリです

277
00:19:54,528 --> 00:19:59,566
いくつかある機能の内の
１つは転換機能です

278
00:20:00,100 --> 00:20:05,672
フォーマットの異なる画像を
転換することができます

279
00:20:06,373 --> 00:20:10,043
フォーマットには
それぞれ利点があります

280
00:20:10,144 --> 00:20:14,815
RGBはディスプレイの
画素と相性がよく

281
00:20:14,915 --> 00:20:16,550
背景画面に最適です

282
00:20:17,084 --> 00:20:20,087
一方でYCbCrもあります

283
00:20:20,654 --> 00:20:23,724
人の視覚に近いのが特徴です

284
00:20:23,957 --> 00:20:27,995
明るさを認識する
輝度チャネル

285
00:20:28,495 --> 00:20:31,231
色を認識する
クロミナンスチャネル

286
00:20:32,065 --> 00:20:36,403
カメラは
YCbCrを使っていますね

287
00:20:37,438 --> 00:20:41,942
転換機能でフォーマット間を
移動可能にします

288
00:20:43,677 --> 00:20:45,913
次に形状機能です

289
00:20:46,880 --> 00:20:51,718
画像のサイズや
位置の変更が可能になります

290
00:20:52,152 --> 00:20:57,024
vImageScaleを使って
画像の拡大縮小ができます

291
00:20:57,391 --> 00:21:02,996
ランチョス法アルゴリズムで
高品質な仕上がりです

292
00:20:57,391 --> 00:21:02,996
ランチョス法アルゴリズムで
高品質な仕上がりです

293
00:21:03,797 --> 00:21:09,136
vImageRotateでは
画像の回転が可能です

294
00:21:11,171 --> 00:21:13,407
次に畳み込み機能です

295
00:21:13,974 --> 00:21:18,312
この機能の一番の特徴は
ぼかし効果です

296
00:21:18,745 --> 00:21:23,417
UIや写真では
よく見られるエフェクトです

297
00:21:23,650 --> 00:21:29,256
何かを背景へぼかしたい際に
このエフェクトを使います

298
00:21:31,024 --> 00:21:33,160
そして変換機能です

299
00:21:33,727 --> 00:21:37,130
基本的には
行列の乗法のことで

300
00:21:37,397 --> 00:21:40,901
各画素のデータチャネルに
対応します

301
00:21:41,168 --> 00:21:44,271
例えば赤や緑を
強くしたい場合

302
00:21:44,371 --> 00:21:46,874
変換機能が役立ちます

303
00:21:48,709 --> 00:21:49,776
形態機能

304
00:21:50,377 --> 00:21:55,682
この機能で対象物の
サイズや形を変更できます

305
00:21:55,782 --> 00:21:57,151
対象物のみです

306
00:21:57,818 --> 00:21:59,620
vImageErodeと

307
00:22:00,154 --> 00:22:04,324
vImageDilateで
拡大縮小ができます

308
00:22:04,825 --> 00:22:06,827
冒険をしたければ

309
00:22:06,927 --> 00:22:11,231
カーネルの形を
各機能に反映させます

310
00:22:11,398 --> 00:22:16,437
するとErodeとDilateは
対象物の拡大縮小を

311
00:22:16,537 --> 00:22:18,705
カーネルを元に行います

312
00:22:20,307 --> 00:22:22,576
これらが５つの機能です

313
00:22:22,676 --> 00:22:26,980
これからVimageの
デモアプリケーションで

314
00:22:27,080 --> 00:22:30,150
エフェクトを紹介します

315
00:22:33,754 --> 00:22:38,158
これは端末の
背面カメラで映した映像で

316
00:22:38,826 --> 00:22:41,762
スクリーンに投影させました

317
00:22:42,362 --> 00:22:46,133
リアルタイムの
ライブ映像なので

318
00:22:46,233 --> 00:22:49,970
バラの横で水飲み鳥が
動いていますね

319
00:22:50,571 --> 00:22:54,675
まずはサチュレーション
エフェクトです

320
00:22:54,775 --> 00:22:59,613
これは他社の画像編集
ソフトでもよく見られます

321
00:23:00,047 --> 00:23:02,483
色を鮮やかにしましょう

322
00:23:02,583 --> 00:23:06,687
このスライダを
右へ動かします

323
00:23:08,956 --> 00:23:12,159
赤はより赤く 緑はより緑に

324
00:23:13,560 --> 00:23:16,964
また左側に
白いバラがあります

325
00:23:17,264 --> 00:23:21,435
この色は
あまり面白味がありません

326
00:23:21,535 --> 00:23:24,605
この映像で
注目してほしいのは

327
00:23:24,738 --> 00:23:28,375
構図と色のコントラストです

328
00:23:28,942 --> 00:23:31,778
左へスライドさせて

329
00:23:32,179 --> 00:23:34,147
彩度を下げます

330
00:23:36,049 --> 00:23:39,720
映像が白黒になるまで
スライドさせると

331
00:23:40,087 --> 00:23:43,023
色は もう気になりません

332
00:23:43,123 --> 00:23:47,127
構図とコントラストのみ
注目されます

333
00:23:48,161 --> 00:23:51,498
では やり方を解説します

334
00:23:55,969 --> 00:23:57,771
いくつかステップがあり

335
00:23:57,871 --> 00:24:01,842
まずはカメラで
画像を撮影します

336
00:23:57,871 --> 00:24:01,842
まずはカメラで
画像を撮影します

337
00:24:03,677 --> 00:24:08,448
次にVimageを使うための
準備として

338
00:24:08,549 --> 00:24:12,352
出入力バッファを用意します

339
00:24:13,687 --> 00:24:17,558
Vimageの機能で
エフェクトをかけ

340
00:24:18,859 --> 00:24:21,495
スクリーンに出力します

341
00:24:22,596 --> 00:24:28,268
先にVimageを使った
エフェクトの話をしましょう

342
00:24:30,704 --> 00:24:33,106
サチュレーション
エフェクトは

343
00:24:33,207 --> 00:24:36,910
こちらの方程式を使います

344
00:24:37,344 --> 00:24:40,347
基本的には
画素からバイアスを外し

345
00:24:40,781 --> 00:24:44,985
掛け算を使って
エフェクトをかけます

346
00:24:45,519 --> 00:24:48,655
そしてバイアスを戻します

347
00:24:49,656 --> 00:24:53,293
Vimageは
この作業を行うのです

348
00:24:53,627 --> 00:24:56,296
vImageMatrixMultiplyと
いいます

349
00:24:58,332 --> 00:25:01,168
まずは
プリバイアスを取り出し

350
00:24:58,332 --> 00:25:01,168
まずは
プリバイアスを取り出し

351
00:25:01,268 --> 00:25:05,072
例では-128ですが
これでバイアスを除きます

352
00:25:06,140 --> 00:25:11,278
彩度は点が浮いていますが
画像は整数値です

353
00:25:11,712 --> 00:25:16,150
彩度の値を定点に
変換する必要があります

354
00:25:16,283 --> 00:25:21,622
Q12を定点とすると
除数は0×100となります

355
00:25:22,756 --> 00:25:28,095
ポストバイアス×除数で
バイアスを画素に戻します

356
00:25:30,397 --> 00:25:32,933
マトリクスはシンプルです

357
00:25:33,033 --> 00:25:37,337
CbCrチャネルを
スケーリングします

358
00:25:37,438 --> 00:25:44,311
マトリクスはスケーラーで
CbCrチャネルを掛けます

359
00:25:45,512 --> 00:25:49,449
vImageMatrixMultiplyを
呼び出すと

360
00:25:49,883 --> 00:25:55,656
１つの配列と１つの機能で
エフェクトがかけられます

361
00:25:57,157 --> 00:26:00,094
ではステップに戻ります

362
00:25:57,157 --> 00:26:00,094
ではステップに戻ります

363
00:26:01,128 --> 00:26:05,065
カメラから
画像を取り出すには

364
00:26:06,467 --> 00:26:08,235
デリゲートを使います

365
00:26:08,902 --> 00:26:12,573
カメラから
CV画像バッファを取得し

366
00:26:13,340 --> 00:26:15,109
バッファを手に入れます

367
00:26:15,843 --> 00:26:19,813
CPUでアクセスが
可能か確認します

368
00:26:19,913 --> 00:26:21,548
そこにVimageがあります

369
00:26:22,149 --> 00:26:26,286
どんなエフェクトを
かけたあとも

370
00:26:26,386 --> 00:26:30,324
バッファのベースアドレスを
アンロックします

371
00:26:30,757 --> 00:26:33,727
これでメモリを
再利用できます

372
00:26:36,763 --> 00:26:41,068
次のステップでは
出入力バッファを準備します

373
00:26:43,504 --> 00:26:46,573
CV画像バッファがあるので

374
00:26:46,673 --> 00:26:49,409
情報を取得するだけです

375
00:26:49,510 --> 00:26:52,079
高さや長さなどですね

376
00:26:53,280 --> 00:26:57,084
これをVimage
バッファ対象とし

377
00:26:57,217 --> 00:26:59,720
ライブラリで使用します

378
00:26:59,820 --> 00:27:02,389
輝度とクロミナンス
チャネルのためです

379
00:26:59,820 --> 00:27:02,389
輝度とクロミナンス
チャネルのためです

380
00:27:03,490 --> 00:27:05,893
そして出力バッファを
用意します

381
00:27:06,493 --> 00:27:11,098
メモリは まだ出力画像に
配置されていません

382
00:27:11,198 --> 00:27:14,902
Vimageには
便利な機能があります

383
00:27:15,002 --> 00:27:17,604
正確にはVimageバッファです

384
00:27:18,672 --> 00:27:23,377
高さと長さ
１画素のビット数を与えると

385
00:27:23,911 --> 00:27:27,881
画像の保存に十分な
メモリを配置します

386
00:27:27,981 --> 00:27:30,517
さらにバッファ
対象物を作成し

387
00:27:30,617 --> 00:27:33,620
ライブラリ内での
使用が可能になります

388
00:27:35,689 --> 00:27:40,394
最後のステップで
画像をスクリーンに移します

389
00:27:43,430 --> 00:27:44,865
すでにお話ししましたが

390
00:27:45,699 --> 00:27:48,001
RGBは
ディスプレイに最適です

391
00:27:48,101 --> 00:27:50,170
では転換機能を使って

392
00:27:50,270 --> 00:27:54,241
YCbCr画像を
RGB画像に変えます

393
00:27:54,341 --> 00:27:58,579
UIはCGImage対象物に
対応するので

394
00:27:58,679 --> 00:28:00,180
新しく作ります

395
00:27:58,679 --> 00:28:00,180
新しく作ります

396
00:28:01,482 --> 00:28:03,150
Vimageの機能で

397
00:28:03,250 --> 00:28:06,920
CGImageCreateがあります

398
00:28:08,021 --> 00:28:12,893
Vimageバッファから
CGImageを作成します

399
00:28:13,794 --> 00:28:15,229
特筆すべき点は

400
00:28:15,329 --> 00:28:21,068
大きなデータバッファを
コピーしていないということ

401
00:28:21,201 --> 00:28:24,271
CGImageを単に作成し

402
00:28:24,371 --> 00:28:27,574
画像バッファの
容量を足しています

403
00:28:28,108 --> 00:28:33,514
必要な情報を提供し
CGImageを作成しているので

404
00:28:33,614 --> 00:28:35,716
コピーは不要です

405
00:28:37,117 --> 00:28:41,989
作成したCGImageを
イメージビューに送ると

406
00:28:42,422 --> 00:28:44,758
スクリーンに投影されます

407
00:28:44,892 --> 00:28:46,126
簡単です

408
00:28:46,293 --> 00:28:50,063
４つのステップで
エフェクトを加えます

409
00:28:50,164 --> 00:28:51,865
例は彩度でしたが

410
00:28:51,965 --> 00:28:56,503
Vimageの他の
エフェクトも紹介しましょう

411
00:28:57,538 --> 00:29:03,210
時計回りと反時計回りに
画像を回転させることと

412
00:28:57,538 --> 00:29:03,210
時計回りと反時計回りに
画像を回転させることと

413
00:29:03,544 --> 00:29:07,314
背景への
ぼかし効果も可能です

414
00:29:08,115 --> 00:29:13,220
画像にレトロな
質感を出したいと感じたら

415
00:29:13,320 --> 00:29:16,223
ディザリングで
白黒にできます

416
00:29:16,657 --> 00:29:19,560
カラー画像は
量子化も可能です

417
00:29:20,227 --> 00:29:23,397
アプリケーションでの
操作をお見せします

418
00:29:36,510 --> 00:29:40,447
回転を操作する
スライダがあります

419
00:29:40,848 --> 00:29:44,618
映像を反時計回りに
回転させたり

420
00:29:46,220 --> 00:29:48,889
時計回りの回転も可能です

421
00:29:51,525 --> 00:29:53,427
次に ぼかし効果です

422
00:29:53,527 --> 00:29:55,329
ここをクリックして

423
00:29:55,963 --> 00:29:59,433
段々とぼかしていきます

424
00:30:00,534 --> 00:30:03,237
左にスライドさせれば

425
00:30:03,704 --> 00:30:06,140
再びバラを前面に戻せます

426
00:30:08,041 --> 00:30:10,310
ディザリングで白黒にします

427
00:30:12,246 --> 00:30:14,848
この白黒映像のグレー部分は

428
00:30:14,948 --> 00:30:18,719
点の密集によって
表示されています

429
00:30:18,819 --> 00:30:20,187
ディザリングです

430
00:30:20,287 --> 00:30:24,191
アクセントとディザリング
アルゴリズムは

431
00:30:24,291 --> 00:30:26,093
のちほど解説します

432
00:30:27,127 --> 00:30:30,464
カラー量子化は
参照テーブルがあります

433
00:30:31,131 --> 00:30:34,334
スライダで
量子化レベルを上げます

434
00:30:34,434 --> 00:30:36,670
右に動かしていくと

435
00:30:36,970 --> 00:30:40,974
映像の色が
どんどん減っていきます

436
00:30:41,308 --> 00:30:43,076
独創的な映像です

437
00:30:44,478 --> 00:30:48,682
80～90年代の
パソコンの画面のようです

438
00:30:50,417 --> 00:30:52,219
それでは今から

439
00:30:53,086 --> 00:30:54,955
やり方を説明します

440
00:30:58,458 --> 00:31:01,862
回転はvImageRotateを
呼び出し

441
00:30:58,458 --> 00:31:01,862
回転はvImageRotateを
呼び出し

442
00:31:01,962 --> 00:31:04,364
角度を設定します

443
00:31:04,464 --> 00:31:08,268
時計回りも
反時計回りも可能です

444
00:31:09,903 --> 00:31:12,906
ぼかしは
TentConvolveです

445
00:31:13,574 --> 00:31:16,310
カーネルのサイズが重要で

446
00:31:16,610 --> 00:31:19,446
大きいほど
ぼかしが強くなります

447
00:31:21,648 --> 00:31:26,153
ディザリングは画像を
８ビットから１ビットに変え

448
00:31:26,253 --> 00:31:29,456
アルゴリズムも選びます

449
00:31:29,623 --> 00:31:32,793
ここではアトキンソン
ディザリングを使います

450
00:31:35,462 --> 00:31:36,864
カラー量子化は

451
00:31:36,964 --> 00:31:42,236
RGBチャネルのために
参照テーブルを作成します

452
00:31:42,870 --> 00:31:45,472
vImageTableLookUpを
呼び出し

453
00:31:45,739 --> 00:31:51,178
参照テーブルを適用し
色の数を限定していきます

454
00:31:54,047 --> 00:31:56,917
４つのエフェクトを
紹介しましたが

455
00:31:57,017 --> 00:32:01,455
ここからは次のトピックに
話を移します

456
00:31:57,017 --> 00:32:01,455
ここからは次のトピックに
話を移します

457
00:32:04,491 --> 00:32:05,759
LINPACKベンチマーク

458
00:32:06,860 --> 00:32:09,797
Accelerateの機能は

459
00:32:09,897 --> 00:32:13,967
アプリケーションでの
利用も手軽だと話しました

460
00:32:14,401 --> 00:32:18,071
しかし速度に関しては
話していません

461
00:32:18,572 --> 00:32:21,341
そこでLINPACK
ベンチマークです

462
00:32:23,410 --> 00:32:25,112
一体何をするのか

463
00:32:25,712 --> 00:32:30,818
連立一次方程式を解く
速度を計るツールです

464
00:32:31,718 --> 00:32:34,721
実際には３種類あります

465
00:32:34,822 --> 00:32:38,225
行列を100に固定して
計測するもの

466
00:32:38,859 --> 00:32:41,662
行列を1000に固定するもの

467
00:32:42,229 --> 00:32:47,601
最後が これからお見せする
タイプのもので

468
00:32:47,868 --> 00:32:49,002
無制限です

469
00:32:49,103 --> 00:32:51,505
どんな行列でも可能です

470
00:32:51,605 --> 00:32:56,243
機械の計算能力を
最大限に使っています

471
00:32:57,644 --> 00:33:02,049
iPhone XでAccelerateを
使ってみましょう

472
00:32:57,644 --> 00:33:02,049
iPhone XでAccelerateを
使ってみましょう

473
00:33:03,116 --> 00:33:05,419
速度はギガフロップスです

474
00:33:07,120 --> 00:33:10,858
倍精度は
iPhone 5Sから上がり

475
00:33:11,291 --> 00:33:12,659
iPhone 6

476
00:33:13,927 --> 00:33:17,698
iPhone 6S　iPhone 7

477
00:33:18,065 --> 00:33:22,102
そしてiPhone Xは
28.7ギガフロップスです

478
00:33:22,269 --> 00:33:23,704
これが倍精度で

479
00:33:23,804 --> 00:33:25,706
単精度も見ましょう

480
00:33:27,007 --> 00:33:27,941
そうですね

481
00:33:31,044 --> 00:33:35,082
はみ出したので
チャートを縮めます

482
00:33:38,318 --> 00:33:41,889
iPhone Xは
68ギガフロップスです

483
00:33:42,689 --> 00:33:46,727
別に驚くことでは
ないかもしれません

484
00:33:47,194 --> 00:33:51,899
精度もパフォーマンスも
改良されていますが

485
00:33:52,599 --> 00:33:55,536
それだけではありません

486
00:33:56,603 --> 00:34:01,475
マイクロアーキテクチャで
計算能力が上がり

487
00:33:56,603 --> 00:34:01,475
マイクロアーキテクチャで
計算能力が上がり

488
00:34:01,775 --> 00:34:06,346
高度な計算能力を
使うソフトが必要となります

489
00:34:06,680 --> 00:34:08,282
そこに注目しました

490
00:34:08,982 --> 00:34:13,053
同じLINPACKベンチマークが

491
00:34:13,187 --> 00:34:16,290
５つのiPhoneで実行できます

492
00:34:16,422 --> 00:34:19,359
Accelerateで得られる

493
00:34:20,260 --> 00:34:21,695
最適な動作環境

494
00:34:23,330 --> 00:34:25,399
アプリケーションも同様です

495
00:34:25,833 --> 00:34:31,304
Accelerateを使えば
最適な動作が保障されます

496
00:34:31,405 --> 00:34:34,475
すべての
アーキテクチャで可能です

497
00:34:35,641 --> 00:34:40,748
異なるプラットフォームも
Accelerateが利用できます

498
00:34:41,014 --> 00:34:45,886
macOS iOS tvOS
watchOSで可能です

499
00:34:47,187 --> 00:34:52,292
新しいアーキテクチャや
プラットフォームが出ても

500
00:34:52,391 --> 00:34:54,027
心配は要りません

501
00:34:54,561 --> 00:34:57,865
その際に必要な作業は１つ

502
00:34:57,965 --> 00:35:01,635
Accelerateに
リンクさせるだけです

503
00:34:57,965 --> 00:35:01,635
Accelerateに
リンクさせるだけです

504
00:35:01,735 --> 00:35:04,705
これで最新の
アーキテクチャや

505
00:35:04,805 --> 00:35:07,908
プラットフォームも
快適に使用できます

506
00:35:10,711 --> 00:35:12,512
最後にまとめます

507
00:35:12,846 --> 00:35:18,318
Accelerateには
様々な機能があります

508
00:35:18,819 --> 00:35:22,055
想定以上のことが
可能なのです

509
00:35:22,489 --> 00:35:27,461
機能が不十分であれば
リクエストを送ってください

510
00:35:27,895 --> 00:35:32,599
送られたものは検証し
開発に役立てます

511
00:35:32,766 --> 00:35:37,571
リクエストから生まれた
機能はたくさんあります

512
00:35:38,939 --> 00:35:40,808
Accelerateは手軽です

513
00:35:40,908 --> 00:35:44,445
大抵は機能を
呼び出すだけです

514
00:35:45,446 --> 00:35:47,948
高速かつ省エネであり

515
00:35:48,115 --> 00:35:52,853
アプリケーションは速く
バッテリーも長く持ちます

516
00:35:53,854 --> 00:35:57,491
Accelerateは移行が可能です

517
00:35:57,591 --> 00:36:00,594
全プラットフォームと
全アーキテクチャにおいて

518
00:35:57,591 --> 00:36:00,594
全プラットフォームと
全アーキテクチャにおいて

519
00:36:00,694 --> 00:36:03,564
最適なパフォーマンスを
保障します

520
00:36:03,964 --> 00:36:06,767
コードの変更は
必要はありません

521
00:36:09,069 --> 00:36:14,141
developer.apple.comにて
詳細が確認できます

522
00:36:14,241 --> 00:36:19,913
デモアプリケーションや
コードなども取得可能です

523
00:36:20,547 --> 00:36:23,750
明日は
ラボセッションがあります

524
00:36:24,184 --> 00:36:25,886
とても楽しみです

525
00:36:25,986 --> 00:36:29,923
Accelerateに関する
質問があれば

526
00:36:30,090 --> 00:36:31,625
明日 聞きましょう

527
00:36:33,427 --> 00:36:36,229
では本日は ここまでです

528
00:36:36,330 --> 00:36:37,397
よい１日を

529
00:36:37,498 --> 00:36:40,567
(拍手)