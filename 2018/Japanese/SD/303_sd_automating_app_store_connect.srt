
1
00:00:07,174 --> 00:00:15,883
(音楽)

2
00:00:26,093 --> 00:00:33,300
(拍手)

3
00:00:34,735 --> 00:00:38,705
App Store Connectの
ジェフ･コフィです

4
00:00:39,006 --> 00:00:41,942
今日のテーマは
App Store Connectの自動化

5
00:00:42,276 --> 00:00:45,746
正直 この話題は
テンションが上がります

6
00:00:46,947 --> 00:00:51,118
まずApp Store Connectの
自動化の現状から

7
00:00:51,752 --> 00:00:56,156
クラッシュレポートの
ダウンロードなどには

8
00:00:56,523 --> 00:00:58,292
Xcodeを使いますね

9
00:00:58,759 --> 00:01:03,497
またTransporterで
metadata.xmlやビルドの

10
00:00:58,759 --> 00:01:03,497
またTransporterで
metadata.xmlやビルドの

11
00:01:03,697 --> 00:01:05,699
アップロードが
自動化できます

12
00:01:06,133 --> 00:01:11,071
財務報告書などの
ダウンロードはReporter

13
00:01:11,605 --> 00:01:16,276
便利なツールですが
さらなる要望の声があります

14
00:01:16,376 --> 00:01:19,646
App Store Connectの
アクセス拡大と

15
00:01:19,746 --> 00:01:22,416
多様なワークフローとの
統合です

16
00:01:22,883 --> 00:01:26,854
新App Store Connect APIを
ご紹介します

17
00:01:28,021 --> 00:01:33,460
(拍手)

18
00:01:34,094 --> 00:01:35,762
我々もうれしい

19
00:01:36,330 --> 00:01:39,700
App Store Connectの
標準REST APIで

20
00:01:40,300 --> 00:01:46,039
最大の売りはレスポンスが
JSON形式であること

21
00:01:46,139 --> 00:01:49,142
皆さんには
扱いやすいと思います

22
00:01:49,476 --> 00:01:54,114
どんなプログラミング言語や
プラットフォームも

23
00:01:54,214 --> 00:01:57,317
既存のツールも使えます

24
00:01:58,352 --> 00:02:00,254
セキュリティも重要です

25
00:01:58,352 --> 00:02:00,254
セキュリティも重要です

26
00:02:00,354 --> 00:02:05,025
認証には業界標準のJWT
JSON Web Tokenを採用し

27
00:02:05,125 --> 00:02:08,228
ユーザネームや
パスワードは不要です

28
00:02:08,562 --> 00:02:12,766
人物やチームに対応する
コードを使わずに

29
00:02:12,900 --> 00:02:16,870
アクセス権限を
コントロールできます

30
00:02:18,639 --> 00:02:23,043
使いやすさの観点から
一貫性を重視しています

31
00:02:23,243 --> 00:02:26,113
RESTリソースモデルが
一元化されており

32
00:02:26,346 --> 00:02:32,085
あるパートで学んだことが
他のすべてに適用できます

33
00:02:32,319 --> 00:02:35,856
見つけやすさも追求しました

34
00:02:35,956 --> 00:02:40,460
JSONデータはフォーマットも
インデントも完璧です

35
00:02:40,561 --> 00:02:44,531
そのまま画面で
読むことができます

36
00:02:44,831 --> 00:02:50,504
リンクや関連情報への
レスポンスも有益です

37
00:02:51,738 --> 00:02:54,408
もちろん このAPIの
ドキュメントは完璧です

38
00:02:54,508 --> 00:02:59,813
Apple DeveloperとXcodeで
使用中のプラットフォームは

39
00:02:59,913 --> 00:03:04,384
今年も継続され
REST APIも対象です

40
00:02:59,913 --> 00:03:04,384
今年も継続され
REST APIも対象です

41
00:03:04,484 --> 00:03:07,788
慣れ親しんだ
フレームワークが

42
00:03:07,888 --> 00:03:10,457
App Store Connect APIでも
利用できるのです

43
00:03:12,326 --> 00:03:16,029
App Store Connectの中で
頻繁に使うのに

44
00:03:16,129 --> 00:03:21,168
自動化が進んでいなかった
領域に注目しました

45
00:03:21,268 --> 00:03:26,640
特に ご覧の４つの領域から
ご紹介しましょう

46
00:03:27,140 --> 00:03:29,543
まずTestFlightは
全面的にカバーしています

47
00:03:29,643 --> 00:03:33,447
テスターやグループの管理
ビルドのレビューも可能

48
00:03:33,580 --> 00:03:36,583
昨日のセッションで
述べたように

49
00:03:36,683 --> 00:03:40,521
テスター獲得のための
リンクも設けます

50
00:03:40,854 --> 00:03:45,959
APIと緊密に連携し
リンクを管理できます

51
00:03:46,093 --> 00:03:51,331
両方使ってベータテストを
実行することもできます

52
00:03:52,733 --> 00:03:55,602
Users and Rolesでは
ユーザの追加や

53
00:03:55,702 --> 00:03:59,640
削除ができ
アクセス許可も可能です

54
00:04:00,073 --> 00:04:03,977
デベロッパウェブサイトと
App Store Connectに

55
00:04:04,077 --> 00:04:06,980
統合されたユーザ基盤が
できるわけです

56
00:04:07,080 --> 00:04:09,983
ユーザと役割が共有されます

57
00:04:10,884 --> 00:04:14,888
(拍手)

58
00:04:16,089 --> 00:04:19,159
Provisioningでは
開発デバイス追加や

59
00:04:19,259 --> 00:04:23,130
バンドルID登録や
認証情報などの管理もできる

60
00:04:23,597 --> 00:04:28,168
Reportsでは財務報告などを
ダウンロードできます

61
00:04:28,268 --> 00:04:31,471
APIに送るパラメータは

62
00:04:31,572 --> 00:04:35,676
Reporterに送るものと
ほぼ同じです

63
00:04:35,776 --> 00:04:37,744
だからスイッチしやすい

64
00:04:38,846 --> 00:04:42,883
最後の部分は
APIそのものでなく

65
00:04:42,983 --> 00:04:46,386
自動化に関わるので
取り上げました

66
00:04:46,620 --> 00:04:50,624
Transporterはいくつか
改良を加えました

67
00:04:50,791 --> 00:04:54,061
第１にLinuxで
公式にサポートされます

68
00:04:54,461 --> 00:04:58,832
また新しいAPIで使う
トークンは

69
00:04:58,932 --> 00:05:02,569
Transporterでも送れて
認証にも使えます

70
00:04:58,932 --> 00:05:02,569
Transporterでも送れて
認証にも使えます

71
00:05:02,669 --> 00:05:05,172
プロセスが簡単になります

72
00:05:07,140 --> 00:05:12,012
話すべきことが多いので
駆け足ですが お許しを

73
00:05:12,112 --> 00:05:15,249
次はAPIでの
データ取得と変更です

74
00:05:15,349 --> 00:05:20,487
APIのパーツ間の
関係について述べます

75
00:05:20,754 --> 00:05:25,092
エラー処理 APIアクセス
リクエスト認証を解説し

76
00:05:25,192 --> 00:05:27,427
ベストプラクティスを
紹介します

77
00:05:28,629 --> 00:05:29,830
準備はいい？

78
00:05:31,632 --> 00:05:33,867
(拍手)

79
00:05:33,967 --> 00:05:38,105
まずはデータ取得から
始めましょう

80
00:05:38,205 --> 00:05:41,175
api.appstoreconnect.
apple.com

81
00:05:41,275 --> 00:05:45,913
このAPIのベースから
URLを構築していきます

82
00:05:46,280 --> 00:05:48,482
最初に加えるのはバージョン

83
00:05:48,882 --> 00:05:52,519
どのAPIエンドポイントでも
今はv1です

84
00:05:52,986 --> 00:05:56,456
しかしApp Store Connectの
成長と変化に伴い

85
00:05:56,557 --> 00:06:00,460
番号が変わるとコードが
機能しなくなる可能性がある

86
00:05:56,557 --> 00:06:00,460
番号が変わるとコードが
機能しなくなる可能性がある

87
00:06:00,561 --> 00:06:05,799
だからバージョンアップ後も
しばらくは旧版も使えるよう

88
00:06:05,899 --> 00:06:08,168
移行期間を設けています

89
00:06:08,735 --> 00:06:13,140
バージョンの後は
リソースタイプ名です

90
00:06:13,340 --> 00:06:16,777
APIにおいて
極めて重要な概念です

91
00:06:16,877 --> 00:06:19,646
リソースは
APIの基礎ユニット

92
00:06:19,847 --> 00:06:25,052
概念上 APIはリソースの
集合体と考えられます

93
00:06:25,519 --> 00:06:28,088
APIのリソースの多くは

94
00:06:28,322 --> 00:06:32,860
App Store Connectで
なじみ深いものです

95
00:06:32,960 --> 00:06:34,394
見ていきましょう

96
00:06:34,495 --> 00:06:36,597
まずはユーザから

97
00:06:37,030 --> 00:06:39,633
完全なAPIのURLです

98
00:06:39,733 --> 00:06:44,972
api.appstoreconnect.apple.
com/v1/users

99
00:06:45,272 --> 00:06:48,242
全ユーザを表わしています

100
00:06:48,609 --> 00:06:53,146
このURLでJSON
オブジェクトが表示されます

101
00:06:53,547 --> 00:06:57,451
データプロパティが
まず目に入りますね

102
00:06:57,784 --> 00:07:02,523
レスポンスには常に
データプロパティが伴います

103
00:06:57,784 --> 00:07:02,523
レスポンスには常に
データプロパティが伴います

104
00:07:02,856 --> 00:07:06,360
この場合
ユーザリソースです

105
00:07:06,727 --> 00:07:10,697
今は１つだけですが
画面が大きければ

106
00:07:10,797 --> 00:07:13,800
すべてのユーザが
表示されます

107
00:07:14,434 --> 00:07:19,706
このリソースレスポンスの
データに注目します

108
00:07:20,040 --> 00:07:23,110
どのリソースも
固有のタイプとIDを持ち

109
00:07:23,310 --> 00:07:28,248
App Store Connect内で
識別されます

110
00:07:28,782 --> 00:07:32,786
皆さんが一番気になるのが
属性でしょう

111
00:07:32,886 --> 00:07:37,157
ユーザにとってはいわば
氏名とEメールアドレス

112
00:07:37,591 --> 00:07:43,664
これらは通常は文字列 数値
日付など単純な値ですが

113
00:07:43,764 --> 00:07:47,401
配列やオブジェクトのように
複雑な場合もあります

114
00:07:48,035 --> 00:07:50,404
属性の次は関係性です

115
00:07:50,704 --> 00:07:53,273
これについては後で述べます

116
00:07:53,674 --> 00:07:58,078
次にリンク
特にリソースセルフリンク

117
00:07:58,579 --> 00:08:02,082
特定のリソースを
識別するURLです

118
00:07:58,579 --> 00:08:02,082
特定のリソースを
識別するURLです

119
00:08:02,182 --> 00:08:04,751
この場合 最初のユーザです

120
00:08:04,852 --> 00:08:08,722
リソースセルフリンクは
どのリソースにも含まれます

121
00:08:09,756 --> 00:08:13,627
api.appstoreconnect.apple.comに
続けて

122
00:08:13,727 --> 00:08:17,564
バージョン：v1
リソースタイプ：ユーザ

123
00:08:17,664 --> 00:08:20,100
そして
リソースの識別子を表示

124
00:08:20,200 --> 00:08:24,972
これが分かれば
同じデータが取り出せます

125
00:08:25,105 --> 00:08:30,310
ただ実際にはすべての
ユーザが表示されます

126
00:08:32,578 --> 00:08:37,618
リソースのリストあるいは
各リソースが見られ―

127
00:08:37,717 --> 00:08:40,486
データの変更もできます

128
00:08:40,587 --> 00:08:43,756
一般的なRESTのやり方なので

129
00:08:43,857 --> 00:08:46,360
皆さんもご存じでしょう

130
00:08:46,894 --> 00:08:48,929
リソース入手の次は

131
00:08:49,029 --> 00:08:53,066
HTTP POSTメソッドを使う
新たなリソースの作成です

132
00:08:53,267 --> 00:08:58,805
リソース変更にはPATCH
削除にはDELETEを使います

133
00:08:59,339 --> 00:09:03,310
新しいユーザを
加えてみましょう

134
00:08:59,339 --> 00:09:03,310
新しいユーザを
加えてみましょう

135
00:09:03,810 --> 00:09:06,680
直接 加えることは
できません

136
00:09:06,780 --> 00:09:11,018
App Store Connect同様
ユーザを招待し

137
00:09:11,118 --> 00:09:13,120
承諾を受ける形です

138
00:09:13,220 --> 00:09:17,357
だからユーザ招待リソースを
作成します

139
00:09:17,658 --> 00:09:20,861
POSTメソッドです

140
00:09:21,261 --> 00:09:24,731
URLは固定されているので

141
00:09:25,032 --> 00:09:28,235
このユーザのデータも
ここで送ります

142
00:09:28,569 --> 00:09:32,606
ユーザを取得した時の
データに似ています

143
00:09:32,706 --> 00:09:35,075
しかし重大な違いがあります

144
00:09:35,275 --> 00:09:39,413
タイプはありますが
IDがありません

145
00:09:39,913 --> 00:09:43,050
Appleは全リソースに
IDを割り当てるので

146
00:09:43,150 --> 00:09:45,619
POSTにIDはありません

147
00:09:45,853 --> 00:09:48,989
作成には必要ないので
リンクもありません

148
00:09:49,089 --> 00:09:52,926
この場合は関係性も
省略しています

149
00:09:53,193 --> 00:09:55,863
このリクエストへの
レスポンスは―

150
00:09:56,096 --> 00:09:59,933
201 CREATEDとなっています

151
00:10:00,033 --> 00:10:04,338
成功を示す
RESTの一般的コードです

152
00:10:05,272 --> 00:10:09,576
レスポンスデータには
全リソース情報が含まれます

153
00:10:09,676 --> 00:10:11,411
これが重要な理由は２つ

154
00:10:11,512 --> 00:10:17,117
第１に作成されたリソースの
IDとセルフリンクは

155
00:10:17,217 --> 00:10:21,955
後で必要になった時に
ここで参照できるから

156
00:10:22,356 --> 00:10:24,725
第２にPOSTになかった属性が

157
00:10:24,825 --> 00:10:29,129
レスポンスに表示される
場合もあるからです

158
00:10:29,596 --> 00:10:35,402
例えばユーザ招待では
Appleは期限を設けます

159
00:10:35,502 --> 00:10:38,572
POSTには含まれていません

160
00:10:38,672 --> 00:10:43,911
Appleのルールが適用された
レスポンスデータは

161
00:10:44,011 --> 00:10:47,781
リソースの全容を知るために
極めて重要です

162
00:10:49,216 --> 00:10:52,386
ユーザの承諾で
招待は完了です

163
00:10:52,486 --> 00:10:56,223
後に変更を加えたい場合も
あるでしょう

164
00:10:56,323 --> 00:11:00,260
例えばこのユーザの役割は
デベロッパです

165
00:10:56,323 --> 00:11:00,260
例えばこのユーザの役割は
デベロッパです

166
00:11:00,627 --> 00:11:03,931
マーケティングの役割を
加えてみます

167
00:11:04,665 --> 00:11:08,135
変更には
PATCHリクエストを使います

168
00:11:08,335 --> 00:11:13,240
この場合のURLはユーザの
リソースセルフリンク

169
00:11:13,740 --> 00:11:17,711
役割の属性だけを記載します

170
00:11:17,811 --> 00:11:22,916
このリクエストで
マーケティングを加えます

171
00:11:23,016 --> 00:11:28,121
他に変更の必要はないので
属性だけ記載します

172
00:11:28,789 --> 00:11:31,959
このリクエストの
レスポンスが成功すると

173
00:11:32,459 --> 00:11:37,297
変更後のリソースの
全容が送られてきます

174
00:11:38,699 --> 00:11:41,201
最後の処理である削除は

175
00:11:41,301 --> 00:11:45,072
リソースセルフリンクに
DELETEリクエストを出すだけ

176
00:11:45,172 --> 00:11:49,343
204 NO CONTENTという
レスポンスが返ってきます

177
00:11:49,810 --> 00:11:54,748
REST通なら200番台の意味は
成功だとご存じですね

178
00:11:54,848 --> 00:11:58,819
ユーザが削除されたことを
示しています

179
00:11:58,919 --> 00:12:04,925
他のデータは不要なので
NO CONTENTとします

180
00:11:58,919 --> 00:12:04,925
他のデータは不要なので
NO CONTENTとします

181
00:12:07,094 --> 00:12:10,430
次の話題に移る前に
セフンの登場です

182
00:12:10,531 --> 00:12:14,468
リソースの使い方の
実例をお見せします

183
00:12:14,568 --> 00:12:15,435
セフン

184
00:12:16,036 --> 00:12:20,674
(拍手)

185
00:12:21,909 --> 00:12:22,976
ありがとう ジェフ

186
00:12:24,311 --> 00:12:29,049
TestFlightチーム
エンジニアのセフン･ションです

187
00:12:29,149 --> 00:12:32,219
App Source Connect APIの
ライブデモをします

188
00:12:33,287 --> 00:12:37,624
ユーザリソースへの
API適用例を取り上げます

189
00:12:38,292 --> 00:12:42,329
チームのメンバーが
退職したとします

190
00:12:42,429 --> 00:12:46,733
App Source Connectで
このユーザを削除します

191
00:13:02,249 --> 00:13:06,820
GET v1/usersに
GETリクエストを出して

192
00:13:06,920 --> 00:13:10,557
チームの
ユーザリストを入手します

193
00:13:10,991 --> 00:13:14,328
アクセスできる
全ユーザが表示されます

194
00:13:15,162 --> 00:13:21,068
フィルタパラメータを使い
Eメールで検索します

195
00:13:21,168 --> 00:13:26,206
フィルタパラメータで
条件を規定します

196
00:13:26,306 --> 00:13:28,175
JohnAppleseed@mac.com

197
00:13:28,275 --> 00:13:30,010
このリクエストを送ります

198
00:13:30,944 --> 00:13:34,648
該当するEメールの
ユーザが表示されます

199
00:13:36,149 --> 00:13:41,688
ユーザのIDを使って
インスタンスを入手します

200
00:13:42,456 --> 00:13:45,659
users/IDです

201
00:13:46,326 --> 00:13:49,997
適合するIDを持つユーザの
インスタンスが返ってきます

202
00:13:51,498 --> 00:13:54,902
John Appleseedの
レスポンスが戻ります

203
00:13:55,469 --> 00:13:59,106
探しているユーザが
見つかりました

204
00:13:59,206 --> 00:14:02,543
DELETEリクエストを
セルフリンクに送ります

205
00:13:59,206 --> 00:14:02,543
DELETEリクエストを
セルフリンクに送ります

206
00:14:03,343 --> 00:14:06,313
GETをDELETEに置き換えます

207
00:14:07,114 --> 00:14:09,817
適合するIDを持つユーザが
削除されます

208
00:14:13,120 --> 00:14:17,057
削除が成功し
NO CONTENTと表示されます

209
00:14:17,157 --> 00:14:19,726
ユーザのコンテンツは
もう使えません

210
00:14:20,227 --> 00:14:25,766
最後にGETリクエストを送り
削除を確認します

211
00:14:27,234 --> 00:14:31,638
404 NOT FOUNDで
削除が確認されました

212
00:14:34,508 --> 00:14:39,179
ユーザ情報の入手と
インスタンスの検索

213
00:14:39,847 --> 00:14:45,486
フィルタによる検索方法と
ユーザ削除をやってみました

214
00:14:45,752 --> 00:14:50,324
ユーザリソースの使い方の
デモを終わります

215
00:14:50,424 --> 00:14:52,693
ジェフにマイクを戻します

216
00:14:53,527 --> 00:14:57,531
(拍手)

217
00:14:59,500 --> 00:15:00,467
ありがとう セフン

218
00:14:59,500 --> 00:15:00,467
ありがとう セフン

219
00:15:02,402 --> 00:15:08,175
リソースの作成 解読 更新
削除の方法が分かりましたね

220
00:15:08,275 --> 00:15:11,812
基本的にはそれが
必要なことのすべてです

221
00:15:11,912 --> 00:15:15,883
しかし関係性について
まだ触れていません

222
00:15:15,983 --> 00:15:21,488
リソースそのものでなく
関係性が知りたいこともある

223
00:15:21,889 --> 00:15:23,457
例を挙げましょう

224
00:15:23,824 --> 00:15:28,262
Beta Groupは
TestFlight内の全グループ

225
00:15:28,395 --> 00:15:33,467
Beta Testerは
アプリケーションのテスター

226
00:15:33,934 --> 00:15:37,337
テスターはグループに
入れられます

227
00:15:37,638 --> 00:15:40,908
APIでは
どんなモデルになるでしょう

228
00:15:41,441 --> 00:15:43,310
まずBeta Group

229
00:15:43,410 --> 00:15:47,915
v1/betaGroupsで
グループの情報が現れます

230
00:15:48,048 --> 00:15:51,985
第１グループの
関係性の項目には

231
00:15:52,286 --> 00:15:57,457
アプリケーション ビルド
ベータテスターの３つ

232
00:15:57,558 --> 00:16:01,128
今日はベータテスターだけに
注目します

233
00:15:57,558 --> 00:16:01,128
今日はベータテスターだけに
注目します

234
00:16:01,728 --> 00:16:04,164
別のリンクの項目には―

235
00:16:04,531 --> 00:16:09,870
第１グループのテスターの
関係性に関わるリンク

236
00:16:09,970 --> 00:16:13,006
各グループに
こうした項目があります

237
00:16:13,540 --> 00:16:17,945
２つのうち最初のリンクは
関係性セルフリンク

238
00:16:18,045 --> 00:16:21,982
関係性そのものを表わす
URLです

239
00:16:22,683 --> 00:16:27,221
このURLで
この関係性を操作します

240
00:16:27,754 --> 00:16:28,989
こういうことです

241
00:16:29,089 --> 00:16:32,025
このグループに
テスターを加えたいが

242
00:16:32,125 --> 00:16:36,730
TestFlightにはすでに
テスターもグループもある

243
00:16:36,830 --> 00:16:41,301
既存のテスターを既存の
グループに加えることは

244
00:16:42,569 --> 00:16:46,373
これまでに学習したことと
矛盾します

245
00:16:46,473 --> 00:16:51,445
つまりテスターの作成 編集
削除はしない

246
00:16:51,645 --> 00:16:53,847
少なくともグループの属性は
編集しないと学んだ

247
00:16:53,947 --> 00:16:57,184
従って概念的には
グループとテスターの

248
00:16:57,284 --> 00:17:00,187
新たな関係の構築と考えます

249
00:16:57,284 --> 00:17:00,187
新たな関係の構築と考えます

250
00:17:00,287 --> 00:17:03,056
ここに関係性セルフリンクが
登場します

251
00:17:03,457 --> 00:17:07,528
関係性セルフリンクに
POSTリクエストを出します

252
00:17:08,127 --> 00:17:12,465
ここでグループに加えたい
２つのテスターの

253
00:17:12,566 --> 00:17:14,635
タイプとIDを送ります

254
00:17:15,035 --> 00:17:18,238
２つのテスターをグループに
加えるリクエストです

255
00:17:18,338 --> 00:17:22,175
すでにTestFlightにあるので
テスターの情報は不要

256
00:17:22,443 --> 00:17:26,380
レスポンスは
204 NO CONTENT

257
00:17:26,480 --> 00:17:29,516
テスターがグループに
加えられました

258
00:17:30,217 --> 00:17:33,887
グループからテスターを
取り出したい場合は？

259
00:17:33,987 --> 00:17:38,659
同じデータフォーマットと
URLが使えます

260
00:17:38,759 --> 00:17:41,461
POSTをDELETEに
変えるだけです

261
00:17:43,564 --> 00:17:47,334
Beta Groupの
第２リンクを見ましょう

262
00:17:47,901 --> 00:17:51,238
いわゆる関連リンクです

263
00:17:51,505 --> 00:17:56,376
この場合このグループの
テスターを表わします

264
00:17:56,476 --> 00:18:00,080
データからベータテスターの
情報が現れます

265
00:17:56,476 --> 00:18:00,080
データからベータテスターの
情報が現れます

266
00:18:00,180 --> 00:18:05,786
v1/beta testersの場合と
同じフォーマットですが

267
00:18:05,886 --> 00:18:11,191
TestFlight全体でなく
このグループのテスターです

268
00:18:12,359 --> 00:18:15,162
ここで確認させてください

269
00:18:15,262 --> 00:18:21,001
“このグループ”はURLに
識別子があるグループです

270
00:18:21,201 --> 00:18:23,470
だから このURLで
テスターを取得できます

271
00:18:23,570 --> 00:18:29,042
複数のグループが対象なら
複数のリクエストが必要です

272
00:18:29,376 --> 00:18:31,345
それは不便ですね

273
00:18:31,445 --> 00:18:35,282
だから関連データを入手する
別の方法もあります

274
00:18:35,549 --> 00:18:39,419
v1/betaGroupsに

275
00:18:39,520 --> 00:18:43,657
include=betatestersを
追加します

276
00:18:43,757 --> 00:18:47,127
ベータグループに加えて

277
00:18:47,227 --> 00:18:51,231
各グループの関連テスターの
情報表示のリクエストです

278
00:18:53,200 --> 00:18:54,368
実際にやると

279
00:18:54,701 --> 00:18:58,005
Beta Groupの情報が
表示されます

280
00:18:58,105 --> 00:19:01,508
第１グループのテスターの
関係性を見ると

281
00:18:58,105 --> 00:19:01,508
第１グループのテスターの
関係性を見ると

282
00:19:01,608 --> 00:19:03,710
データという新項目が
あります

283
00:19:04,611 --> 00:19:08,649
このグループのテスターの
タイプとIDを示します

284
00:19:08,749 --> 00:19:14,254
この情報の各グループ内の
ベータテスターの関係性に

285
00:19:14,354 --> 00:19:18,125
それぞれデータの項目が
あります

286
00:19:18,225 --> 00:19:22,229
タイプとID以外の
テスター情報は？

287
00:19:22,329 --> 00:19:27,768
レスポンスの最下部に
新項目includeがあります

288
00:19:28,168 --> 00:19:31,972
テスターの全情報を
表示しています

289
00:19:32,072 --> 00:19:36,577
通常 includeの項目には
関係性に基づき

290
00:19:36,677 --> 00:19:40,681
各リソースの全情報が
記載されます

291
00:19:41,081 --> 00:19:46,453
タイプとIDでテスターが
どのグループかが分かります

292
00:19:48,021 --> 00:19:49,523
疑問に思われるでしょう

293
00:19:49,623 --> 00:19:53,193
なぜ全グループに
データ項目があり

294
00:19:53,293 --> 00:19:58,565
その中の全テスターに
include項目があるのか

295
00:19:58,866 --> 00:20:02,803
複数のグループに属する
テスターもいます

296
00:19:58,866 --> 00:20:02,803
複数のグループに属する
テスターもいます

297
00:20:03,070 --> 00:20:05,806
この構造であれば―

298
00:20:05,939 --> 00:20:09,576
グループの数に関わらず
データは１つになります

299
00:20:11,311 --> 00:20:16,717
再びセフンが関係性について
具体例を見せてくれます

300
00:20:16,817 --> 00:20:17,551
セフン

301
00:20:19,620 --> 00:20:23,423
(拍手)

302
00:20:23,524 --> 00:20:24,391
ありがとう ジェフ

303
00:20:26,593 --> 00:20:31,165
TestFlightでベータグループ
を作成してテスターを加え

304
00:20:31,265 --> 00:20:35,769
テスターとグループの
関係性を見てみます

305
00:20:35,869 --> 00:20:37,137
始めます

306
00:20:46,480 --> 00:20:51,618
エンドポイントにアクセスし
ベータグループを作成します

307
00:20:51,718 --> 00:20:53,854
v1/betaGroups

308
00:20:54,288 --> 00:20:58,258
リソース作成時には
ペイロードも必要です

309
00:20:58,358 --> 00:21:01,628
ベータグループのタイプと
属性を伴うデータです

310
00:20:58,358 --> 00:21:01,628
ベータグループのタイプと
属性を伴うデータです

311
00:21:02,029 --> 00:21:05,165
グループ作成時に必要なのは
名前だけなので

312
00:21:05,933 --> 00:21:09,903
単純にTest Groupとします

313
00:21:10,604 --> 00:21:12,172
リクエストを送ります

314
00:21:13,640 --> 00:21:17,411
409 CONFLICTという
レスポンスの意味は

315
00:21:18,612 --> 00:21:22,483
関係性アプリケーションの
値が必要ということ

316
00:21:22,849 --> 00:21:26,887
アプリケーションに属さない
グループは作成できません

317
00:21:26,987 --> 00:21:30,657
アプリケーションに
関連づけるために

318
00:21:31,091 --> 00:21:34,695
ペイロードに
関係性を加えます

319
00:21:36,997 --> 00:21:40,534
ペイロードに関係性を記載
したアプリケーションに

320
00:21:40,801 --> 00:21:46,306
ベータグループが
リンクすることになります

321
00:21:46,607 --> 00:21:51,211
Test Group作成の
準備が完了しました

322
00:21:52,513 --> 00:21:54,414
リクエストを送ります

323
00:21:54,915 --> 00:21:57,251
201 CREATED

324
00:21:57,351 --> 00:22:01,255
このレスポンスで生成された
IDをコピーします

325
00:21:57,351 --> 00:22:01,255
このレスポンスで生成された
IDをコピーします

326
00:22:04,157 --> 00:22:06,059
Test Groupが作成されました

327
00:22:06,160 --> 00:22:08,695
この名前が気に入らなければ

328
00:22:09,463 --> 00:22:14,067
PATCHリクエストで
変更できます

329
00:22:15,469 --> 00:22:19,773
PATCHに続き
“betaGroups/該当ID”です

330
00:22:21,875 --> 00:22:25,679
このようにペイロードも
送ります

331
00:22:25,779 --> 00:22:30,317
修正データが正しいことを
確認するために

332
00:22:30,617 --> 00:22:32,920
IDも示す必要があります

333
00:22:34,188 --> 00:22:36,590
ベータグループのIDを
ペーストします

334
00:22:36,990 --> 00:22:42,329
名前だけ変更して
WWDC Groupとします

335
00:22:44,464 --> 00:22:49,670
200レスポンスが戻り
名前の変更が完了です

336
00:22:50,637 --> 00:22:54,842
グループを作成したので
テスターを加えます

337
00:22:55,209 --> 00:22:59,513
エンドポイント宛てに
POSTリクエストを送ります

338
00:23:00,747 --> 00:23:04,051
v1/betaTesters

339
00:23:05,285 --> 00:23:08,722
ペイロードも
送る必要があります

340
00:23:09,256 --> 00:23:12,159
ベータテスターのタイプと
属性一覧が含まれます

341
00:23:12,259 --> 00:23:15,162
Kate Bellという名の
テスターを作ります

342
00:23:15,729 --> 00:23:20,868
ベータグループと関連のある
ベータテスターです

343
00:23:20,968 --> 00:23:23,504
同時にベータグループに
割り当てられます

344
00:23:24,004 --> 00:23:30,110
IDをペーストすると
テスターが割り当てられます

345
00:23:32,346 --> 00:23:34,081
201 CREATEDのレスポンス

346
00:23:34,181 --> 00:23:38,485
テスターがグループに
割り当てられました

347
00:23:39,052 --> 00:23:41,522
もう１つテスターを加えます

348
00:23:41,688 --> 00:23:46,827
この属性の部分の名前を
置き換えるだけで

349
00:23:48,061 --> 00:23:51,365
John Appleseedも
作成されます

350
00:23:54,601 --> 00:23:57,771
再び201 CREATEDの
レスポンス

351
00:23:58,172 --> 00:24:00,507
２つのテスターを
グループに加えました

352
00:23:58,172 --> 00:24:00,507
２つのテスターを
グループに加えました

353
00:24:00,841 --> 00:24:06,113
ベータグループとベータ
テスターの関連リンクに

354
00:24:07,014 --> 00:24:10,884
GETリクエストを送り
確認します

355
00:24:11,818 --> 00:24:16,723
/the id of the group/
betaTestersです

356
00:24:17,458 --> 00:24:23,030
このIDで割り当てられる
テスターが表示されます

357
00:24:24,832 --> 00:24:28,402
先ほど加えたJohn
Appleseedがあります

358
00:24:29,269 --> 00:24:34,775
このレスポンスには属性や
関係など情報が満載です

359
00:24:34,875 --> 00:24:38,111
Eメールだけ
知りたい場合は？

360
00:24:38,846 --> 00:24:42,883
フィールドと呼ばれる
パラメータで限定できます

361
00:24:42,983 --> 00:24:47,654
知りたい情報だけを
表示することができます

362
00:24:48,288 --> 00:24:53,460
ベータテスターフィールドを
Eメールと同じにすると

363
00:24:54,995 --> 00:24:59,633
レスポンスには
Eメールだけが表示されます

364
00:25:00,334 --> 00:25:03,737
ベータグループに
２つのテスターを加えました

365
00:25:09,977 --> 00:25:14,114
ベータグループと
ベータテスターの作成

366
00:25:14,214 --> 00:25:16,850
テスターとグループの関係性
も紹介しました

367
00:25:17,384 --> 00:25:21,155
App Store Connect APIの
使い方のデモでした

368
00:25:21,255 --> 00:25:23,423
ジェフにマイクを返します

369
00:25:23,891 --> 00:25:28,695
(拍手)

370
00:25:29,930 --> 00:25:31,899
ありがとう セフン

371
00:25:32,599 --> 00:25:37,905
データ入手と変更 関係性に
ついて述べてもらいました

372
00:25:38,005 --> 00:25:40,440
APIの基本的機能を
カバーしています

373
00:25:40,541 --> 00:25:46,113
でもリクエスト処理が
失敗することもあるから

374
00:25:46,213 --> 00:25:51,351
次はAPIのエラー表示を
見ていきましょう

375
00:25:52,152 --> 00:25:55,522
リクエストに失敗すると
こういうレスポンスが来ます

376
00:25:56,523 --> 00:26:01,762
HTTPレスポンスの
ステータスが表示されます

377
00:25:56,523 --> 00:26:01,762
HTTPレスポンスの
ステータスが表示されます

378
00:26:01,962 --> 00:26:06,500
通常 400番台の
エラーコードとなります

379
00:26:06,600 --> 00:26:10,737
RESTクライアントライブラリ
の多くは

380
00:26:10,838 --> 00:26:15,542
“success”などの関数で
リクエストの成否を伝えます

381
00:26:15,909 --> 00:26:19,713
詳細が知りたければ
レスポンスを読み込みます

382
00:26:19,947 --> 00:26:25,419
失敗した場合は
エラープロパティが現れます

383
00:26:25,519 --> 00:26:27,588
エラーオブジェクトの
情報です

384
00:26:27,688 --> 00:26:32,726
リクエストに複数の問題が
認められる場合は

385
00:26:33,460 --> 00:26:38,599
IDで特定のレスポンスの
特定のエラーを識別します

386
00:26:38,699 --> 00:26:43,937
Apple側に問題がある場合
報告により追跡ができます

387
00:26:44,471 --> 00:26:47,307
さらに便利なのは
タイトルと詳細です

388
00:26:47,474 --> 00:26:51,378
何が悪かったか
英語で説明が表示されます

389
00:26:51,478 --> 00:26:54,681
タイトルから
パラメータに問題があり

390
00:26:54,948 --> 00:27:01,054
詳細からそれがEメールの
スペルミスだと分かります

391
00:26:54,948 --> 00:27:01,054
詳細からそれがEメールの
スペルミスだと分かります

392
00:27:01,255 --> 00:27:06,260
トラブルシューティングと
学習に役立つ記録です

393
00:27:07,027 --> 00:27:11,064
コードによる解釈は
気が進まないでしょう

394
00:27:11,165 --> 00:27:16,069
しかしメッセージの文言は
変わる可能性があるので

395
00:27:17,037 --> 00:27:21,008
プログラムエラーの処理では
コードの利用を勧めます

396
00:27:21,308 --> 00:27:25,212
これは機械が読める
問題を示す文字列で

397
00:27:25,379 --> 00:27:29,483
ドットで区切られた
階層構造を持つ値です

398
00:27:29,583 --> 00:27:32,719
この例の
パラメータエラーでは

399
00:27:32,820 --> 00:27:36,123
パラメータの１つが無効です

400
00:27:36,590 --> 00:27:39,193
長く具体的なコードですが

401
00:27:39,593 --> 00:27:42,930
詳細まで
必要ない時もありますね

402
00:27:43,030 --> 00:27:47,634
だからコードの
プレフィックスの照合で

403
00:27:47,734 --> 00:27:51,438
必要に応じた内容を示す
構造にしました

404
00:27:51,805 --> 00:27:57,044
ユーザに詳細な報告が
必要な場合は申告すれば

405
00:27:57,144 --> 00:28:00,714
我々が十分な情報を
提供します

406
00:27:57,144 --> 00:28:00,714
我々が十分な情報を
提供します

407
00:28:00,814 --> 00:28:03,217
ソースパラメータについても
支援します

408
00:28:03,884 --> 00:28:08,522
可能ならエラーの原因の
リクエストまで遡及もします

409
00:28:08,622 --> 00:28:13,460
ここでエラーを起こしたのは
filter[email]パラメータ

410
00:28:13,961 --> 00:28:17,331
ソースは
こうしたパラメータか

411
00:28:17,431 --> 00:28:22,002
原因を示すデータで
該当箇所を示すJSONポインタ

412
00:28:23,570 --> 00:28:26,907
App Store Connect APIの
基本は以上です

413
00:28:27,007 --> 00:28:30,644
残るはこのAPI入手と
リクエスト送信の方法です

414
00:28:30,744 --> 00:28:35,015
ジュリーが皆さんの
お手伝いをします

415
00:28:35,782 --> 00:28:36,350
ジュリー

416
00:28:36,450 --> 00:28:39,753
(拍手)

417
00:28:45,392 --> 00:28:49,797
App Store Connectチーム
エンジニアのジュリーです

418
00:28:50,164 --> 00:28:53,767
アクセスと認証について
お話しします

419
00:28:54,334 --> 00:29:00,307
利用できるエンドポイントの
さまざまな例を見てきました

420
00:28:54,334 --> 00:29:00,307
利用できるエンドポイントの
さまざまな例を見てきました

421
00:29:00,741 --> 00:29:04,111
新機能のテストを始めたい時

422
00:29:04,344 --> 00:29:08,348
GETリクエストを送りますね

423
00:29:08,849 --> 00:29:12,586
単純にこのエンドポイントを
入力すると

424
00:29:12,686 --> 00:29:17,424
このようなレスポンスが
返ってくることになります

425
00:29:18,258 --> 00:29:23,063
ジェフが言ったように
重要なステップである―

426
00:29:23,163 --> 00:29:26,133
認証情報が抜けています

427
00:29:27,568 --> 00:29:31,038
このステップは
２つの理由から必要です

428
00:29:31,472 --> 00:29:36,076
第１にリクエストに
コンテキストを与えるから

429
00:29:36,176 --> 00:29:40,347
すべてのアプリケーションが
必要なわけじゃない

430
00:29:40,514 --> 00:29:44,952
重要なのは認証情報が
APIの安全を守り

431
00:29:45,185 --> 00:29:49,089
データへの不正アクセスを
防ぐこと

432
00:29:50,791 --> 00:29:54,094
だからリクエストに
認証情報を加えるため

433
00:29:54,194 --> 00:29:57,431
まずAPIキーを作成します

434
00:29:57,798 --> 00:30:01,535
そのキーを使って
生成したトークンが

435
00:29:57,798 --> 00:30:01,535
そのキーを使って
生成したトークンが

436
00:30:01,635 --> 00:30:05,305
リクエストの送信に
必要になります

437
00:30:05,739 --> 00:30:08,308
APIキーから始めましょう

438
00:30:09,943 --> 00:30:13,781
パブリックとプライベートが
セットになっています

439
00:30:15,015 --> 00:30:20,487
プライベートキーが
トークンに署名を加えます

440
00:30:22,256 --> 00:30:26,493
Appleがパブリックキーで
その署名を検証し

441
00:30:26,593 --> 00:30:30,964
関連するプライベートキーの
署名であることを確認します

442
00:30:33,600 --> 00:30:37,971
App Store Connectに
ログインし

443
00:30:38,071 --> 00:30:41,942
新APIキータブを選択します

444
00:30:42,709 --> 00:30:47,548
チームのAPIキーの管理は
管理ユーザに限られます

445
00:30:47,915 --> 00:30:52,085
作成したキーは
不要になれば無効化できます

446
00:30:53,687 --> 00:30:57,057
アクセスレベルをキーに
割り当てることで

447
00:30:57,357 --> 00:31:02,129
どのAPIサービスに
使えるかが決まります

448
00:30:57,357 --> 00:31:02,129
どのAPIサービスに
使えるかが決まります

449
00:31:03,664 --> 00:31:06,467
作成されたキーは
このリストに表示され

450
00:31:06,567 --> 00:31:12,406
プライベートキーファイルは
ダウンロードできます

451
00:31:13,707 --> 00:31:19,046
ただし このキーは
Appleに保管されないので

452
00:31:20,013 --> 00:31:23,016
ダウンロードは１度きりです

453
00:31:23,283 --> 00:31:26,220
ダウンロードして初めて

454
00:31:26,320 --> 00:31:29,323
プライベートキーが
生成されます

455
00:31:30,057 --> 00:31:33,193
本物の鍵と同じだと
考えてください

456
00:31:33,460 --> 00:31:37,798
所有者本人が管理し
守る必要があります

457
00:31:39,366 --> 00:31:44,571
本物の鍵と同じく
有効期限はありません

458
00:31:44,671 --> 00:31:49,643
App Store Connectで
無効にしない限り

459
00:31:50,110 --> 00:31:53,146
紛失や盗難の場合も
失効しません

460
00:31:53,413 --> 00:31:57,951
このためキーの保護は
非常に重要です

461
00:31:59,153 --> 00:32:05,159
プライベートキーファイルを
受け取ったらJWTが作れます

462
00:31:59,153 --> 00:32:05,159
プライベートキーファイルを
受け取ったらJWTが作れます

463
00:32:05,893 --> 00:32:09,897
このトークンには
いくつかの情報が必要です

464
00:32:10,898 --> 00:32:15,869
第１にアカウント識別子の
Issuer ID

465
00:32:15,969 --> 00:32:19,773
このIDはこのページの
冒頭に表示されます

466
00:32:21,208 --> 00:32:25,379
このキーのIDが
トークン作成に必要です

467
00:32:25,779 --> 00:32:30,050
このページにも
表示されています

468
00:32:30,350 --> 00:32:33,520
それぞれのキーに
固有のIDです

469
00:32:36,256 --> 00:32:39,359
各トークンには期限を示す
タイムスタンプも必要です

470
00:32:39,459 --> 00:32:43,130
キーには有効期限は
ありませんが

471
00:32:43,230 --> 00:32:46,600
トークンは
20分しか使えません

472
00:32:47,334 --> 00:32:51,505
情報の最後の２つの部分は
常に同じ

473
00:32:51,872 --> 00:32:56,577
App Store Connect APIでは

474
00:32:56,677 --> 00:32:59,079
どのトークンでも一律です

475
00:32:59,179 --> 00:33:04,118
１つ目はオーディエンス
App Store Connectです

476
00:32:59,179 --> 00:33:04,118
１つ目はオーディエンス
App Store Connectです

477
00:33:05,452 --> 00:33:08,689
最後にトークンの
署名に使う―

478
00:33:08,789 --> 00:33:12,793
アルゴリズムを
割り当てる必要があります

479
00:33:13,126 --> 00:33:16,830
これにはES256を選びました

480
00:33:17,431 --> 00:33:21,502
JWT支援アルゴリズムに
対応するものが

481
00:33:21,602 --> 00:33:23,804
適切だと考えました

482
00:33:23,904 --> 00:33:27,674
でもこのアルゴリズムを
実行する必要はありません

483
00:33:28,208 --> 00:33:33,180
幸いJWTは多言語で
ライブラリを提供しています

484
00:33:33,280 --> 00:33:38,151
非常に簡単にトークンの
作成や署名ができます

485
00:33:39,319 --> 00:33:43,156
この例はRubyで
書かれています

486
00:33:43,257 --> 00:33:48,629
プライベートキーと共に
情報を提供するだけで

487
00:33:48,729 --> 00:33:52,666
このエンコードメソッドで
完璧なトークンができます

488
00:33:54,001 --> 00:33:57,704
このトークンを
リクエストに加えます

489
00:33:57,805 --> 00:34:01,375
認証ヘッダーに
記載するだけです

490
00:33:57,805 --> 00:34:01,375
認証ヘッダーに
記載するだけです

491
00:34:03,777 --> 00:34:08,248
キーの作成方法と
リクエストの仕方が

492
00:34:08,348 --> 00:34:11,284
これで分かりましたね

493
00:34:12,252 --> 00:34:13,853
やってみましょう

494
00:34:23,130 --> 00:34:26,166
新しいAPIキーのページです

495
00:34:26,266 --> 00:34:28,202
まだキーはありません

496
00:34:28,435 --> 00:34:32,572
では実際に
キーを作ってみましょう

497
00:34:32,806 --> 00:34:35,409
名前はDemoとし
アクセスレベルを決めます

498
00:34:35,509 --> 00:34:38,612
財務を選んで
キーを取得したとします

499
00:34:38,712 --> 00:34:43,116
このキーは財務報告書などに
アクセスできますが

500
00:34:43,217 --> 00:34:47,987
ベータテスターやビルドには
アクセスできません

501
00:34:48,188 --> 00:34:52,326
アクセスレベルは
変更できます

502
00:34:52,559 --> 00:34:55,429
Adminを選ぶと全APIに
アクセスできるので

503
00:34:55,529 --> 00:34:58,665
キーを作成する時は
Adminで通します

504
00:34:59,566 --> 00:35:03,370
プライベートキーで
ダウンロードができます

505
00:34:59,566 --> 00:35:03,370
プライベートキーで
ダウンロードができます

506
00:35:04,271 --> 00:35:08,842
プライベートキーの
ダウンロードは１度だけ

507
00:35:09,109 --> 00:35:13,747
キーを紛失したり削除すると
再ダウンロードはできません

508
00:35:13,847 --> 00:35:18,452
だからすぐにダウンロード
できるようにします

509
00:35:19,253 --> 00:35:21,622
ではダウンロードします

510
00:35:23,257 --> 00:35:26,326
ダウンロードフォルダに
プライベートキーがあります

511
00:35:26,793 --> 00:35:29,263
先ほど見たスクリプトを
引き出せます

512
00:35:29,863 --> 00:35:33,333
ISSUER IDをコピーします

513
00:35:37,871 --> 00:35:40,908
すべてのAPIキーで共通です

514
00:35:41,041 --> 00:35:45,679
プライベートキーのIDも
コピーします

515
00:35:49,850 --> 00:35:55,422
ID入力後プライベートキーが
読み込まれます

516
00:35:55,522 --> 00:35:57,357
新トークンを生成します

517
00:35:58,292 --> 00:36:01,528
アプリケーションの
エンドポイントを

518
00:35:58,292 --> 00:36:01,528
アプリケーションの
エンドポイントを

519
00:36:02,262 --> 00:36:04,665
ターミナルで
リクエストします

520
00:36:06,133 --> 00:36:10,070
予想どおり401の
レスポンスが来ました

521
00:36:10,270 --> 00:36:12,306
スクリプトを呼び出し

522
00:36:18,145 --> 00:36:22,449
取得した新たなトークンを
取り出し

523
00:36:24,051 --> 00:36:25,786
リクエストに加えます

524
00:36:29,289 --> 00:36:32,159
認証ヘッダーに記載します

525
00:36:32,492 --> 00:36:33,861
スペルは正確に

526
00:36:38,332 --> 00:36:40,367
アプリケーションのリストに
戻ります

527
00:36:40,901 --> 00:36:45,539
(拍手)

528
00:36:45,639 --> 00:36:49,009
ご覧のとおり
簡単なステップで

529
00:36:49,109 --> 00:36:53,614
APIへのアクセスと
データの入手ができました

530
00:36:54,047 --> 00:36:55,716
ジェフにマイクを返します

531
00:36:56,083 --> 00:37:00,521
(拍手)

532
00:36:56,083 --> 00:37:00,521
(拍手)

533
00:37:02,589 --> 00:37:03,857
ありがとう ジュリー

534
00:37:04,625 --> 00:37:05,526
すごいよね

535
00:37:06,427 --> 00:37:08,896
アクセスと認証のデモでした

536
00:37:08,996 --> 00:37:13,333
残り数分でAPIの
ベストプラクティスの話を

537
00:37:14,401 --> 00:37:17,204
ジュリーが言ったように
キーは出発点です

538
00:37:17,304 --> 00:37:20,474
所有者本人の責任で守ります

539
00:37:20,574 --> 00:37:23,344
キーを持っていれば誰でも
データにアクセスできる

540
00:37:23,444 --> 00:37:27,281
だからキーは安全な場所に
保管するのが理想です

541
00:37:27,381 --> 00:37:33,520
コードで確認と記憶をし
データベースなどに入れない

542
00:37:33,620 --> 00:37:38,926
ディスクに保管する場合は
チェックを強化します

543
00:37:39,026 --> 00:37:42,796
キーが何らかの理由で
外部に漏れた場合は

544
00:37:42,896 --> 00:37:46,300
App Store Connectで
キーを無効化します

545
00:37:47,401 --> 00:37:50,904
キーから生成したトークンは

546
00:37:51,004 --> 00:37:54,308
リクエストごとに
変える必要はありません

547
00:37:54,408 --> 00:37:57,544
むしろ同じトークンを
何度も使うほうが

548
00:37:57,644 --> 00:38:00,414
コードもApple側も
パフォーマンスが上がります

549
00:37:57,644 --> 00:38:00,414
コードもApple側も
パフォーマンスが上がります

550
00:38:00,514 --> 00:38:04,551
スクリプトに基づいて
トークンを生成し

551
00:38:04,751 --> 00:38:07,121
リクエストと共に送る

552
00:38:07,354 --> 00:38:12,492
皆さんは使用期限を
しっかり把握しているから

553
00:38:12,593 --> 00:38:16,663
プロセスを
完了させられますね

554
00:38:17,898 --> 00:38:21,935
プロセスが20分を超えたり
継続する場合は

555
00:38:22,035 --> 00:38:24,938
構成を変えて対応します

556
00:38:25,239 --> 00:38:28,642
20分のトークンを生成し
必要に応じて使い

557
00:38:28,976 --> 00:38:33,447
例えば18分ごとに
新たなトークンを発行します

558
00:38:33,547 --> 00:38:38,952
トークンを最大限に利用でき
期限切れにならずに済みます

559
00:38:40,721 --> 00:38:43,957
次の話題はレスポンスに
含まれるリンクです

560
00:38:44,191 --> 00:38:48,062
今日取り上げたのは一種の
セルフドキュメントで

561
00:38:48,162 --> 00:38:51,198
データから他に使えるものを
見極める方法です

562
00:38:51,298 --> 00:38:55,869
しかし本来は
自分のコードで使うものです

563
00:38:56,303 --> 00:38:59,540
複数のステップがある
プロセスでは

564
00:38:59,640 --> 00:39:04,177
レスポンスにあるリンクで
次のプロセスに進みます

565
00:38:59,640 --> 00:39:04,177
レスポンスにあるリンクで
次のプロセスに進みます

566
00:39:04,278 --> 00:39:10,250
これならAPIの別の部分でも
コードが使えます

567
00:39:10,350 --> 00:39:13,454
APIが
バージョンアップしても

568
00:39:13,554 --> 00:39:17,357
変更に対応するための
作業量が軽減されます

569
00:39:18,425 --> 00:39:20,794
最後にドキュメントの話です

570
00:39:22,029 --> 00:39:25,866
我々はAPIの一貫性に
注目しています

571
00:39:25,966 --> 00:39:31,305
リソースが何かできる場合
他と同じ方法を採用します

572
00:39:31,505 --> 00:39:36,310
リソースが万能ではないのは
もうお分かりですね

573
00:39:36,410 --> 00:39:39,646
APIは招待なしに
ユーザを作れない

574
00:39:39,813 --> 00:39:44,084
ドキュメントは
リソースができることや

575
00:39:44,184 --> 00:39:47,988
使えるオペレーションや
パラメータなどを教えます

576
00:39:49,256 --> 00:39:53,927
それが一貫した標準REST API
App Store Connect API

577
00:39:54,027 --> 00:39:55,396
感動ものです

578
00:39:55,496 --> 00:40:00,200
このAPIは非常に柔軟に
設計されています

579
00:39:55,496 --> 00:40:00,200
このAPIは非常に柔軟に
設計されています

580
00:40:00,300 --> 00:40:04,204
App Store Connectを
ワークフローに加えれば

581
00:40:04,304 --> 00:40:07,774
自分のやり方で
使いこなせます

582
00:40:07,875 --> 00:40:10,043
是非 試してください

583
00:40:10,144 --> 00:40:12,813
すべてのデベロッパに
この夏 公開されます

584
00:40:13,714 --> 00:40:18,218
質問がある方は
App Store Connect Labへ

585
00:40:18,318 --> 00:40:21,521
スピーチ終了後すぐ
質問に答えます

586
00:40:21,622 --> 00:40:24,157
明日も午後１時から
セッションを開きます

587
00:40:24,324 --> 00:40:28,028
App Store Connectの
最新ニュースもチェックを

588
00:40:28,128 --> 00:40:31,832
APIとApp Store Connectの
情報が得られます

589
00:40:31,932 --> 00:40:36,136
ドキュメントも上げるので
リンクもどうぞ

590
00:40:36,470 --> 00:40:38,305
またセッションで
お会いしましょう

591
00:40:38,405 --> 00:40:40,641
(拍手)