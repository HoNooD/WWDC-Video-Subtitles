
1
00:00:07,107 --> 00:00:15,282
(音楽)

2
00:00:22,523 --> 00:00:29,530
(拍手)

3
00:00:29,763 --> 00:00:33,867
A Tour of UICollectionViewへ
ようこそ

4
00:00:34,268 --> 00:00:36,236
私はスティーブ･ブリーン

5
00:00:36,336 --> 00:00:39,139
フレームワークエンジニアです

6
00:00:39,673 --> 00:00:42,309
本日は 私と同じUIKitチームの

7
00:00:42,409 --> 00:00:46,113
モハメド･ジスロウイと
ツアーを行います

8
00:00:48,815 --> 00:00:51,385
今日は変わったことをします

9
00:00:51,485 --> 00:00:55,889
デザイナーのスペックを基に
アプリケーションを構築し

10
00:00:56,023 --> 00:01:00,027
UICollectionViewの
機能を活用します

11
00:00:56,023 --> 00:01:00,027
UICollectionViewの
機能を活用します

12
00:01:00,127 --> 00:01:04,364
アプリケーションを構築する過程で

13
00:01:04,464 --> 00:01:07,835
様々なトピックに
触れたいと思います

14
00:01:07,935 --> 00:01:11,972
レイアウト 更新
アニメーションを含みます

15
00:01:12,606 --> 00:01:15,709
それでは早速 始めましょう

16
00:01:17,344 --> 00:01:20,614
これはデザイナーのスペックです

17
00:01:20,714 --> 00:01:22,850
フレンドフィードのようです

18
00:01:22,950 --> 00:01:24,852
レイアウトは縦で

19
00:01:24,985 --> 00:01:27,321
分かりやすい作りです

20
00:01:28,689 --> 00:01:30,357
これはいいですね

21
00:01:30,457 --> 00:01:33,327
フレンドフィードのコンテンツが

22
00:01:33,427 --> 00:01:35,762
モザイクで表示されています

23
00:01:36,163 --> 00:01:39,132
これらを使うためのコードを

24
00:01:39,233 --> 00:01:41,502
モハメドが説明します

25
00:01:41,602 --> 00:01:43,003
デザインはどう？

26
00:01:43,170 --> 00:01:45,572
実際に見るのは初めてだけど

27
00:01:45,672 --> 00:01:48,041
CollectionViewが使えると思う

28
00:01:48,141 --> 00:01:49,943
作業するのが楽しそうだ

29
00:01:50,043 --> 00:01:51,512
これはすごくいい

30
00:01:52,312 --> 00:01:57,651
コードを使った説明は
モハメドが後ほど行います

31
00:01:57,751 --> 00:02:01,255
まず CollectionViewを
理解するために

32
00:01:57,751 --> 00:02:01,255
まず CollectionViewを
理解するために

33
00:02:01,355 --> 00:02:03,824
３つのコンセプトを説明します

34
00:02:03,924 --> 00:02:08,127
レイアウト データソース
デリゲートです

35
00:02:10,062 --> 00:02:13,500
まずレイアウトからお話しします

36
00:02:13,600 --> 00:02:18,105
UICollectionViewの
定義を開きます

37
00:02:18,438 --> 00:02:20,274
UITableViewに詳しければ

38
00:02:20,374 --> 00:02:23,777
APIが似ていることに気づきます

39
00:02:24,144 --> 00:02:27,548
デリゲートや
データソースがあります

40
00:02:27,915 --> 00:02:32,819
しかし UICollectionViewの
レイアウトコンセプトは

41
00:02:32,920 --> 00:02:36,056
独特で すごい力を持っています

42
00:02:36,723 --> 00:02:41,128
視覚配置の情報を
コンテンツから抽象化できます

43
00:02:41,228 --> 00:02:43,697
コンテンツ自身とは別にです

44
00:02:44,331 --> 00:02:47,668
レイアウトは
コンテンツの配置場所です

45
00:02:48,936 --> 00:02:51,371
全アイテムが
UICollectionViewの

46
00:02:51,872 --> 00:02:55,409
レイアウト属性で特定されています

47
00:02:55,509 --> 00:02:59,446
境界 センター
フレームなどの属性です

48
00:02:59,546 --> 00:03:04,384
表示アイテムを定義する
プロパティとも言えます

49
00:02:59,546 --> 00:03:04,384
表示アイテムを定義する
プロパティとも言えます

50
00:03:04,484 --> 00:03:09,723
サブクラスを作成して
カスタマイズすることもでき

51
00:03:09,823 --> 00:03:11,925
自分のデザインに組み込めます

52
00:03:12,826 --> 00:03:17,130
ユーザがコンテンツを
スクロールする時―

53
00:03:17,231 --> 00:03:20,234
通常レイアウトは変わりません

54
00:03:20,567 --> 00:03:23,604
しかし レイアウトの表示を

55
00:03:23,704 --> 00:03:25,706
変えたい時もあります

56
00:03:25,906 --> 00:03:30,244
その時には
無効化メカニズムを使用します

57
00:03:31,445 --> 00:03:36,049
レイアウトがコンテンツとは別に
抽象化されるので

58
00:03:36,149 --> 00:03:38,986
別のレイアウトへの移行が簡単です

59
00:03:39,086 --> 00:03:42,956
また移行時に
アニメーション効果が使えます

60
00:03:43,390 --> 00:03:47,127
レイアウトＡとＢの
情報共有は要りません

61
00:03:47,227 --> 00:03:50,864
作りたいレイアウトを
宣言するだけです

62
00:03:51,899 --> 00:03:55,969
CollectionViewLayoutは
抽象クラスなので

63
00:03:56,069 --> 00:03:59,206
直接は使用されません

64
00:03:59,306 --> 00:04:02,943
むしろサブクラスが使用されます

65
00:03:59,306 --> 00:04:02,943
むしろサブクラスが使用されます

66
00:04:03,944 --> 00:04:08,615
今回は UICollectionView
FlowLayoutがあります

67
00:04:08,715 --> 00:04:11,885
CollectionViewを
知っていれば簡単です

68
00:04:13,020 --> 00:04:16,255
UICollectionViewFlowLayoutの
カスタマイズには

69
00:04:16,356 --> 00:04:19,259
色々と方法があります

70
00:04:19,358 --> 00:04:22,196
デリゲートを使うこともできます

71
00:04:22,763 --> 00:04:27,234
しかし
CollectionViewFlowLayoutは

72
00:04:27,334 --> 00:04:32,539
CollectionViewDelegateより
多くのものを特定できます

73
00:04:34,408 --> 00:04:38,679
フローレイアウトは
行配置に基づいているため

74
00:04:38,779 --> 00:04:44,151
様々なデザインに
対応することができます

75
00:04:46,653 --> 00:04:49,656
行配置とはどういう意味か？

76
00:04:49,890 --> 00:04:52,993
行配置システムを説明するには

77
00:04:53,093 --> 00:04:56,330
例を挙げるのが一番でしょう

78
00:04:56,496 --> 00:05:00,234
この縦にスクロールする
CollectionViewで

79
00:04:56,496 --> 00:05:00,234
この縦にスクロールする
CollectionViewで

80
00:05:00,334 --> 00:05:04,404
フローレイアウトの
コンテンツ表示を再現します

81
00:05:04,605 --> 00:05:07,307
まず最初のアイテムを

82
00:05:07,407 --> 00:05:10,177
上端に配置します

83
00:05:10,277 --> 00:05:13,680
そして同じ行にアイテムを並べます

84
00:05:14,081 --> 00:05:16,817
アイテムを並べる行は

85
00:05:16,917 --> 00:05:20,554
スクロール軸に直交し
水平になます

86
00:05:21,255 --> 00:05:24,758
最初の行が一杯になったので

87
00:05:24,858 --> 00:05:27,628
次の行に移動します

88
00:05:27,728 --> 00:05:30,264
コンテンツを更に並べます

89
00:05:31,098 --> 00:05:33,634
最後の行に来ました

90
00:05:33,734 --> 00:05:35,836
コンテンツを全て並べました

91
00:05:36,970 --> 00:05:39,706
水平なレイアウトが分かるように

92
00:05:39,806 --> 00:05:42,009
線を引きました

93
00:05:42,376 --> 00:05:46,947
フローレイアウトを
カスタマイズする定義を見ます

94
00:05:47,948 --> 00:05:50,384
最初はラインスペース

95
00:05:50,851 --> 00:05:55,823
矢印で表示されている
行間のスペースです

96
00:05:56,557 --> 00:05:57,758
同様に

97
00:05:58,892 --> 00:06:03,463
レイアウトに沿った
アイテム間スペースもあります

98
00:05:58,892 --> 00:06:03,463
レイアウトに沿った
アイテム間スペースもあります

99
00:06:03,564 --> 00:06:08,368
両方の最低スペースを定義する
プロパティは２つ

100
00:06:09,403 --> 00:06:11,905
それでは理解を深めるために

101
00:06:12,005 --> 00:06:15,409
90度回転させて
もう１度やってみます

102
00:06:15,576 --> 00:06:17,644
最初は左上です

103
00:06:17,878 --> 00:06:23,116
今度は横スクロールなので
縦にアイテムを並べます

104
00:06:23,784 --> 00:06:28,088
下まで一杯になったら上に戻ります

105
00:06:28,555 --> 00:06:31,191
パターンは分かりましたね

106
00:06:31,425 --> 00:06:33,760
コンテンツを全て入れて

107
00:06:34,027 --> 00:06:36,597
縦のレイアウトができました

108
00:06:36,864 --> 00:06:40,968
この方向での
ラインスペースはこれです

109
00:06:41,802 --> 00:06:44,838
アイテム間スペースはこれ

110
00:06:45,239 --> 00:06:47,574
必ず覚えてください

111
00:06:48,475 --> 00:06:49,910
以上がレイアウトです

112
00:06:51,311 --> 00:06:53,514
今度はデータソースです

113
00:06:54,381 --> 00:06:59,086
TableViewを知っていれば
すぐに使えます

114
00:06:59,353 --> 00:07:01,788
APIが似ているのです

115
00:06:59,353 --> 00:07:01,788
APIが似ているのです

116
00:07:02,089 --> 00:07:06,093
レイアウトは
コンテンツの表示場所で

117
00:07:06,193 --> 00:07:09,263
データソースがコンテンツです

118
00:07:09,897 --> 00:07:14,735
メソッドは３つあり
１つ目はセクションの数です

119
00:07:15,068 --> 00:07:18,438
入力しない場合 値は１になります

120
00:07:19,540 --> 00:07:24,144
２つ目はセクション内の
アイテムの数で

121
00:07:24,244 --> 00:07:27,381
各セクションの
アイテム数が分かります

122
00:07:27,748 --> 00:07:33,220
３つ目はコンテンツを提供する
cellForItemAtIndexPathです

123
00:07:34,188 --> 00:07:35,889
以上がデータソースです

124
00:07:36,623 --> 00:07:38,959
３つ目のトピックはデリゲート

125
00:07:39,059 --> 00:07:42,529
コードに入る前に説明します

126
00:07:42,629 --> 00:07:46,233
デリゲートの使用は
必須ではありません

127
00:07:47,134 --> 00:07:50,237
CollectionViewは
UIScrollViewのサブクラスです

128
00:07:50,337 --> 00:07:53,440
そのため
UIScrollViewが提供する―

129
00:07:53,540 --> 00:07:57,244
同じデリゲートを拡張して使います

130
00:07:57,411 --> 00:08:02,049
スクロールを変える時も
同じデリゲートを使います

131
00:07:57,411 --> 00:08:02,049
スクロールを変える時も
同じデリゲートを使います

132
00:08:02,149 --> 00:08:07,187
また ハイライトや選択の
細かい作業を可能にする―

133
00:08:07,321 --> 00:08:13,193
UICollectionViewDelegate
メソッドとも連携できます

134
00:08:14,461 --> 00:08:18,131
willDisplayItemと
didEndDisplayingItemのAPIが

135
00:08:18,232 --> 00:08:21,034
スクリーンの
新着情報を通知します

136
00:08:23,504 --> 00:08:27,241
UICollectionViewの
コードを説明する前に

137
00:08:27,341 --> 00:08:31,044
お話ししたかったのは
この３点です

138
00:08:31,145 --> 00:08:35,414
ではモハメドと交代して
実際に見てみましょう

139
00:08:35,515 --> 00:08:36,283
モハメド

140
00:08:36,416 --> 00:08:41,221
CollectionViewFlowLayoutを
使用するのに

141
00:08:41,321 --> 00:08:44,892
最初の縦のレイアウトは最適です

142
00:08:44,992 --> 00:08:47,861
そこで全てを行えるので

143
00:08:47,961 --> 00:08:52,466
UICollectionViewを
使うのに向いています

144
00:08:54,768 --> 00:08:59,540
更にカスタマイズするために
フローレイアウトではなく

145
00:08:59,640 --> 00:09:05,012
CollectionViewFlowLayoutの
サブクラスを見ます

146
00:08:59,640 --> 00:09:05,012
CollectionViewFlowLayoutの
サブクラスを見ます

147
00:09:05,112 --> 00:09:09,816
ColumnFlowLayoutクラスの
インスタンスを

148
00:09:09,917 --> 00:09:13,554
作成することから初めましょう

149
00:09:13,654 --> 00:09:17,791
そのインスタンスを使い
CollectionViewを作り

150
00:09:18,258 --> 00:09:21,195
ビュープロパティを設定します

151
00:09:21,295 --> 00:09:24,264
autoresizingMaskや
backgroundColorです

152
00:09:24,364 --> 00:09:28,335
ScrollViewプロパティも設定します

153
00:09:28,435 --> 00:09:32,506
これで希望どおりに表示されます

154
00:09:33,307 --> 00:09:38,645
ビュー階層に
CollectionViewを入れた後に

155
00:09:38,745 --> 00:09:43,951
一意識別子を使い
PersonCellクラスを登録します

156
00:09:44,985 --> 00:09:49,289
View Controllerを
データソースとして設定

157
00:09:49,389 --> 00:09:53,727
表示するセルの数や
データの種類などの情報を

158
00:09:53,827 --> 00:09:56,497
これで提供できます

159
00:09:57,631 --> 00:10:02,436
デリゲートとしても設定して
セル選択を可能にします

160
00:09:57,631 --> 00:10:02,436
デリゲートとしても設定して
セル選択を可能にします

161
00:10:03,170 --> 00:10:07,574
そして ２つのプロトコルに
準拠させます

162
00:10:07,774 --> 00:10:11,411
まずデータソースに準拠させます

163
00:10:12,045 --> 00:10:14,948
２つのメソッドを実装します

164
00:10:15,048 --> 00:10:20,020
１つ目は
セクション内のアイテムの数です

165
00:10:20,387 --> 00:10:25,292
people配列にある
人数やアイテムの数を返して

166
00:10:25,392 --> 00:10:28,462
データモデルオブジェクトを
表示させます

167
00:10:28,562 --> 00:10:31,899
２つ目に実装するメソッドは

168
00:10:31,999 --> 00:10:35,269
CellForItemAtIndexPathです

169
00:10:35,369 --> 00:10:38,839
一意識別子でCollectionViewから
セルを取り除き

170
00:10:39,606 --> 00:10:43,877
people配列のPersonオブジェクトを
セルに渡します

171
00:10:43,977 --> 00:10:49,049
データを実際に表示させて
セルを戻します

172
00:10:50,350 --> 00:10:53,987
最後に
選択をハンドルできるように

173
00:10:54,087 --> 00:10:58,892
デリゲートプロトコルの
任意メソッドを実装します

174
00:10:59,226 --> 00:11:03,230
まず
DidSelectItemAtIndexPathを追加

175
00:10:59,226 --> 00:11:03,230
まず
DidSelectItemAtIndexPathを追加

176
00:11:03,530 --> 00:11:07,668
feedViewControllerを
インスタンス化し

177
00:11:07,768 --> 00:11:11,038
２つ目のスクリーンを作ります

178
00:11:11,138 --> 00:11:13,740
表示する画像が誰か分かるように

179
00:11:13,841 --> 00:11:16,944
Personオブジェクトを渡します

180
00:11:17,044 --> 00:11:20,881
navControllerに置きます

181
00:11:21,181 --> 00:11:23,951
ではシミュレータで

182
00:11:24,051 --> 00:11:27,454
実際にやってみましょう

183
00:11:29,790 --> 00:11:30,424
始めます

184
00:11:30,524 --> 00:11:33,393
(拍手 喝采)

185
00:11:34,061 --> 00:11:38,065
これはCollectionViewです

186
00:11:38,165 --> 00:11:40,601
いくつかセルが見えますが

187
00:11:40,701 --> 00:11:43,403
表示サイズが正しくありません

188
00:11:43,504 --> 00:11:47,875
そこでカスタマイズしたいと
思います

189
00:11:47,975 --> 00:11:51,044
ではXcodeに戻りましょう

190
00:11:51,144 --> 00:11:54,815
そして 列のクラスを

191
00:11:55,482 --> 00:11:57,251
開きます

192
00:11:57,885 --> 00:12:02,356
先程の
ColumnFlowLayoutクラスです

193
00:11:57,885 --> 00:12:02,356
先程の
ColumnFlowLayoutクラスです

194
00:12:03,023 --> 00:12:03,824
そして

195
00:12:05,726 --> 00:12:07,961
必要な作業をお見せします

196
00:12:08,061 --> 00:12:13,333
既にprepareメソッドを
スタブに置き換えています

197
00:12:13,433 --> 00:12:16,603
UICollectionViewの
prepareメソッドが

198
00:12:16,703 --> 00:12:18,906
レイアウトの無効化で呼ばれます

199
00:12:19,039 --> 00:12:22,009
UICollectionViewFlowLayoutでは

200
00:12:22,576 --> 00:12:27,247
サイズの境界が変わると
レイアウトが無効化されます

201
00:12:27,347 --> 00:12:32,853
アプリケーションの向きや
サイズが変わった時です

202
00:12:33,887 --> 00:12:38,125
ですからCollectionViewの
サイズを考慮した

203
00:12:38,225 --> 00:12:41,295
カスタマイズを行うのに最適です

204
00:12:41,395 --> 00:12:45,165
セルに
CollectionViewの幅に関する

205
00:12:45,265 --> 00:12:47,067
機能を持たせます

206
00:12:47,367 --> 00:12:51,471
CollectionViewに
アイテムサイズのプロパティで

207
00:12:51,572 --> 00:12:54,308
希望サイズを知らせます

208
00:12:54,441 --> 00:12:56,743
実際にやってみます

209
00:12:57,377 --> 00:13:01,114
アイテムのサイズを
CGサイズにして

210
00:12:57,377 --> 00:13:01,114
アイテムのサイズを
CGサイズにして

211
00:13:01,215 --> 00:13:05,752
CollectionViewの境界幅に
合わせます

212
00:13:05,853 --> 00:13:08,088
レイアウトのマージンに合わせ

213
00:13:08,355 --> 00:13:10,724
高さを70ポイントにします

214
00:13:10,824 --> 00:13:13,227
これでデザインに合います

215
00:13:13,994 --> 00:13:19,099
ついでに見た目を
もう少し良くしましょう

216
00:13:19,199 --> 00:13:23,036
アイテム間スペースに合うように

217
00:13:23,136 --> 00:13:25,572
セクションを挿入します

218
00:13:25,806 --> 00:13:30,777
CollectionViewの
セーフエリアに全て収まるように

219
00:13:30,878 --> 00:13:35,315
挿入参照プロパティを
セーフエリアから設定します

220
00:13:35,549 --> 00:13:39,119
シミュレータでレイアウトが

221
00:13:39,219 --> 00:13:41,822
どう見えるか確認します

222
00:13:43,857 --> 00:13:46,860
スペックどおり表示されています

223
00:13:46,960 --> 00:13:49,029
デザイナーも満足でしょう

224
00:13:50,731 --> 00:13:55,035
画面を横にすると
セルのサイズが変更されます

225
00:13:55,135 --> 00:13:58,605
無効化コードが呼び出されたのです

226
00:13:59,673 --> 00:14:04,311
しかし
もっと良いレイアウトにできると

227
00:13:59,673 --> 00:14:04,311
しかし
もっと良いレイアウトにできると

228
00:14:04,411 --> 00:14:07,514
考える人もいると思います

229
00:14:08,382 --> 00:14:11,818
まだスペースが余っているので

230
00:14:11,919 --> 00:14:15,122
複数の列を表示させてみましょう

231
00:14:15,222 --> 00:14:18,225
フローレイアウトなら
簡単にできます

232
00:14:18,325 --> 00:14:22,963
スティーブが説明したように
フローレイアウトは

233
00:14:23,197 --> 00:14:27,267
１行にできるだけ多くの
アイテムを入れます

234
00:14:27,367 --> 00:14:30,404
そして 入らないと行を変えます

235
00:14:30,504 --> 00:14:35,542
つまり アイテムのサイズを
変更すると

236
00:14:35,809 --> 00:14:39,179
複数の列が作成されるのです

237
00:14:39,413 --> 00:14:43,083
Xcodeのレイアウトに戻り

238
00:14:43,784 --> 00:14:47,821
アイテムサイズの計算を
変更します

239
00:14:47,921 --> 00:14:51,658
サイズに合わせる設定を消し

240
00:14:51,758 --> 00:14:55,929
代わりに少し計算式を入れます

241
00:14:56,230 --> 00:15:00,367
まず 使用可能な幅は
前回と同じです

242
00:14:56,230 --> 00:15:00,367
まず 使用可能な幅は
前回と同じです

243
00:15:00,467 --> 00:15:03,437
これはマージンによる
境界のインセットです

244
00:15:03,637 --> 00:15:07,674
列の最低幅を決める
任意の定義は

245
00:15:07,774 --> 00:15:11,545
300ポイントになります

246
00:15:12,980 --> 00:15:17,651
この決められたスペースに
最大 何列まで入るかを

247
00:15:17,751 --> 00:15:20,787
両方の値を使って計算します

248
00:15:20,888 --> 00:15:23,991
求めた数値で幅を割ると

249
00:15:24,324 --> 00:15:26,426
最適なセルの幅がでます

250
00:15:26,493 --> 00:15:30,164
300ポイント以上かもしれません

251
00:15:30,564 --> 00:15:34,334
それをCGSizeに伝えます

252
00:15:34,802 --> 00:15:38,405
シミュレータに再び戻って

253
00:15:38,505 --> 00:15:41,108
レイアウトの更新を確認します

254
00:15:42,509 --> 00:15:45,913
前と同じように表示されています

255
00:15:46,680 --> 00:15:49,750
画面を横にして表示すると

256
00:15:49,850 --> 00:15:52,653
列が左右に並んでいます

257
00:15:54,621 --> 00:15:55,456
どうだい？

258
00:15:55,556 --> 00:15:59,927
簡単に調整できる良いレイアウトだ

259
00:16:00,427 --> 00:16:01,828
次のデザインは？

260
00:16:01,929 --> 00:16:04,698
フレンドリストは終わりにして

261
00:16:04,798 --> 00:16:08,135
モザイクのレイアウトを作ります

262
00:16:08,235 --> 00:16:10,070
いい考えだね

263
00:16:10,170 --> 00:16:13,774
スライドに戻って説明をしましょう

264
00:16:17,044 --> 00:16:22,282
このレイアウトを見て
何ができるか考えます

265
00:16:22,382 --> 00:16:26,019
私はフローレイアウトを
使う傾向にあります

266
00:16:26,119 --> 00:16:28,255
まず使ってみましょう

267
00:16:29,189 --> 00:16:34,261
このデザインに
フローレイアウトが適切か考えます

268
00:16:34,895 --> 00:16:40,133
３枚の写真が並ぶ
この箇所を拡大してみます

269
00:16:40,234 --> 00:16:45,105
このインスタンスには
左に大きな写真があり

270
00:16:45,205 --> 00:16:48,242
右には写真が縦に並んでいます

271
00:16:48,342 --> 00:16:52,913
フローレイアウトでは
左にアイテムを置いた後に

272
00:16:53,013 --> 00:16:56,483
次のアイテムを
空いている場所に置きます

273
00:16:56,583 --> 00:16:58,485
空きがなければ次の行です

274
00:16:58,952 --> 00:17:01,188
縦に並ぶ写真を改善します

275
00:16:58,952 --> 00:17:01,188
縦に並ぶ写真を改善します

276
00:17:01,288 --> 00:17:04,858
このレイアウトは
行配置に基づかないため

277
00:17:04,958 --> 00:17:09,363
フローレイアウトを
使うことはできません

278
00:17:09,695 --> 00:17:13,567
しかし試しに一度 使ってみます

279
00:17:15,301 --> 00:17:19,039
カスタムレイアウトを
作成しましょう

280
00:17:19,540 --> 00:17:24,578
難しくありません
４つの基本メソッドに

281
00:17:24,678 --> 00:17:28,816
もう１つメソッドを
追加するだけです

282
00:17:29,917 --> 00:17:32,052
４つのメソッドを説明します

283
00:17:32,686 --> 00:17:36,657
１つ目はCollectionViewの
コンテンツサイズ

284
00:17:37,224 --> 00:17:41,395
CollectionViewは
UIScrollViewのサブクラスです

285
00:17:41,495 --> 00:17:43,697
UIScrollViewの特徴は

286
00:17:43,797 --> 00:17:47,067
広いコンテンツ領域が
可視である点です

287
00:17:47,267 --> 00:17:51,772
そのため領域内で
快適にコンテンツを動かせます

288
00:17:52,105 --> 00:17:56,944
ScrollViewに伝えるべき
コンテンツサイズを

289
00:17:57,177 --> 00:18:00,214
どうやって求めるのでしょう

290
00:17:57,177 --> 00:18:00,214
どうやって求めるのでしょう

291
00:18:00,614 --> 00:18:03,550
コンテンツを含む長方形があります

292
00:18:03,650 --> 00:18:08,255
その長方形の領域の
サイズを出すのです

293
00:18:09,289 --> 00:18:12,726
以上がコンテンツサイズです

294
00:18:13,460 --> 00:18:18,432
次の２つのメソッドは
レイアウト属性を提供します

295
00:18:19,299 --> 00:18:22,703
１つ目はlayoutAttributesFor
ElementsInRectです

296
00:18:23,103 --> 00:18:27,608
これはCollectionViewが
画面に何を表示するか

297
00:18:27,708 --> 00:18:31,378
確認する時に呼び出します

298
00:18:31,745 --> 00:18:34,515
このクエリは幾何学領域からです

299
00:18:35,916 --> 00:18:40,954
もう１つのAPIは
特定のアイテムを探す―

300
00:18:41,054 --> 00:18:44,958
LayoutAttributes
ForItemAtIndexPathです

301
00:18:45,792 --> 00:18:48,595
後ほどモハメドが説明しますが

302
00:18:48,695 --> 00:18:53,267
この２つのAPIでは
処理能力がカギとなります

303
00:18:57,070 --> 00:19:01,041
４つ目のカスタムレイアウトの
サブクラスは

304
00:18:57,070 --> 00:19:01,041
４つ目のカスタムレイアウトの
サブクラスは

305
00:19:01,141 --> 00:19:04,311
prepareメソッドです

306
00:19:04,411 --> 00:19:06,547
これはレイアウトが

307
00:19:06,647 --> 00:19:09,783
無効化される度に呼び出されます

308
00:19:09,917 --> 00:19:14,421
キャッシュ保存したい
レイアウト属性や

309
00:19:14,721 --> 00:19:19,526
コンテンツのサイズを
計算する良い機会です

310
00:19:23,363 --> 00:19:26,867
追加のAPIについて話します

311
00:19:26,967 --> 00:19:30,170
shouldInvalidateLayout
(forBoundsChange:)です

312
00:19:30,704 --> 00:19:34,908
これは境界が
変更される度に呼び出されます

313
00:19:35,008 --> 00:19:38,445
これもUIScrollViewの
サブクラスです

314
00:19:38,545 --> 00:19:41,982
境界の変更とは何を指すのか？

315
00:19:42,082 --> 00:19:46,487
スクロール中に原点が変わったり

316
00:19:46,587 --> 00:19:51,492
アプリケーションと共に
サイズが変わったりします

317
00:19:51,592 --> 00:19:54,528
そのため スクロール時や

318
00:19:55,028 --> 00:19:57,998
絵文字の使用中に呼び出されます

319
00:19:58,098 --> 00:20:01,301
うまく設定する必要があります

320
00:19:58,098 --> 00:20:01,301
うまく設定する必要があります

321
00:20:01,401 --> 00:20:07,374
UICollectionViewLayoutは
デフォルトでfalseを返します

322
00:20:07,841 --> 00:20:11,245
変更したければ ここで行います

323
00:20:11,845 --> 00:20:15,782
これに対して
UICollectionViewFlowLayoutは

324
00:20:15,883 --> 00:20:18,786
原点が変わるとfalseを返します

325
00:20:18,886 --> 00:20:23,223
スクロール時は
デフォルトに任せます

326
00:20:23,323 --> 00:20:28,328
機器が回転してアプリケーションの
サイズが変わると

327
00:20:28,428 --> 00:20:29,897
trueを返します

328
00:20:30,497 --> 00:20:34,167
例外は
フローティングヘッダとフッタで

329
00:20:34,268 --> 00:20:37,304
スクロール中に再計算が必要です

330
00:20:37,404 --> 00:20:40,541
これはカスタム無効化で行います

331
00:20:40,741 --> 00:20:43,844
理論はここまでにして

332
00:20:44,311 --> 00:20:46,180
実際に見てみましょう

333
00:20:46,580 --> 00:20:49,416
では このレイアウトのコードを

334
00:20:49,516 --> 00:20:52,753
モハメドに説明してもらいます

335
00:20:54,354 --> 00:20:56,089
では始めましょう

336
00:20:56,190 --> 00:20:59,293
このレイアウトで使用する

337
00:20:59,393 --> 00:21:02,196
サブクラスを入力しました

338
00:20:59,393 --> 00:21:02,196
サブクラスを入力しました

339
00:21:02,296 --> 00:21:06,133
UICollectionViewLayoutの直下で

340
00:21:06,233 --> 00:21:09,536
UICollectionViewFlowLayoutの
下ではありません

341
00:21:09,636 --> 00:21:13,207
その理由は
スティーブが説明しました

342
00:21:13,307 --> 00:21:16,844
UICollectionViewFlowLayoutは
カスタムモザイクを

343
00:21:16,944 --> 00:21:19,813
サポートしないからです

344
00:21:20,814 --> 00:21:24,818
まずインスタンス変数を設定して

345
00:21:24,918 --> 00:21:29,790
後で重要な情報を
参照できるようにします

346
00:21:30,624 --> 00:21:36,363
１つ目は
コンテンツ境界のCGRectです

347
00:21:36,463 --> 00:21:40,734
CollectionView内の
アイテムの境界を示します

348
00:21:41,702 --> 00:21:46,273
２つ目は
キャッシュ済みの属性配列です

349
00:21:46,373 --> 00:21:50,277
後でレイアウト属性を
参照することができます

350
00:21:51,745 --> 00:21:56,316
ではレイアウトに
prepareメソッドを実装します

351
00:21:57,050 --> 00:22:01,088
レイアウト作業に
prepareが使われるのは

352
00:21:57,050 --> 00:22:01,088
レイアウト作業に
prepareが使われるのは

353
00:22:01,188 --> 00:22:04,458
無効化の度に
呼び出されるからです

354
00:22:04,591 --> 00:22:08,295
レイアウトを
ここに作れば終わりです

355
00:22:08,395 --> 00:22:11,765
もっと頻繁に呼ばれる
メソッドのように

356
00:22:11,865 --> 00:22:14,434
難しい作業や計算は要りません

357
00:22:18,472 --> 00:22:23,844
まずキャッシュ属性と
コンテンツ境界をリセットして

358
00:22:23,944 --> 00:22:28,649
古い無効化情報は
全て消去します

359
00:22:29,516 --> 00:22:34,454
次にCollectionViewの
全てのアイテムに対し

360
00:22:35,355 --> 00:22:38,325
属性を設定します

361
00:22:38,425 --> 00:22:42,496
レイアウトごとに
必要なものが違うので

362
00:22:42,596 --> 00:22:44,264
詳細は省きます

363
00:22:44,364 --> 00:22:49,436
ここでサイズ 位置
変化などを計算して

364
00:22:49,536 --> 00:22:53,407
セルを自分のデザインに
合わせるのです

365
00:22:53,674 --> 00:22:58,011
属性を設定したら
重要な作業を行います

366
00:22:58,111 --> 00:23:01,415
後で使うため
属性をキャッシュ保存し

367
00:22:58,111 --> 00:23:01,415
後で使うため
属性をキャッシュ保存し

368
00:23:01,515 --> 00:23:03,951
キャッシュ属性配列に置きます

369
00:23:05,219 --> 00:23:09,890
次にコンテンツ境界矩形を使い
フレームを統合し

370
00:23:10,057 --> 00:23:12,626
コンテンツ境界を最新に保ちます

371
00:23:14,127 --> 00:23:17,931
prepareメソッドは作動したので

372
00:23:18,131 --> 00:23:22,035
レイアウトの
残りのメソッドを実装します

373
00:23:24,338 --> 00:23:27,508
まずCollectionViewの
コンテンツサイズです

374
00:23:27,608 --> 00:23:30,177
prepareで設定しているので

375
00:23:30,277 --> 00:23:33,313
コンテンツ境界を
サイズとして返します

376
00:23:35,449 --> 00:23:38,585
次はshouldInvalidateLayout
(forBoundsChange:)です

377
00:23:39,453 --> 00:23:43,257
スクロール中に
無効化する必要のある要素は

378
00:23:43,357 --> 00:23:45,659
レイアウトに含まれていません

379
00:23:45,759 --> 00:23:49,897
フローティングヘッダもフッタも
ありません

380
00:23:49,997 --> 00:23:54,468
境界のサイズが変更された時のみ
無効化します

381
00:23:54,568 --> 00:23:57,871
新しい境界のサイズが
現在のサイズと

382
00:23:57,971 --> 00:24:02,242
異なる場合にtrueを返します

383
00:23:57,971 --> 00:24:02,242
異なる場合にtrueを返します

384
00:24:04,111 --> 00:24:07,414
その後layoutAttributesForItem
AtIndexPathを実装します

385
00:24:07,514 --> 00:24:11,518
準備はprepareメソッドで
行っています

386
00:24:11,618 --> 00:24:15,656
そのため
要求したIndexPathに合う属性を

387
00:24:15,756 --> 00:24:18,392
配列から選ぶだけです

388
00:24:19,726 --> 00:24:21,762
最後に実装するのは

389
00:24:22,196 --> 00:24:24,698
layoutAttributesForElements
InRectです

390
00:24:25,232 --> 00:24:30,137
このメソッドで呼び出された
矩形の範囲は

391
00:24:30,237 --> 00:24:32,806
CollectionViewより大きい
こともあります

392
00:24:32,906 --> 00:24:35,776
CollectionViewは

393
00:24:35,876 --> 00:24:38,312
領域に合う属性だけを要求します

394
00:24:38,545 --> 00:24:44,618
CollectionViewの矩形内に
表示されるアイテムに

395
00:24:44,718 --> 00:24:49,323
対応する属性を含む配列を
返す必要があります

396
00:24:50,557 --> 00:24:53,260
これは簡単に行えます

397
00:24:53,360 --> 00:24:56,463
キャッシュ保存された属性配列を

398
00:24:56,563 --> 00:25:00,000
属性フレームでフィルタにかけます

399
00:25:00,100 --> 00:25:02,870
属性フレームが矩形と交われば

400
00:25:02,970 --> 00:25:06,273
これを返すことができます

401
00:25:06,473 --> 00:25:12,179
シミュレータで
レイアウトを確認してみましょう

402
00:25:13,180 --> 00:25:16,950
フィードを１つ選んで
レイアウトを出します

403
00:25:17,050 --> 00:25:21,755
画像が奇麗に
モザイク配置されています

404
00:25:22,456 --> 00:25:26,427
横にすると
セルのサイズが変更されます

405
00:25:26,527 --> 00:25:29,830
全てが適切に更新されています

406
00:25:35,502 --> 00:25:39,239
しかし スクロール機能が
いま一つです

407
00:25:39,339 --> 00:25:41,241
すごく悪いですね

408
00:25:41,708 --> 00:25:44,177
ご存じかもしれませんが

409
00:25:44,278 --> 00:25:47,815
コードに戻り問題を確認しましょう

410
00:25:49,483 --> 00:25:53,086
矩形内のレイアウト属性を
見てみます

411
00:25:53,187 --> 00:25:57,257
これはスクロール中に
よく呼び出されます

412
00:25:58,926 --> 00:26:03,464
この関数は配列全体を
フィルタにかけます

413
00:25:58,926 --> 00:26:03,464
この関数は配列全体を
フィルタにかけます

414
00:26:03,564 --> 00:26:08,202
そのためアイテムが増えると
作業が大変になります

415
00:26:08,302 --> 00:26:12,840
写真が増えると
スクロールの速度が落ちるのです

416
00:26:14,541 --> 00:26:20,414
こういう時は 一段階前に戻り
レイアウトの性質と

417
00:26:20,514 --> 00:26:23,817
最適化について考えてください

418
00:26:24,184 --> 00:26:26,487
レイアウトの要求は何か？

419
00:26:27,688 --> 00:26:30,824
それは アプリケーションのセルが

420
00:26:30,924 --> 00:26:33,260
上下 左右に並ぶことです

421
00:26:33,427 --> 00:26:37,698
つまり属性は既に
キャッシュ属性配列内で

422
00:26:37,798 --> 00:26:42,135
フレームの最低Ｙ値で
並べられているのです

423
00:26:43,704 --> 00:26:45,172
配列はソート済みです

424
00:26:45,272 --> 00:26:49,042
従って フィルタではなく
２分探索を使うと

425
00:26:49,142 --> 00:26:52,980
検索を迅速に行うことができます

426
00:26:53,614 --> 00:26:56,417
まずスピードの遅い実装を

427
00:26:57,151 --> 00:26:59,319
削除しましょう

428
00:26:59,486 --> 00:27:02,322
そして 速いものと入れ替えます

429
00:26:59,486 --> 00:27:02,322
そして 速いものと入れ替えます

430
00:27:04,892 --> 00:27:08,061
ステップごとに説明をします

431
00:27:08,161 --> 00:27:12,900
まず初めに
準備した２分探索機能を

432
00:27:13,367 --> 00:27:16,236
使うことから始めます

433
00:27:16,336 --> 00:27:21,275
配列と矩形内の
様々なインデックスを使います

434
00:27:22,476 --> 00:27:27,448
属性がフレームを持ち
矩形内にある場合

435
00:27:27,548 --> 00:27:31,285
配列内で属性を
インデックスとして返します

436
00:27:32,953 --> 00:27:36,056
このインデックスを使って
矩形のための

437
00:27:36,156 --> 00:27:39,760
残りの属性を
設定することができます

438
00:27:39,893 --> 00:27:44,498
配列内でループさせて
属性を選んでいき

439
00:27:44,598 --> 00:27:49,703
矩形外の属性を
見つけるまで続けます

440
00:27:49,803 --> 00:27:51,772
この方法は迅速です

441
00:27:51,872 --> 00:27:54,441
配列にある何千ものアイテムを

442
00:27:54,641 --> 00:27:58,278
何千回も検索しなくていいのです

443
00:27:58,479 --> 00:28:01,582
スクロールのアルゴリズムを

444
00:27:58,479 --> 00:28:01,582
スクロールのアルゴリズムを

445
00:28:01,682 --> 00:28:04,618
シミュレータで確認してみます

446
00:28:07,221 --> 00:28:11,592
スクロールすると
速いのが分かります

447
00:28:12,526 --> 00:28:13,594
どうだいスティーブ？

448
00:28:13,727 --> 00:28:17,030
いいね
２つのレイアウトが完成した

449
00:28:17,130 --> 00:28:18,232
次は何？

450
00:28:18,665 --> 00:28:22,202
残りはフレンドリスト用の

451
00:28:22,302 --> 00:28:24,705
更新アニメーションです

452
00:28:24,805 --> 00:28:29,443
“すごくクールな
更新アニメーション”を

453
00:28:29,543 --> 00:28:32,913
スライドで見てみましょう

454
00:28:33,514 --> 00:28:36,783
アニメーションのビデオを

455
00:28:36,884 --> 00:28:39,453
実際に見てみます

456
00:28:40,454 --> 00:28:43,357
画面上の最後のアイテムが

457
00:28:43,457 --> 00:28:47,261
誰かが写真を投稿したので
更新されました

458
00:28:47,361 --> 00:28:51,398
そして３番目の
サミアのアイテムは

459
00:28:51,498 --> 00:28:53,767
画面から消されました

460
00:28:53,867 --> 00:28:56,503
今３つのことが行われました

461
00:28:56,603 --> 00:28:59,840
リロード 移動 削除です

462
00:29:00,407 --> 00:29:02,643
モハメドがシミュレータで

463
00:29:02,743 --> 00:29:05,412
やり方を説明します

464
00:29:06,113 --> 00:29:07,281
では始めます

465
00:29:08,515 --> 00:29:13,620
複数の更新アニメーションを
同時に行っています

466
00:29:13,954 --> 00:29:19,092
UICollectionViewと
UITableViewが提供する―

467
00:29:19,193 --> 00:29:21,728
performBatchUpdatesのAPIが
使えます

468
00:29:21,828 --> 00:29:25,866
これで更新とアニメーションが

469
00:29:25,966 --> 00:29:30,137
同時に実行されるようにします

470
00:29:30,470 --> 00:29:35,676
performBatchUpdatesを
呼び出します

471
00:29:35,776 --> 00:29:38,278
データソースとCollectionViewの

472
00:29:38,378 --> 00:29:41,048
両方の更新をここで行います

473
00:29:41,148 --> 00:29:45,819
これは更新が矛盾を生まないように

474
00:29:45,919 --> 00:29:50,190
同期させる最善の方法と言えます

475
00:29:50,757 --> 00:29:54,962
初めに データソースの
最後のアイテムを

476
00:29:55,062 --> 00:29:57,464
更新したいと思います

477
00:29:57,564 --> 00:30:02,102
下から２番目を削除し
最後を１番上に持ってきて

478
00:29:57,564 --> 00:30:02,102
下から２番目を削除し
最後を１番上に持ってきて

479
00:30:02,202 --> 00:30:06,406
アニメーションを表示させます

480
00:30:06,673 --> 00:30:11,178
シミュレータで
レイアウトを確認します

481
00:30:11,278 --> 00:30:15,682
更新コードを
右上の更新ボタンで送りました

482
00:30:17,985 --> 00:30:18,919
おかしいな

483
00:30:19,086 --> 00:30:20,053
どうした？

484
00:30:22,523 --> 00:30:23,557
何てことだ

485
00:30:24,691 --> 00:30:25,325
どうした

486
00:30:25,425 --> 00:30:29,062
私もiOSのコードで
同じ画面を見たよ

487
00:30:29,797 --> 00:30:31,398
ステージで起こるなんて

488
00:30:34,468 --> 00:30:38,639
時間があまりないので
データをリロードして

489
00:30:38,739 --> 00:30:42,376
アニメーションをやり直さないか？

490
00:30:42,476 --> 00:30:43,443
本気で？

491
00:30:43,544 --> 00:30:48,115
(拍手)

492
00:30:48,215 --> 00:30:52,486
でも“すごくクールな
更新アニメーション”を失い

493
00:30:52,586 --> 00:30:55,789
ユーザの期待に応えられない

494
00:30:56,557 --> 00:30:59,259
確かにそのとおりだ

495
00:30:59,359 --> 00:31:00,527
分かってくれた

496
00:30:59,359 --> 00:31:00,527
分かってくれた

497
00:31:00,627 --> 00:31:02,596
ではスライドに戻り

498
00:31:02,996 --> 00:31:07,100
アニメーションを
救えるか見てみましょう

499
00:31:07,734 --> 00:31:08,802
これは前に見ました

500
00:31:08,902 --> 00:31:09,970
では

501
00:31:10,270 --> 00:31:15,175
このデバッグ例外が
示すものを見てみます

502
00:31:15,475 --> 00:31:18,579
indexPathの0-3から

503
00:31:18,679 --> 00:31:21,582
削除と移動を試みました

504
00:31:21,682 --> 00:31:25,519
４番目のアイテムを
リロードして移動しました

505
00:31:26,487 --> 00:31:29,823
４番でなく
３番目の0-2を削除したはず

506
00:31:30,057 --> 00:31:31,091
そうだね

507
00:31:31,191 --> 00:31:33,560
何かおかしいな

508
00:31:33,660 --> 00:31:38,799
まずperformBatchUpdatesの
APIを確認して

509
00:31:38,899 --> 00:31:42,202
ハイレベルな原則について
お話しします

510
00:31:42,302 --> 00:31:45,105
このAPIを使用する目的は

511
00:31:45,205 --> 00:31:49,710
同時に複数の更新を行うことです

512
00:31:49,810 --> 00:31:54,181
そして全てに
アニメーションを演出させます

513
00:31:54,281 --> 00:31:58,619
CollectionViewの更新と共に

514
00:31:58,719 --> 00:32:02,923
データソースの更新を
必ず行ってください

515
00:31:58,719 --> 00:32:02,923
データソースの更新を
必ず行ってください

516
00:32:03,190 --> 00:32:07,628
CollectionViewに関することは

517
00:32:07,728 --> 00:32:10,697
TableViewにも当てはまります

518
00:32:11,398 --> 00:32:14,268
では見てみましょう

519
00:32:14,368 --> 00:32:18,038
CollectionViewの更新では

520
00:32:18,138 --> 00:32:23,043
挿入 移動 削除を行う順番は
重要ではありません

521
00:32:23,544 --> 00:32:27,347
しかしデータソースの更新で

522
00:32:27,448 --> 00:32:31,752
データソースの構成を変える時は
順序が重要です

523
00:32:32,352 --> 00:32:35,556
分かりやすいように例を挙げます

524
00:32:35,656 --> 00:32:39,660
３つの要素を含む
配列が２つあります

525
00:32:39,960 --> 00:32:43,931
理解しやすいように
削除と挿入を行います

526
00:32:44,031 --> 00:32:47,201
１回目は削除を最初に行い

527
00:32:47,301 --> 00:32:50,304
２回目は削除を２番目に行います

528
00:32:50,671 --> 00:32:54,041
こうすると感覚的に理解できます

529
00:32:54,308 --> 00:32:56,477
１番目のアイテムを削除し

530
00:32:57,177 --> 00:33:00,280
インデックス１に挿入します

531
00:32:57,177 --> 00:33:00,280
インデックス１に挿入します

532
00:33:01,148 --> 00:33:06,120
２つ目は逆に
挿入をした後に 削除します

533
00:33:06,520 --> 00:33:11,258
違う結果が出るので
悪い例だと思うでしょう

534
00:33:12,326 --> 00:33:15,929
これをCollectionViewの更新と
比較します

535
00:33:16,029 --> 00:33:20,701
BatchUpdates経由の
CollectionViewの更新が２つあり

536
00:33:20,834 --> 00:33:24,304
データソースの更新は
していません

537
00:33:24,872 --> 00:33:27,007
１つは挿入した後に削除

538
00:33:27,107 --> 00:33:30,644
もう１つは
削除した後に挿入です

539
00:33:30,744 --> 00:33:32,813
結果は全く同じになります

540
00:33:33,347 --> 00:33:37,751
エンジニアとしては
その理由が気になります

541
00:33:38,886 --> 00:33:42,956
なぜCollectionViewでは
更新の順番が重要でなく

542
00:33:43,056 --> 00:33:44,892
データソースでは重要なのか

543
00:33:45,359 --> 00:33:47,795
ステップごとに見てみます

544
00:33:47,895 --> 00:33:49,696
１番目の削除は

545
00:33:50,030 --> 00:33:53,700
indexPathで降順に処理されます

546
00:33:54,268 --> 00:33:57,070
indexPathを説明します

547
00:33:57,171 --> 00:33:59,773
BatchUpdatesが始まる前は

548
00:33:59,873 --> 00:34:03,343
データソースは更新前の状態です

549
00:33:59,873 --> 00:34:03,343
データソースは更新前の状態です

550
00:34:03,944 --> 00:34:08,415
終わると更新後の状態に移行します

551
00:34:08,514 --> 00:34:13,687
indexPathは
削除に対し常に更新前の状態を

552
00:34:14,621 --> 00:34:16,156
参照します

553
00:34:16,255 --> 00:34:20,694
一方 挿入は
indexPathで昇順に処理されます

554
00:34:20,793 --> 00:34:24,231
よってindexPathは挿入に対して

555
00:34:24,331 --> 00:34:28,668
常に更新後の状態を参照します

556
00:34:29,536 --> 00:34:34,741
移動はこの２つを混ぜたもので
indexPathからの更新前と

557
00:34:34,842 --> 00:34:39,746
indexPathへの
更新後の状態があります

558
00:34:41,148 --> 00:34:44,217
リロードはスーパーコマンドで

559
00:34:44,318 --> 00:34:48,355
削除と挿入に
分解することができます

560
00:34:49,056 --> 00:34:52,326
リロードのindexPathは

561
00:34:52,426 --> 00:34:55,462
更新前の状態を示しています

562
00:34:56,063 --> 00:35:00,033
リロードの仕組みを理解すると

563
00:34:56,063 --> 00:35:00,033
リロードの仕組みを理解すると

564
00:35:00,134 --> 00:35:04,938
今回のアプリケーションの
エラーが分かってきます

565
00:35:05,372 --> 00:35:10,778
リロードでの削除が
移動と矛盾を起こしているのです

566
00:35:10,878 --> 00:35:13,180
後でコードで修正します

567
00:35:14,248 --> 00:35:17,951
参考までに紹介しておきますが

568
00:35:18,052 --> 00:35:23,557
これがCollectionViewが
作動しなくなる原因です

569
00:35:25,325 --> 00:35:29,730
どうやって
これらの知識を活用できるのか

570
00:35:29,830 --> 00:35:33,133
どのように
データソースの更新を適用し

571
00:35:33,233 --> 00:35:36,937
全てが同期するように保てるのか

572
00:35:37,037 --> 00:35:39,173
４つの基本原則があります

573
00:35:39,373 --> 00:35:43,243
移動を 削除と挿入に分解して

574
00:35:43,710 --> 00:35:47,047
２つのリストに分けます

575
00:35:47,981 --> 00:35:52,085
まずindexPath上で
削除を降順で処理し

576
00:35:52,319 --> 00:35:55,355
挿入を昇順で適用します

577
00:35:55,756 --> 00:35:58,192
これをやれば大丈夫です

578
00:35:59,727 --> 00:36:01,428
データのリロードは？

579
00:35:59,727 --> 00:36:01,428
データのリロードは？

580
00:36:01,528 --> 00:36:04,798
モハメドが言ったように
リロードは

581
00:36:04,898 --> 00:36:06,733
ボタン１つで終わります

582
00:36:07,234 --> 00:36:09,737
しかしアニメーションが出せず

583
00:36:09,837 --> 00:36:12,306
荒っぽいアプローチです

584
00:36:12,406 --> 00:36:16,477
アニメーションを提供したいので

585
00:36:16,577 --> 00:36:19,880
これは特別な時にしか使いません

586
00:36:20,214 --> 00:36:23,116
モハメド コードを修正して

587
00:36:23,217 --> 00:36:27,521
更新アニメーションを出せるか
試してみよう

588
00:36:27,621 --> 00:36:29,356
名誉挽回の時間だ

589
00:36:29,890 --> 00:36:34,995
スティーブが説明した
修正ガイドラインを使用します

590
00:36:35,095 --> 00:36:37,965
まず古い実装を削除します

591
00:36:38,966 --> 00:36:44,738
更新はリロード 削除
移動から成っていました

592
00:36:44,838 --> 00:36:50,310
そしてリロードと移動は
同じindexPathを使いました

593
00:36:50,410 --> 00:36:52,613
そこが矛盾点でした

594
00:36:52,713 --> 00:36:55,782
まず この２つを切り離します

595
00:36:55,883 --> 00:37:00,921
リロードを
performBatchUpdatesに移します

596
00:36:55,883 --> 00:37:00,921
リロードを
performBatchUpdatesに移します

597
00:37:02,389 --> 00:37:06,326
そしてデータソースを更新して

598
00:37:06,427 --> 00:37:10,130
リロードのアイテムを
CollectionViewに呼び出します

599
00:37:10,230 --> 00:37:14,601
performWithoutAnimationで
実行しています

600
00:37:14,701 --> 00:37:17,804
実はスペックをよく見ると

601
00:37:18,205 --> 00:37:20,941
アニメーションは使われていません

602
00:37:22,276 --> 00:37:27,247
次に 残りの更新の
削除と移動を行います

603
00:37:29,817 --> 00:37:32,186
状況を整理しましょう

604
00:37:32,286 --> 00:37:36,256
index 2に削除があります

605
00:37:36,723 --> 00:37:40,761
index 3のアイテムを
index 0に移動します

606
00:37:41,295 --> 00:37:46,133
ガイドラインに従って
移動を分けると

607
00:37:46,233 --> 00:37:51,205
index 2とindex 3に削除がきます

608
00:37:51,305 --> 00:37:56,510
そしてindex 3のアイテムを
index 0に挿入

609
00:37:57,411 --> 00:38:00,614
ここでの作業は２つで

610
00:37:57,411 --> 00:38:00,614
ここでの作業は２つで

611
00:38:00,714 --> 00:38:02,950
削除と挿入です

612
00:38:03,050 --> 00:38:05,285
順番に作業を行います

613
00:38:05,619 --> 00:38:08,655
まず削除を降順で行います

614
00:38:08,755 --> 00:38:12,826
index 3で削除を行い

615
00:38:12,926 --> 00:38:16,897
Personを後から
挿入できるようにします

616
00:38:17,731 --> 00:38:20,834
そしてindex 2のアイテムを削除

617
00:38:23,136 --> 00:38:26,306
その後 昇順で挿入を処理します

618
00:38:26,406 --> 00:38:29,176
１つしかないので
それを挿入します

619
00:38:30,110 --> 00:38:33,547
最後にCollectionViewに

620
00:38:33,647 --> 00:38:37,017
アニメーションの表示を指示します

621
00:38:37,718 --> 00:38:42,256
正しいアニメーションを
表示させるために

622
00:38:42,356 --> 00:38:45,292
移動の指示のままにしています

623
00:38:45,392 --> 00:38:47,594
データソースが正しければ

624
00:38:47,694 --> 00:38:50,831
正しいアニメーションが
表示されます

625
00:38:51,298 --> 00:38:55,636
シミュレータに戻り
更新の状況を

626
00:38:56,003 --> 00:38:58,372
見てみましょう

627
00:38:59,540 --> 00:39:01,575
うまくいくでしょうか

628
00:38:59,540 --> 00:39:01,575
うまくいくでしょうか

629
00:39:02,810 --> 00:39:03,744
成功しました

630
00:39:03,844 --> 00:39:07,981
(拍手)

631
00:39:08,082 --> 00:39:11,719
リロードして
スローモーションでもう一度

632
00:39:13,854 --> 00:39:16,657
スペックのとおりです

633
00:39:16,757 --> 00:39:18,292
良くできてる

634
00:39:18,825 --> 00:39:23,163
ではスライドに戻って
まとめてみましょう

635
00:39:23,897 --> 00:39:26,934
カスタムレイアウトを作る時に

636
00:39:27,034 --> 00:39:31,138
緊張したことはありますか

637
00:39:31,238 --> 00:39:33,740
今日ご紹介した方法で

638
00:39:33,841 --> 00:39:37,811
CollectionViewソリューションを
作ってください

639
00:39:38,145 --> 00:39:41,515
リロードデータが一杯で
アニメーションが

640
00:39:41,615 --> 00:39:43,817
使えない時もあります

641
00:39:43,917 --> 00:39:47,554
これらの事項をチェックして

642
00:39:47,654 --> 00:39:51,024
間違った点を修正してください

643
00:39:52,426 --> 00:39:56,096
このリンクで
詳しい情報が見られます

644
00:39:56,196 --> 00:39:59,399
明日の朝９時に
CollectionViewラボに来れば

645
00:39:59,500 --> 00:40:02,236
質問を受け付けます

646
00:39:59,500 --> 00:40:02,236
質問を受け付けます

647
00:40:02,336 --> 00:40:05,472
モハメドと私がいる予定です

648
00:40:05,572 --> 00:40:09,510
本日はありがとうございました

649
00:40:09,743 --> 00:40:13,180
(拍手)