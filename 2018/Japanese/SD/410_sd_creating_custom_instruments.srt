
1
00:00:07,074 --> 00:00:16,383
(音楽)

2
00:00:17,384 --> 00:00:26,126
(拍手)

3
00:00:26,226 --> 00:00:27,327
おはようございます

4
00:00:27,427 --> 00:00:28,762
チャド･ウルフです

5
00:00:28,862 --> 00:00:31,198
Appleのエンジニアです

6
00:00:31,298 --> 00:00:33,066
このセッションでは―

7
00:00:33,167 --> 00:00:36,136
カスタムinstrumentの
話をします

8
00:00:37,237 --> 00:00:42,442
作りたくなる理由も
少し触れましょう

9
00:00:42,743 --> 00:00:47,681
盛りだくさんの内容を
入門 中級 上級の―

10
00:00:47,981 --> 00:00:50,384
３つに分けてお届けします

11
00:00:50,717 --> 00:00:56,557
ベストプラクティスを
本日 最後に紹介します

12
00:00:57,724 --> 00:01:00,627
では まず作りたい理由です

13
00:00:57,724 --> 00:01:00,627
では まず作りたい理由です

14
00:01:01,328 --> 00:01:04,730
Instrumentsには
有益なツールがあります

15
00:01:04,864 --> 00:01:09,803
アプリケーションとの互換性を
確認するSystem Trace

16
00:01:10,637 --> 00:01:15,242
Metal System Traceと組み合わせた
ビデオゲームのテンプレートは―

17
00:01:15,442 --> 00:01:20,080
アプリ上の機械的な画像の不具合や
フレームの消失などを解消しました

18
00:01:21,448 --> 00:01:26,854
Network Connections Instrumentを
お持ちであれば

19
00:01:26,954 --> 00:01:30,858
アプリ間の
TCP/IPの交信ができます

20
00:01:31,258 --> 00:01:36,163
そして おなじみの
Time Profilerです

21
00:01:36,296 --> 00:01:38,365
アプリ内の
時間がかかる処理を調べ

22
00:01:38,465 --> 00:01:42,069
原因がネットワーク階層なのか
ゲームエンジンなのかなど探ります

23
00:01:42,703 --> 00:01:46,373
当たり前のことですが―

24
00:01:46,740 --> 00:01:51,078
コードが分かれば
とても有益です

25
00:01:51,345 --> 00:01:57,050
IPアドレスやコールスタックの
仕組みを理解することで

26
00:01:57,217 --> 00:01:59,586
Time Profilerを
簡単にすることができます

27
00:01:59,920 --> 00:02:03,790
ではコードに不慣れだと
どうなるでしょう？

28
00:01:59,920 --> 00:02:03,790
ではコードに不慣れだと
どうなるでしょう？

29
00:02:03,891 --> 00:02:05,359
アプリの
ネットワークレイヤの―

30
00:02:05,459 --> 00:02:10,264
処理時間があまりにも
かかっていたら どう解決します？

31
00:02:10,464 --> 00:02:13,567
カスタムinstrumentの
出番です

32
00:02:13,800 --> 00:02:18,805
アプリケーションやレイヤの
状況について―

33
00:02:18,906 --> 00:02:23,544
コード初心者が分かるように
示せるのです

34
00:02:24,745 --> 00:02:29,750
Expert System技術の
有用性について―

35
00:02:29,850 --> 00:02:31,318
上級編で話します

36
00:02:31,485 --> 00:02:34,888
これによって
自動で悪いパターンを探し―

37
00:02:34,988 --> 00:02:39,126
アンチパターンを検出する
instrumentを作れます

38
00:02:40,294 --> 00:02:43,363
ではアーキテクチャを
見てみましょう

39
00:02:44,198 --> 00:02:46,066
そのために―

40
00:02:47,367 --> 00:02:48,669
振り返ってみます

41
00:02:49,102 --> 00:02:52,172
Instrumentsは
当時も今も―

42
00:02:52,272 --> 00:02:57,611
単なるドキュメントの
ライブラリです

43
00:02:57,811 --> 00:03:01,148
レコードを押すと
ツールが実行されます

44
00:02:57,811 --> 00:03:01,148
レコードを押すと
ツールが実行されます

45
00:03:01,515 --> 00:03:06,053
以前との主な違いは
Instrumentsはその組織構造上

46
00:03:06,153 --> 00:03:09,356
コードを書く速度を
上げられなかったのです

47
00:03:09,623 --> 00:03:12,793
当時は問題ありませんでした

48
00:03:12,893 --> 00:03:16,597
アセットやパフォーマンスツールを
引き継いでいたからです

49
00:03:16,697 --> 00:03:19,700
独自のレコード技術や
論理解析がありました

50
00:03:19,800 --> 00:03:23,904
トレースからデータを得るために
カスタムstorage mechanismを作り

51
00:03:24,071 --> 00:03:27,140
アプリケーションに組み込むのに
カスタムUIを作る必要がありました

52
00:03:27,774 --> 00:03:30,210
Instrumentsと
該当モデルの―

53
00:03:30,310 --> 00:03:33,046
維持費が急上昇しました

54
00:03:33,514 --> 00:03:36,116
その理由は毎回
各７個のカスタムUIと

55
00:03:36,216 --> 00:03:37,851
カスタムstorage mechanismの
作成が必要で

56
00:03:37,951 --> 00:03:41,021
それを変更する
新たな機能を加えたかったのです

57
00:03:41,255 --> 00:03:43,123
従来型のモデルを持続し

58
00:03:43,223 --> 00:03:46,994
メンテナンスにかかるコスト負担を
皆さんに続けてほしくありません

59
00:03:47,094 --> 00:03:51,798
新しい機能より
コスト問題の解決を―

60
00:03:51,999 --> 00:03:53,167
優先したのです

61
00:03:53,467 --> 00:03:55,169
新しいInstrumentsは―

62
00:03:55,269 --> 00:04:00,140
カスタムUIなどの代わりに
２つの標準化要素を使います

63
00:03:55,269 --> 00:04:00,140
カスタムUIなどの代わりに
２つの標準化要素を使います

64
00:04:00,274 --> 00:04:03,410
Standard UIと
Analysis Coreです

65
00:04:04,011 --> 00:04:08,215
Standard UIは
現代のInstrumentsのUIで―

66
00:04:08,549 --> 00:04:11,151
Analysis Coreと
組み合わせます

67
00:04:11,418 --> 00:04:14,655
Analysis Coreは
データベースと―

68
00:04:14,855 --> 00:04:17,057
エキスパートシステムの
中間です

69
00:04:17,224 --> 00:04:22,062
そしてInstrumentsの
重要な基盤となります

70
00:04:22,329 --> 00:04:26,733
現代の構造でInstrumentを
作ると―

71
00:04:26,900 --> 00:04:33,473
Standard UIとAnalysis Coreの
custom configurationが必要です

72
00:04:34,007 --> 00:04:37,477
こちらの画面をご覧ください

73
00:04:37,578 --> 00:04:40,714
System Traceと―

74
00:04:41,048 --> 00:04:43,517
ゲームテンプレート

75
00:04:43,750 --> 00:04:45,819
ネットワークコネクション
テンプレートと―

76
00:04:46,153 --> 00:04:48,555
Time Profilerの画面です

77
00:04:48,789 --> 00:04:50,824
全ドキュメントの
Instrumentは―

78
00:04:50,924 --> 00:04:55,028
Standard UIとAnalysis Coreで
ビルドされました

79
00:04:55,362 --> 00:04:57,764
同様に皆さんも作れます

80
00:04:58,699 --> 00:05:03,770
Xcode 10とInstruments 10で
同じツールを提供しています

81
00:04:58,699 --> 00:05:03,770
Xcode 10とInstruments 10で
同じツールを提供しています

82
00:05:03,871 --> 00:05:08,542
Xcodeと皆さんの
Instrumentsの違いは―

83
00:05:08,642 --> 00:05:11,211
作成者だけです

84
00:05:12,779 --> 00:05:15,215
ライブラリにInstrumentsが
表示されます

85
00:05:15,349 --> 00:05:18,685
トップは
アクティビティモニタです

86
00:05:19,019 --> 00:05:23,757
ドラッグ＆ドロップで
レコードを残します

87
00:05:24,124 --> 00:05:27,261
Analysis Coreに
データを入れると―

88
00:05:27,361 --> 00:05:30,998
Standard UIがグラフと
Table Viewを表示します

89
00:05:31,765 --> 00:05:37,437
トップにグラフがあり
２通りで表示されています

90
00:05:37,638 --> 00:05:41,608
１つ以上のグラフで
定義できます

91
00:05:42,576 --> 00:05:45,379
定義するグラフを
選ぶ方法は―

92
00:05:45,479 --> 00:05:48,582
Instrumentsアイコンの
この部分を使います

93
00:05:48,682 --> 00:05:52,452
CPUからネットワークに
変更できます

94
00:05:53,987 --> 00:05:57,624
どのグラフにも
一定のレーンがあります

95
00:05:57,724 --> 00:06:01,795
CPUの使用率で
３つレーンを定義しました

96
00:05:57,724 --> 00:06:01,795
CPUの使用率で
３つレーンを定義しました

97
00:06:03,130 --> 00:06:06,833
レーンはAnalysis Coreの
テーブルに結びつきます

98
00:06:06,934 --> 00:06:11,438
同テーブル内の別カラムの
場合もあります

99
00:06:12,673 --> 00:06:15,108
Instrumentsの下部は―

100
00:06:15,209 --> 00:06:18,846
Detail Viewと呼ばれる
重要な部分です

101
00:06:19,246 --> 00:06:22,649
event-by-event listや―

102
00:06:22,749 --> 00:06:25,752
データのアグリゲーションや
サマリも見られます

103
00:06:27,521 --> 00:06:30,757
グラフと同じように―

104
00:06:30,958 --> 00:06:33,594
Instrumentsの項目数を
定義できます

105
00:06:33,694 --> 00:06:37,030
ジャンプバーで
項目を選び―

106
00:06:37,130 --> 00:06:39,900
自分で定義づけるタイトルの
詳細を選択します

107
00:06:40,868 --> 00:06:43,070
グラフのレーンと同じく―

108
00:06:43,170 --> 00:06:47,474
全項目がAnalysis Coreの
テーブルに結び付いています

109
00:06:47,574 --> 00:06:51,044
データを受け取って
レコードします

110
00:06:51,145 --> 00:06:54,715
特別なコードは
必要ありません

111
00:06:56,049 --> 00:07:01,889
Analysis Coreは すべて
テーブルで表示されます

112
00:06:56,049 --> 00:07:01,889
Analysis Coreは すべて
テーブルで表示されます

113
00:07:01,989 --> 00:07:04,491
テーブルとは―

114
00:07:05,058 --> 00:07:09,429
ローの集合体で
構造は定義されています

115
00:07:09,530 --> 00:07:11,698
データベースに似ています

116
00:07:12,466 --> 00:07:16,370
スキーマはカラムや
その名前を定義します

117
00:07:16,470 --> 00:07:18,138
新しいAnalysis Coreは

118
00:07:18,238 --> 00:07:20,807
engineering typeという
システムを使っています

119
00:07:20,974 --> 00:07:26,280
標準UIの中でも データの保存
視覚化 解析の方法が分かります

120
00:07:27,447 --> 00:07:32,352
テーブルの構造を
スキーマが説明し―

121
00:07:32,586 --> 00:07:36,223
コンテンツの説明に
属性を使用できます

122
00:07:36,523 --> 00:07:39,226
何がテーブルに入るか
分かります

123
00:07:39,426 --> 00:07:44,264
Objective-CかSwiftでは
スキーマはクラスで

124
00:07:44,498 --> 00:07:46,266
ローはインスタンスです

125
00:07:46,533 --> 00:07:49,837
スキーマの名称は固有です

126
00:07:49,937 --> 00:07:53,273
Objective-Cの
クラスの名前や―

127
00:07:53,407 --> 00:07:56,743
Stringの代わりの
NSStringと同じです

128
00:07:57,044 --> 00:08:00,147
上級編で
重要な点ですが―

129
00:07:57,044 --> 00:08:00,147
上級編で
重要な点ですが―

130
00:08:00,814 --> 00:08:02,115
先に触れます

131
00:08:02,883 --> 00:08:05,886
スキーマの例として
tickがあります

132
00:08:06,019 --> 00:08:08,655
Instrumentsの
スキーマの１つです

133
00:08:08,755 --> 00:08:11,258
統計計算で使用する―

134
00:08:11,358 --> 00:08:15,262
総合的なClock Tickの
テーブルを維持していました

135
00:08:15,796 --> 00:08:19,199
カラムは１つで
Sample Timeを使う―

136
00:08:19,299 --> 00:08:21,635
シンプルな構造です

137
00:08:22,102 --> 00:08:24,104
さらにテーブルの特徴である―

138
00:08:24,238 --> 00:08:27,541
周波数に属する可能性のある
視覚属性を定義づけます

139
00:08:27,708 --> 00:08:33,480
10属性でtickスキーマに
テーブルを作るとしましょう

140
00:08:33,947 --> 00:08:38,118
１秒10タイムスタンプで
データ入力が必要だと―

141
00:08:38,251 --> 00:08:40,386
プロバイダは分かります

142
00:08:40,520 --> 00:08:43,857
こうしてテーブルに書き込んだ
データと情報伝達ができるのです

143
00:08:44,491 --> 00:08:48,462
入門編の情報は
これで十分でしょう

144
00:08:48,762 --> 00:08:53,767
XcodeでのInstrumentsの
作り方をお示しします

145
00:08:53,901 --> 00:08:56,470
また tickを
Detail Viewで示す―

146
00:08:56,570 --> 00:09:00,107
Instrumentの作り方も
お伝えします

147
00:08:56,570 --> 00:09:00,107
Instrumentの作り方も
お伝えします

148
00:09:00,307 --> 00:09:03,777
では同僚のキャスパーが―

149
00:09:03,877 --> 00:09:05,445
実演します

150
00:09:05,679 --> 00:09:08,315
(拍手)

151
00:09:08,448 --> 00:09:09,583
ありがとうございます

152
00:09:09,950 --> 00:09:15,589
カスタムinstrumentを作り
実行する方法を説明します

153
00:09:16,256 --> 00:09:19,059
tickスキーマを使って―

154
00:09:19,259 --> 00:09:22,796
一定の頻度で
Instrumentを作ります

155
00:09:23,764 --> 00:09:26,333
パッケージを説明したり―

156
00:09:26,700 --> 00:09:30,571
Instrumentsで
テストする方法を学びます

157
00:09:31,071 --> 00:09:32,005
始めましょう

158
00:09:33,173 --> 00:09:35,876
Xcodeと同じように―

159
00:09:36,009 --> 00:09:38,345
新しいパッケージを作ります

160
00:09:38,612 --> 00:09:40,547
New Xcode Projectに飛び―

161
00:09:40,848 --> 00:09:43,984
Instrumentsパッケージを
選びます

162
00:09:45,252 --> 00:09:49,790
Instrumentsパッケージの
デフォルト名を入力します

163
00:09:49,923 --> 00:09:51,258
“Ticks”とします

164
00:09:52,693 --> 00:09:53,827
“Next”をクリック

165
00:09:54,561 --> 00:09:55,729
“Create”をクリック

166
00:09:59,733 --> 00:10:04,037
Xcodeが package definitionと
package targetを持つ―

167
00:09:59,733 --> 00:10:04,037
Xcodeが package definitionと
package targetを持つ―

168
00:10:04,304 --> 00:10:05,873
プロジェクトを作成しました

169
00:10:07,674 --> 00:10:09,009
中を見てみます

170
00:10:10,410 --> 00:10:13,747
パッケージは
XMLのシンタックスです

171
00:10:13,981 --> 00:10:19,186
ID タイトル オーナーが
含まれています

172
00:10:19,319 --> 00:10:23,290
パッケージをインストールすると
これらのフィールドが見られます

173
00:10:24,758 --> 00:10:28,128
スキーマとモデラを
定義して―

174
00:10:29,429 --> 00:10:30,898
開始します

175
00:10:31,031 --> 00:10:36,069
先に定めたtickスキーマを
使うのでガイドを消します

176
00:10:39,406 --> 00:10:45,112
ベースパッケージからスキーマの
要素とfirst nameを特定して―

177
00:10:47,381 --> 00:10:49,383
インポートします

178
00:10:53,554 --> 00:10:56,557
Instrumentsの
準備が整いました

179
00:10:58,992 --> 00:11:02,262
複雑な要素を
簡単に定義するため―

180
00:10:58,992 --> 00:11:02,262
複雑な要素を
簡単に定義するため―

181
00:11:02,496 --> 00:11:04,832
Xcodeで
スニペットを利用します

182
00:11:05,165 --> 00:11:08,435
要素名を
例えばInstrumentと書き込み―

183
00:11:08,836 --> 00:11:11,972
リターンを押します

184
00:11:13,707 --> 00:11:17,244
Instrumentに
ユニークIDと―

185
00:11:21,215 --> 00:11:24,918
後でInstrumentsライブラリに
出現するプロパティをいくつか入力

186
00:11:29,890 --> 00:11:32,025
10ミリ秒ごとに―

187
00:11:34,194 --> 00:11:35,863
tickを書き込む
Instrumentです

188
00:11:39,199 --> 00:11:43,937
このInstrumentがライブラリから
trace documentにドロップした時

189
00:11:44,037 --> 00:11:46,907
テーブルが作成されます

190
00:11:47,875 --> 00:11:52,012
テーブルIDは Instrumentの
定義内で固有でなければなりません

191
00:11:52,546 --> 00:11:54,148
“tick-table”とします

192
00:11:56,049 --> 00:11:57,284
schema-refの中に―

193
00:11:57,384 --> 00:12:01,221
すでにtickにインポートされている
スキーマのリファレンスが必要です

194
00:11:57,384 --> 00:12:01,221
すでにtickにインポートされている
スキーマのリファレンスが必要です

195
00:12:04,424 --> 00:12:07,361
Track Viewと
Detail Viewでの―

196
00:12:07,794 --> 00:12:09,863
表示を定義します

197
00:12:10,464 --> 00:12:12,266
グラフ要素を使います

198
00:12:14,268 --> 00:12:17,905
グラフの中のタイトルを
“Ticks”とします

199
00:12:19,373 --> 00:12:21,542
レーンのタイトルです

200
00:12:24,211 --> 00:12:27,080
事前に作成した
テーブルとして―

201
00:12:27,214 --> 00:12:31,552
tickテーブルの
リファレンスが必要です

202
00:12:34,221 --> 00:12:37,457
これでグラフの
プロッティングを特定します

203
00:12:38,158 --> 00:12:39,927
プロット要素を使います

204
00:12:40,627 --> 00:12:42,563
基本的に―

205
00:12:42,663 --> 00:12:47,267
カラムのmnemonicを
パスする必要があります

206
00:12:48,101 --> 00:12:49,670
グラフ化します

207
00:12:52,940 --> 00:12:57,444
タイムスタンプが
見られるようにするため―

208
00:12:57,711 --> 00:13:00,681
リスト要素を使います

209
00:12:57,711 --> 00:13:00,681
リスト要素を使います

210
00:13:02,883 --> 00:13:07,888
レーン要素と同じく
table refで表示される―

211
00:13:10,257 --> 00:13:13,260
リストのタイトルを
パスします

212
00:13:15,028 --> 00:13:17,030
見たいカラムも同じです

213
00:13:20,467 --> 00:13:25,072
Instrumentsを
実行する準備ができました

214
00:13:25,839 --> 00:13:28,909
Xcodeスキーマを使います

215
00:13:29,576 --> 00:13:30,611
やってみます

216
00:13:33,413 --> 00:13:35,716
ビルドエラーが出ました

217
00:13:35,816 --> 00:13:39,153
IDサポートが
表示されています

218
00:13:39,253 --> 00:13:41,154
エラーはここです

219
00:13:41,255 --> 00:13:45,092
カラムのタイムスタンプが
ないという内容です

220
00:13:45,626 --> 00:13:48,695
“time”にしないと
いけません

221
00:13:49,029 --> 00:13:50,230
修正して―

222
00:13:51,798 --> 00:13:53,000
実行します

223
00:13:55,335 --> 00:13:57,471
確認できるのは―

224
00:13:57,671 --> 00:14:00,340
Instrumentsの
コピーだからです

225
00:13:57,671 --> 00:14:00,340
Instrumentsの
コピーだからです

226
00:14:00,841 --> 00:14:04,044
アイコンが違うので
分かります

227
00:14:04,745 --> 00:14:08,382
一時的にパッケージを
取り込みます

228
00:14:08,715 --> 00:14:11,685
もっと簡単に繰り返せます

229
00:14:13,487 --> 00:14:16,590
取り込みを確認するには―

230
00:14:16,723 --> 00:14:19,993
New Package Management UIで
分かります

231
00:14:20,294 --> 00:14:23,363
“Instruments”の
“Preferences”から―

232
00:14:23,730 --> 00:14:24,965
確認できます

233
00:14:27,501 --> 00:14:31,705
新しく作成された
パッケージを見られます

234
00:14:31,805 --> 00:14:34,274
一時的に取り込まれています

235
00:14:35,642 --> 00:14:38,178
システムパッケージも
あります

236
00:14:38,312 --> 00:14:42,583
ここに表示される
リンクを使えます

237
00:14:44,718 --> 00:14:47,221
Ticksパッケージは
Ticks Instrumentを含みます

238
00:14:47,387 --> 00:14:48,922
テストしましょう

239
00:14:51,625 --> 00:14:53,126
空のテンプレートです

240
00:14:53,594 --> 00:14:56,663
ターゲットを
MacBookにします

241
00:15:00,367 --> 00:15:03,570
ライブラリで
Instrumentを探します

242
00:15:04,671 --> 00:15:06,306
“Ticks”と入力

243
00:15:08,509 --> 00:15:13,447
package definitionから入力された
全プロパティが表示されます

244
00:15:15,015 --> 00:15:17,017
ドラッグ＆ドロップし―

245
00:15:19,753 --> 00:15:21,688
すぐにレコードします

246
00:15:26,093 --> 00:15:31,899
下位ペインを見ると10ミリ秒ごとに
データが生成され増えています

247
00:15:33,267 --> 00:15:36,136
detailとグラフは
調整し合っています

248
00:15:36,270 --> 00:15:40,107
ローをクリックすると
inspection headが移動します

249
00:15:41,008 --> 00:15:42,843
グラフをズームインします

250
00:15:42,976 --> 00:15:45,379
Optionを押してクリックし
ドラッグします

251
00:15:48,682 --> 00:15:51,952
tickが刻まれています

252
00:15:54,221 --> 00:15:57,090
パッケージの作り方でした

253
00:15:57,457 --> 00:16:01,228
ではチャドが
Standard UIの話をします

254
00:15:57,457 --> 00:16:01,228
ではチャドが
Standard UIの話をします

255
00:16:02,029 --> 00:16:04,765
(拍手)

256
00:16:04,865 --> 00:16:06,366
ありがとう

257
00:16:06,700 --> 00:16:09,736
初めての
プロジェクトとして―

258
00:16:09,837 --> 00:16:13,307
基本のInstrumentの
作り方を説明しました

259
00:16:13,607 --> 00:16:16,610
次はグラフと
詳細について―

260
00:16:16,710 --> 00:16:21,114
また実際のデータでの対応を
説明します

261
00:16:21,548 --> 00:16:24,051
グラフレーンからです

262
00:16:24,751 --> 00:16:28,689
キャスパーは
プロット要素を使って―

263
00:16:28,856 --> 00:16:30,824
グラフとレーンを
定義しました

264
00:16:31,325 --> 00:16:32,693
プロット要素は―

265
00:16:33,260 --> 00:16:36,263
Standard UIへの
指示方法です

266
00:16:36,363 --> 00:16:39,166
テーブルの
全コンテンツを―

267
00:16:39,299 --> 00:16:41,835
レーンに割り当てるよう
指示します

268
00:16:42,102 --> 00:16:48,675
グラフの作り方やその扱いを
プロット要素が決めるには

269
00:16:48,876 --> 00:16:53,547
カラムとスキーマの両方を
確認することです

270
00:16:53,914 --> 00:16:57,751
インターバルスキーマは
継続時間があり―

271
00:16:57,851 --> 00:17:02,022
ポイントスキーマは
タイムスタンプと同じです

272
00:16:57,851 --> 00:17:02,022
ポイントスキーマは
タイムスタンプと同じです

273
00:17:02,489 --> 00:17:05,959
カラムがマグニチュードを
ターゲットとした時は―

274
00:17:06,059 --> 00:17:10,564
このように
棒グラフを作れます

275
00:17:11,397 --> 00:17:14,134
もう１つは
ライフサイクルレーンで―

276
00:17:14,233 --> 00:17:19,272
インターバルスキーマですが
stateのカラムを選択します

277
00:17:19,373 --> 00:17:24,044
stateはマグニチュードがないので
棒グラフは作成しません

278
00:17:24,411 --> 00:17:27,513
Standard UIは インターバルを
関連づけることができ―

279
00:17:27,614 --> 00:17:29,883
state style treatmentを
自動的に選びます

280
00:17:30,017 --> 00:17:35,756
そして丸長方形型に分類されるので
平らな棒グラフとは異なります

281
00:17:36,256 --> 00:17:39,393
Standard UIは
こうした調整が可能です

282
00:17:39,493 --> 00:17:42,129
それでInstruments UIを
安定させます

283
00:17:42,262 --> 00:17:44,932
私たちが
状態図を定義する場合―

284
00:17:45,065 --> 00:17:48,068
Standard UIは
同じ処理を行います

285
00:17:48,168 --> 00:17:52,839
それがInstrumentsのユーザの
利便性を高めています

286
00:17:54,341 --> 00:17:58,979
グラフや多くのレーンを
作りたいなら―

287
00:17:59,079 --> 00:18:02,616
プロットテンプレートを
定義できます

288
00:17:59,079 --> 00:18:02,616
プロットテンプレートを
定義できます

289
00:18:02,916 --> 00:18:06,019
テーブルでカラムを選べる
要素を除いて―

290
00:18:06,120 --> 00:18:10,324
プロットに類似しています

291
00:18:10,424 --> 00:18:14,394
そしてカラムで値ごとに
ローを分けて作ります

292
00:18:15,896 --> 00:18:18,432
スパイクまたはアクティビティの
停止区間を限定して見たい場合は

293
00:18:18,532 --> 00:18:19,933
ヒストグラムがあります

294
00:18:20,067 --> 00:18:24,838
100ミリ秒ほどタイムラインを
休ませることができます

295
00:18:24,972 --> 00:18:27,975
COUNT SUM または
最大値 最小値で―

296
00:18:28,242 --> 00:18:33,747
バケットのマグニチュードを
増やすことができます

297
00:18:33,847 --> 00:18:36,316
一番よい方法は―

298
00:18:36,416 --> 00:18:42,356
アクティビティのスパイクを
System Traceで探すことです

299
00:18:44,024 --> 00:18:47,794
UIの下半分にある
Detailsの話をします

300
00:18:48,362 --> 00:18:50,664
“List”の画面です

301
00:18:50,764 --> 00:18:55,102
UI内のテーブルと
Analysis CoreとTable Viewの―

302
00:18:55,235 --> 00:18:57,905
シンプルなマッピングです

303
00:18:58,672 --> 00:19:00,107
“アグリゲーション”です

304
00:18:58,672 --> 00:19:00,107
“アグリゲーション”です

305
00:19:00,707 --> 00:19:04,011
タイムコンポーネントを
減じたり―

306
00:19:04,111 --> 00:19:08,849
テーブルの中の統計を
取りたいですよね

307
00:19:09,283 --> 00:19:11,418
アグリゲーションを
定義する時―

308
00:19:11,652 --> 00:19:14,621
カラムは関数です

309
00:19:14,721 --> 00:19:17,758
SUM 平均値 COUNTなど
異種の統計計算機能を使い―

310
00:19:17,858 --> 00:19:23,497
望みどおりの
アグリゲーションviewを―

311
00:19:23,597 --> 00:19:26,567
作ることができます

312
00:19:28,035 --> 00:19:32,072
アグリゲーションの利点は
階層を定義することです

313
00:19:32,172 --> 00:19:36,643
ここで 仮想メモリ階層の中に
プロセススレッドを定義しました

314
00:19:36,810 --> 00:19:39,713
プロセスや その中の
各スレッドによって―

315
00:19:39,813 --> 00:19:44,084
分析された全体を
見ることができます

316
00:19:44,184 --> 00:19:45,986
該当するプロセス内でです

317
00:19:46,086 --> 00:19:50,724
アグリゲーションは 大量の
データの概要を見るのに最適です

318
00:19:52,059 --> 00:19:54,862
Call Treeは
新しいアグリゲーションです

319
00:19:55,362 --> 00:19:58,665
Call Treeは
backtraceカラムがあれば有用です

320
00:19:58,832 --> 00:20:03,370
Time Profiler同様
weighted backtrace または―

321
00:19:58,832 --> 00:20:03,370
Time Profiler同様
weighted backtrace または―

322
00:20:03,637 --> 00:20:06,406
weighted Call Tree viewを
作ることができます

323
00:20:07,641 --> 00:20:09,910
ナラティブと呼ばれる
形式があります

324
00:20:10,010 --> 00:20:14,181
専門用語に関する情報を
伝える時に―

325
00:20:14,281 --> 00:20:16,517
ナラティブが有益です

326
00:20:16,617 --> 00:20:18,385
例えば エキスパートシステムの
出力などが

327
00:20:18,485 --> 00:20:21,655
narrative engineering typeに
円滑に伝達されます

328
00:20:23,791 --> 00:20:26,860
最後はtime sliceです

329
00:20:26,994 --> 00:20:29,062
これはListに似ています

330
00:20:29,162 --> 00:20:33,167
青色の線で
二分した区間を含めて―

331
00:20:33,267 --> 00:20:36,570
コンテンツを絞り込む点が
違います

332
00:20:36,670 --> 00:20:41,341
青いライン つまり
inspection headを動かし

333
00:20:41,475 --> 00:20:44,678
リストのコンテンツが
比較されます

334
00:20:46,680 --> 00:20:51,018
Analysis Coreのテーブルに
３つのUIが関連づけられます

335
00:20:51,218 --> 00:20:52,586
レコードを押すと―

336
00:20:52,686 --> 00:20:57,524
Instrumentsにデータが入り
Analysis Coreが埋まります

337
00:20:57,791 --> 00:21:01,094
プロセスがどう働くか
説明します

338
00:20:57,791 --> 00:21:01,094
プロセスがどう働くか
説明します

339
00:21:02,663 --> 00:21:05,732
レコードを押す前に―

340
00:21:05,833 --> 00:21:09,570
Analysis Coreが
テーブルを取ります

341
00:21:09,670 --> 00:21:13,173
マッピングして
ストレージを割り当てます

342
00:21:13,640 --> 00:21:17,010
テーブルがまったく同じスキーマで
属性を持てば―

343
00:21:17,110 --> 00:21:21,849
定義上 同じデータなので
同じストアでマップされます

344
00:21:23,016 --> 00:21:27,521
次に 各ストアに
データ用プロバイダを探します

345
00:21:27,654 --> 00:21:31,058
ターゲットのデータストリームから
直接レコードすることも可能ですし

346
00:21:31,258 --> 00:21:34,361
モデラを使って
データを統合できます

347
00:21:35,195 --> 00:21:37,464
モデラは独自の入力を
要求することができます

348
00:21:37,564 --> 00:21:40,167
これらは他のモデラの
出力にもなり

349
00:21:40,267 --> 00:21:42,536
直接レコードする方法が分からない
残りのデータを統合し

350
00:21:42,636 --> 00:21:46,740
データストリームより
直接レコード可能です

351
00:21:47,341 --> 00:21:52,846
Analysis Coreの中にストアされた
すべてのデータソースを得られます

352
00:21:53,180 --> 00:21:57,384
このbinding solutionですが
binding solutionを可視化します

353
00:21:57,484 --> 00:22:00,754
Instrumentsがbinding
solutionを見られるようにします

354
00:21:57,484 --> 00:22:00,754
Instrumentsがbinding
solutionを見られるようにします

355
00:22:00,854 --> 00:22:02,656
thread narrativeと呼びます

356
00:22:03,924 --> 00:22:05,893
binding solutionは―

357
00:22:06,093 --> 00:22:07,861
トレース全体に渡ります

358
00:22:08,195 --> 00:22:12,266
ドラッグ＆ドロップで
Instrumentをトレースします

359
00:22:12,432 --> 00:22:15,969
Instrumentsは
最大限にレコード 演算し―

360
00:22:16,069 --> 00:22:19,339
ターゲットへの影響を
最小限に抑えます

361
00:22:20,741 --> 00:22:23,076
テーブルや
テーブルインスタンスを作る時

362
00:22:23,177 --> 00:22:24,978
Instrumentsは
スキーマを必要とします

363
00:22:25,279 --> 00:22:29,149
すでに100スキーマを
超えています

364
00:22:29,817 --> 00:22:34,888
Package Management UIの中に
含まれる全スキーマが使えます

365
00:22:35,089 --> 00:22:38,759
自分のパッケージに
インポート可能です

366
00:22:38,892 --> 00:22:43,163
スキーマが基本パッケージに
含まれていない場合―

367
00:22:43,297 --> 00:22:47,801
Xcodeの設定で
関連づけが必要です

368
00:22:47,901 --> 00:22:53,440
他のパッケージを
探せるように設定します

369
00:22:54,608 --> 00:22:57,478
スキーマはすべて 他の
パッケージ内でも定義されるので

370
00:22:57,578 --> 00:23:01,248
レコードを押すと テーブルが
スキーマと共に情報入力されます

371
00:22:57,578 --> 00:23:01,248
レコードを押すと テーブルが
スキーマと共に情報入力されます

372
00:23:01,348 --> 00:23:03,584
モデラが定義するか
データストリームから

373
00:23:03,684 --> 00:23:04,952
レコードする方法が分かれば

374
00:23:05,052 --> 00:23:07,921
自身のモデラに書き込む
優れた出力を作るよりも

375
00:23:08,155 --> 00:23:11,925
優れたビルディングブロックを
作ることができます

376
00:23:12,493 --> 00:23:13,994
これでモデラエレメントと―

377
00:23:14,094 --> 00:23:17,731
Instruments Packageの中に
書くか定義することができます

378
00:23:18,098 --> 00:23:21,468
モデラに
カスタム出力スキーマを―

379
00:23:21,568 --> 00:23:24,004
作ることができます

380
00:23:24,104 --> 00:23:26,840
点にはポイントスキーマを

381
00:23:26,974 --> 00:23:29,910
点と区間の複合の場合は
インターバルスキーマを使えます

382
00:23:31,612 --> 00:23:34,848
モデラは
どの入力が必要か定義でき―

383
00:23:35,015 --> 00:23:39,553
残りのデータフロー･グラフを
埋めることができますが―

384
00:23:39,653 --> 00:23:43,357
これをデータバインディング
ソリューションと呼びます

385
00:23:44,491 --> 00:23:49,263
モデラはCLIPS言語で書かれた
小型のエキスパートシステムです

386
00:23:49,496 --> 00:23:52,900
つまりパワフルで
進化しているのです

387
00:23:53,000 --> 00:23:57,871
モデラの作り方の詳細は上級編で
後ほど扱います

388
00:23:58,772 --> 00:24:02,443
独自のスキーマを
定義できることと―

389
00:23:58,772 --> 00:24:02,443
独自のスキーマを
定義できることと―

390
00:24:02,543 --> 00:24:05,279
Instrumentsに入れるデータを得る
最適な方法

391
00:24:05,379 --> 00:24:08,048
新しいos signpost APIを
持つことが最重要でした

392
00:24:08,448 --> 00:24:10,951
ショートカットも
作っています

393
00:24:11,952 --> 00:24:16,023
パッケージ内に os-signpost-
interval-schemaという―

394
00:24:16,156 --> 00:24:18,559
スキーマを定義できます

395
00:24:18,759 --> 00:24:23,964
スキーマを定義し　モデラを代理で
作成する方法を説明してくれます

396
00:24:24,631 --> 00:24:28,068
os signpost callsのメタデータに
自分でレコードしたデータを

397
00:24:28,168 --> 00:24:30,370
内部から
取り込むことができます

398
00:24:31,138 --> 00:24:34,808
そして取り込んだ
メタデータを使い―

399
00:24:34,942 --> 00:24:39,313
スキーマのカラムの埋め方を
定義できます

400
00:24:40,013 --> 00:24:42,583
シンプルな例です

401
00:24:43,016 --> 00:24:46,787
JSONのデコードを
例にしましょう

402
00:24:46,920 --> 00:24:52,493
デコードの始まりと終わりを
マークするsignpostがあります

403
00:24:52,793 --> 00:24:55,629
最初はメタデータを
取り込み―

404
00:24:55,729 --> 00:24:59,867
解析するJSONオブジェクトの
容量を示します

405
00:25:00,701 --> 00:25:02,636
これで
Instruments Package definitionに

406
00:25:02,703 --> 00:25:05,139
os-signpost-interval-schemaを
作れます

407
00:25:05,405 --> 00:25:08,842
スキーマの名前も定義します

408
00:25:09,142 --> 00:25:14,314
レコードしたいsignpostと
その名前を選びます

409
00:25:14,982 --> 00:25:19,152
これでシンタックスを使って
メタデータメッセージの最初から

410
00:25:19,253 --> 00:25:21,755
各メタデータを取り込みます

411
00:25:22,122 --> 00:25:26,126
さらに取り込んだ値を
使って―

412
00:25:26,293 --> 00:25:30,697
定義したカラムのデータ容量を
入力する方法を教えてくれます

413
00:25:32,533 --> 00:25:38,305
セッション405ではロギングを使い
計測法を紹介していましたね

414
00:25:38,806 --> 00:25:43,010
その時 Trailblazerの
実演を行い―

415
00:25:43,110 --> 00:25:47,681
signpostを基に書き込める
Instrumentをお見せしました

416
00:25:47,848 --> 00:25:51,151
カスタムinstrumentへの
書き込みについてでした

417
00:25:51,251 --> 00:25:53,821
ではキャスパーに―

418
00:25:53,921 --> 00:25:57,758
パッケージの作り方を
実演してもらいます

419
00:25:57,958 --> 00:26:04,264
(拍手)

420
00:25:57,958 --> 00:26:04,264
(拍手)

421
00:26:04,898 --> 00:26:05,899
ありがとう チャド

422
00:26:10,070 --> 00:26:12,673
TrailblazerはiOSの
アプリケーションで―

423
00:26:12,806 --> 00:26:16,443
身近なハイキングコースを
紹介するものです

424
00:26:17,177 --> 00:26:20,314
UITableViewを使用します

425
00:26:20,914 --> 00:26:24,451
各セルで画像を取り込みます

426
00:26:25,185 --> 00:26:28,055
欠陥を防ぎ
最適化するため―

427
00:26:28,155 --> 00:26:30,757
セルの再利用時は
ダウンロードを中止します

428
00:26:31,425 --> 00:26:33,927
流れを可視化するため―

429
00:26:34,061 --> 00:26:37,064
データを os signpost callに
まとめます

430
00:26:37,397 --> 00:26:38,699
ご覧ください

431
00:26:41,735 --> 00:26:45,806
セルの表示中に
画像が取り込まれます

432
00:26:45,939 --> 00:26:48,942
OSログハンドルやダウンローダ
オブジェクトから取得する―

433
00:26:49,042 --> 00:26:52,679
downloader signpost IDを
作ると

434
00:26:53,180 --> 00:26:56,483
UITableViewの
セルのアドレスを入手します

435
00:26:57,918 --> 00:27:02,422
signpost
ネットワークから―

436
00:26:57,918 --> 00:27:02,422
signpost
ネットワークから―

437
00:27:02,589 --> 00:27:06,226
OSログより始まる
os signpostを呼び出します

438
00:27:07,194 --> 00:27:10,731
このログが カテゴリー別に
サブシステムと

439
00:27:10,831 --> 00:27:12,900
ネットワークの
アプリケーションIDを取ります

440
00:27:14,802 --> 00:27:16,837
背景画像の名前と関連せず―

441
00:27:17,204 --> 00:27:22,443
画像名が含まれたsignpost IDと
メッセージ形式が作られました

442
00:27:23,844 --> 00:27:27,681
stringやcallerは
セルのアドレスなので―

443
00:27:28,182 --> 00:27:30,684
public specifierに
まとめます

444
00:27:32,152 --> 00:27:35,789
２通りで
ダウンロードできました

445
00:27:35,989 --> 00:27:37,724
ご覧ください

446
00:27:39,059 --> 00:27:43,330
このように完了すると
デリゲート方が最適です

447
00:27:43,997 --> 00:27:48,936
先にsignpost IDを作って
os signpost endを呼び出します

448
00:27:49,469 --> 00:27:53,006
今回はステータスとサイズを
パスします

449
00:27:54,074 --> 00:27:57,377
ステータスの値が
完了しています

450
00:27:58,178 --> 00:28:00,280
サイズは画像に
合わせます

451
00:27:58,178 --> 00:28:00,280
サイズは画像に
合わせます

452
00:28:02,115 --> 00:28:06,487
次にoverwriteの準備を
ご覧ください

453
00:28:08,088 --> 00:28:11,425
実行中のダウンローダを
キャンセルします

454
00:28:12,059 --> 00:28:15,129
signpost IDを作り
呼び出します

455
00:28:15,229 --> 00:28:18,766
同じフォーマットですが
値はキャンセルです

456
00:28:18,932 --> 00:28:22,002
ダウンロードに失敗したので
サイズはゼロです

457
00:28:23,971 --> 00:28:27,207
os signpostインターバル
スキーマを見てみます

458
00:28:27,307 --> 00:28:30,644
どのようにパッケージを
取り込むのでしょうか

459
00:28:33,013 --> 00:28:37,151
signpostインターバルスキーマを
ユニークID タイトルと共に定義

460
00:28:37,651 --> 00:28:40,787
そしてサブシステムと
カテゴリを定義します

461
00:28:40,888 --> 00:28:44,958
OSのlogハンドルを作った際
パスしたものです

462
00:28:47,394 --> 00:28:52,766
os signpostの呼び出しや
startとendでパスした―

463
00:28:53,267 --> 00:28:56,437
名前要素とスタート･エンド
パターンを作ります

464
00:28:56,637 --> 00:29:02,042
両方が os signpostのbeginとendの
セルを通過したものと一致してます

465
00:28:56,637 --> 00:29:02,042
両方が os signpostのbeginとendの
セルを通過したものと一致してます

466
00:29:04,177 --> 00:29:07,214
メッセージ要素は
書式のstringと同じです

467
00:29:07,314 --> 00:29:09,817
format argumentの
代わりに―

468
00:29:10,083 --> 00:29:15,689
os signpostを呼びこむ時 値を
取り込むために変数をパスします

469
00:29:17,291 --> 00:29:20,994
カラムに値を入力する方法を
説明します

470
00:29:24,164 --> 00:29:26,867
ここにステータスのカラムが
あります

471
00:29:26,967 --> 00:29:30,604
完了か中止なので
stringです

472
00:29:31,405 --> 00:29:35,375
ステータス変数を入力します

473
00:29:37,144 --> 00:29:41,081
式要素は
Clipsの式を取るので―

474
00:29:41,615 --> 00:29:44,384
もっと高度なこともできます

475
00:29:44,718 --> 00:29:49,423
容量によりイベントインパクトを
演算することができます

476
00:29:49,790 --> 00:29:53,961
3.5MBを超えるとイベント
インパクトは高いです

477
00:29:54,328 --> 00:29:56,997
オペレーションインパクトは
逆に低いです

478
00:29:58,632 --> 00:30:01,602
os signpostインターバル
スキーマの定義でした

479
00:29:58,632 --> 00:30:01,602
os signpostインターバル
スキーマの定義でした

480
00:30:01,768 --> 00:30:04,471
次にテーブル作成です

481
00:30:06,006 --> 00:30:11,645
os signpostインターバル
スキーマのIDをパスし―

482
00:30:11,879 --> 00:30:15,082
テーブルに
ユニークIDを作ります

483
00:30:15,816 --> 00:30:19,086
そしてUI definitionで
参照します

484
00:30:20,487 --> 00:30:23,056
グラフ用にレーンを作ります

485
00:30:23,690 --> 00:30:28,262
テーブルを取得し プロット
テンプレートでグラフにします

486
00:30:28,695 --> 00:30:31,698
プロットテンプレートは
グラフ作成に最適です

487
00:30:32,065 --> 00:30:36,170
エレメントによって
パスされたカラムを―

488
00:30:36,303 --> 00:30:38,772
認識するのです

489
00:30:38,872 --> 00:30:43,177
そしてカラムの値に
固有のプロットを作ります

490
00:30:44,478 --> 00:30:50,083
Label formatエレメントで
プロットタイトルを作れます

491
00:30:50,217 --> 00:30:54,188
これがimgカラムと
画像名からの値です

492
00:30:55,455 --> 00:30:57,991
プロットの値として
画像名をパスします

493
00:30:58,659 --> 00:31:03,497
各図形は カラムの
インパクトに応じて色がつけらます

494
00:30:58,659 --> 00:31:03,497
各図形は カラムの
インパクトに応じて色がつけらます

495
00:31:04,198 --> 00:31:07,634
各図形のラベルは
画像の容量に関連します

496
00:31:09,303 --> 00:31:10,804
次はlistです

497
00:31:12,339 --> 00:31:15,742
tickの紹介で
お見せしました

498
00:31:16,810 --> 00:31:19,346
見たいカラムを
すべてパスします

499
00:31:21,448 --> 00:31:23,150
次はアグリゲーションです

500
00:31:23,617 --> 00:31:26,753
完了したダウンロードを
すべて追跡します

501
00:31:27,120 --> 00:31:31,625
テーブルには完了及び中止した
ダウンロードも含まれるので―

502
00:31:31,725 --> 00:31:35,295
データにフィルタをかける
sliceエレメントが必要です

503
00:31:35,929 --> 00:31:40,400
sliceエレメントで
カラムを特定し―

504
00:31:40,868 --> 00:31:43,670
合う値を断定します

505
00:31:43,804 --> 00:31:47,307
テーブルから
完了したローを拾います

506
00:31:48,208 --> 00:31:49,910
階層を定義します

507
00:31:50,310 --> 00:31:53,380
画像名と 可視化された
カラムがある―

508
00:31:54,314 --> 00:31:56,216
１つのレベルの階層です

509
00:31:56,783 --> 00:32:00,154
画像名ごとに
数や容量を特定します

510
00:31:56,783 --> 00:32:00,154
画像名ごとに
数や容量を特定します

511
00:32:01,155 --> 00:32:05,125
そして画像の容量を
合計します

512
00:32:07,094 --> 00:32:09,997
次にtime sliceです

513
00:32:10,364 --> 00:32:13,400
可視化されたカラムを
特定します

514
00:32:16,003 --> 00:32:21,241
Instrumentを
もっと簡単に使うため―

515
00:32:21,341 --> 00:32:23,811
カスタムテンプレートを
特定できます

516
00:32:25,379 --> 00:32:28,148
ではパッケージを実行します

517
00:32:34,321 --> 00:32:38,058
テンプレートが
表示されましたね

518
00:32:41,962 --> 00:32:44,865
iPhoneとTrailblazerを
対象にします

519
00:32:49,536 --> 00:32:51,638
レコードします

520
00:33:01,215 --> 00:33:05,319
TrackViewのデータが
増えたと分かります

521
00:33:06,520 --> 00:33:09,990
プロットは画像名ごとに
作成されます

522
00:33:11,258 --> 00:33:15,963
package definitionで
パスした書式と照合します

523
00:33:16,530 --> 00:33:20,701
ダウンロードが
3.5MBを超えたら―

524
00:33:20,801 --> 00:33:22,836
図形は赤色になります

525
00:33:23,470 --> 00:33:25,439
容量も表示されます

526
00:33:26,840 --> 00:33:29,877
では詳細を見てみましょう

527
00:33:32,679 --> 00:33:35,449
リストがあります

528
00:33:35,949 --> 00:33:39,319
ダウンロードした
すべてのデータです

529
00:33:40,621 --> 00:33:42,723
アグリゲーションを選びます

530
00:33:44,892 --> 00:33:48,395
画像名で
区分されています

531
00:33:48,495 --> 00:33:52,166
ダウンロードした
12の画像がトップにあります

532
00:33:53,600 --> 00:33:57,137
７番目の画像は
２回ダウンロードされました

533
00:33:59,540 --> 00:34:02,075
次はActive requestsです

534
00:33:59,540 --> 00:34:02,075
次はActive requestsです

535
00:34:03,744 --> 00:34:07,014
inspection headを
つかむと―

536
00:34:09,516 --> 00:34:13,152
ディテールビューの
データの数値が変化します

537
00:34:13,520 --> 00:34:16,489
多数のActive requestを
追跡でき―

538
00:34:16,590 --> 00:34:20,194
inspection headの
持続時間を確認できます

539
00:34:22,663 --> 00:34:27,967
異なった方法でのデータ
Storeやモデラを確認したい場合

540
00:34:28,068 --> 00:34:32,873
Instrument Inspectorで
次のようにしましょう

541
00:34:33,507 --> 00:34:36,310
カスタムinstrumentの
デバッグ方法です

542
00:34:36,944 --> 00:34:39,980
これはStoreの手順です

543
00:34:40,748 --> 00:34:44,251
os signpostのStoreが
作成されています

544
00:34:44,418 --> 00:34:47,121
ネットワークカテゴリと―

545
00:34:47,221 --> 00:34:49,889
com apple trailblazer
subsystemを認識してます

546
00:34:50,056 --> 00:34:52,492
ローの値は24ですね

547
00:34:53,159 --> 00:34:58,565
作成したテーブル画像では
ローは12です

548
00:35:02,035 --> 00:35:05,806
全コンテンツが
底部に表示されます

549
00:35:07,641 --> 00:35:09,376
次はモデラです

550
00:35:09,476 --> 00:35:13,180
自動生成するos log
モデラを確認できます

551
00:35:13,380 --> 00:35:17,251
24から12のローを
出力します

552
00:35:18,252 --> 00:35:21,188
binding solutionが
右に表示されます

553
00:35:21,455 --> 00:35:23,991
生成した
os logモデラは―

554
00:35:24,124 --> 00:35:28,562
os signpostテーブルから
データを移します

555
00:35:29,296 --> 00:35:32,065
その後 Instrumentで
使われます

556
00:35:33,867 --> 00:35:38,839
os signpostの呼び出しと
UIの作成―

557
00:35:38,939 --> 00:35:41,575
Instrument Inspectorで
使われたデータを見てきました

558
00:35:41,942 --> 00:35:46,079
ではチャドから
上級モデリングの紹介です

559
00:35:46,447 --> 00:35:53,086
(拍手)

560
00:35:54,655 --> 00:35:56,390
ありがとう

561
00:35:57,558 --> 00:36:00,460
os signpostと
カスタムinstrumentを―

562
00:35:57,558 --> 00:36:00,460
os signpostと
カスタムinstrumentを―

563
00:36:00,561 --> 00:36:03,564
結び付ける方法を
お見せしました

564
00:36:03,730 --> 00:36:07,134
この２つの組み合わせを―

565
00:36:07,234 --> 00:36:10,470
引き離すことができます

566
00:36:10,771 --> 00:36:14,875
少し上級のトピックを
お話しします

567
00:36:14,975 --> 00:36:18,645
モデラを作成し
定義する方法です

568
00:36:19,279 --> 00:36:23,083
入力を行う
シンプルなマシンです

569
00:36:23,183 --> 00:36:26,386
入力を論証し
出力を生みます

570
00:36:27,221 --> 00:36:30,457
入力は常に
完全な時間順です

571
00:36:30,691 --> 00:36:33,093
異なる要求をしても―

572
00:36:33,193 --> 00:36:37,464
最初のオーダーとなり
時間順に並びます

573
00:36:37,865 --> 00:36:39,600
ワーキングメモリを
供給します

574
00:36:39,800 --> 00:36:44,671
処理の１つ１つが
ワーキングメモリに入ります

575
00:36:45,138 --> 00:36:51,145
ワーキングメモリの展開から
モデラは推測します

576
00:36:51,345 --> 00:36:54,681
出力を生みだす
パターンを見て―

577
00:36:54,781 --> 00:36:57,484
出力テーブルに
書き込みます

578
00:36:58,819 --> 00:37:03,424
モデラの楽しい使い方を
ご紹介しましょう

579
00:36:58,819 --> 00:37:03,424
モデラの楽しい使い方を
ご紹介しましょう

580
00:37:04,224 --> 00:37:07,427
“マッチ遊び”の
スキーマを定義します

581
00:37:07,561 --> 00:37:10,764
os signpostインターバル
スキーマです

582
00:37:10,864 --> 00:37:16,403
危険な処理を行うことを
定義したos signpostが―

583
00:37:16,603 --> 00:37:17,671
対象です

584
00:37:18,238 --> 00:37:21,909
“アプリケーション炎上”の
スキーマも定義します

585
00:37:22,042 --> 00:37:25,913
これもsignpost
スキーマですが―

586
00:37:26,013 --> 00:37:29,850
状態が悪いことを意味します

587
00:37:30,517 --> 00:37:32,886
出力スキーマを作ります

588
00:37:32,986 --> 00:37:37,624
“マッチ遊び”オブジェクトと
炎上時間を記録します

589
00:37:37,858 --> 00:37:40,427
炎上開始スキーマを
呼び出します

590
00:37:41,662 --> 00:37:44,031
モデラは
このような感じです

591
00:37:44,131 --> 00:37:48,102
すべての入力を
時間順にすると―

592
00:37:48,202 --> 00:37:53,507
左の点線を
モデラクロックと呼びます

593
00:37:54,041 --> 00:37:57,978
メモリに最初の入力を
入れると

594
00:37:58,078 --> 00:38:00,647
モデラのクロックが
インターバルの最初の地点に移動し

595
00:37:58,078 --> 00:38:00,647
モデラのクロックが
インターバルの最初の地点に移動し

596
00:38:01,415 --> 00:38:03,851
次の入力をつかむと―

597
00:38:03,951 --> 00:38:08,222
またクロックが最初に戻り
ワーキングメモリに入れます

598
00:38:08,722 --> 00:38:12,392
モデラは
両方とも認識します

599
00:38:12,659 --> 00:38:13,694
“マッチ遊び”は

600
00:38:13,794 --> 00:38:16,864
アプリケーションの前に
すでに炎上しています

601
00:38:16,964 --> 00:38:21,034
アプリケーションが先に炎上し
順番が逆でも結果に大差ありません

602
00:38:21,335 --> 00:38:24,638
“炎上の原因”という
ロジカルな結論を―

603
00:38:25,272 --> 00:38:30,210
ワーキングメモリに
盛り込めます

604
00:38:31,578 --> 00:38:35,616
第３の入力をつかむと
クロックの動きが―

605
00:38:35,716 --> 00:38:39,086
２つの入力とは
交わらないと気づきます

606
00:38:39,419 --> 00:38:42,222
その２つはワーキングメモリから
削除されます

607
00:38:42,656 --> 00:38:46,126
“炎上の原因”に
logical supportがあれば―

608
00:38:46,260 --> 00:38:48,662
これも削除されます

609
00:38:50,764 --> 00:38:55,102
クロックの設定は入力時の
タイムスタンプです

610
00:38:55,469 --> 00:38:58,372
ワーキングメモリの中に
入力を残すために―

611
00:38:58,505 --> 00:39:02,576
モデラの現在のクロックは
交差します

612
00:38:58,505 --> 00:39:02,576
モデラの現在のクロックは
交差します

613
00:39:02,876 --> 00:39:07,281
こうして一致させ
古いデータを取り除きます

614
00:39:07,381 --> 00:39:12,085
そして入力が時間と
互換性があるかも分かります

615
00:39:13,821 --> 00:39:16,857
モデラがワーキングメモリを
論証する方法は―

616
00:39:16,957 --> 00:39:20,627
production systemで
定義します

617
00:39:21,461 --> 00:39:24,731
Production systemは ワーキング
メモリ内のファクトに基づき作動し

618
00:39:25,098 --> 00:39:30,671
オペレータの左辺と
右辺で定義されます

619
00:39:31,004 --> 00:39:36,810
左辺はルールを
アクティブにするパターンで―

620
00:39:37,177 --> 00:39:41,849
右辺はルールが集中した時に
起こるアクションです

621
00:39:41,949 --> 00:39:45,652
出力テーブルに
ローを加えます

622
00:39:45,752 --> 00:39:49,757
また モデリングプロセスの
進歩として―

623
00:39:49,890 --> 00:39:52,726
新たなファクトを
含めたりします

624
00:39:54,061 --> 00:39:56,797
ファクトのソースは２つです

625
00:39:56,930 --> 00:39:59,099
１つは
テーブル入力です

626
00:39:59,199 --> 00:40:01,802
先に説明したモデリングクロックの
ルールをファクトとして使用し―

627
00:39:59,199 --> 00:40:01,802
先に説明したモデリングクロックの
ルールをファクトとして使用し―

628
00:40:01,969 --> 00:40:05,005
自動的に組み込みます

629
00:40:05,639 --> 00:40:09,977
さらに 右辺プロダクションから
自動組み込みによって作られます

630
00:40:10,978 --> 00:40:13,547
自分のファクトを
作るなら―

631
00:40:13,647 --> 00:40:19,386
Clipsにファクトの構成を提供する
ファクトテンプレートがあります

632
00:40:20,020 --> 00:40:22,556
Clipsでルールを見てみます

633
00:40:23,123 --> 00:40:26,527
まず“原因”を見つけます

634
00:40:27,261 --> 00:40:29,096
解読します

635
00:40:29,196 --> 00:40:33,667
t1が“誰がマッチで遊ぶか”
というオブジェクトで―

636
00:40:34,001 --> 00:40:37,004
“アプリケーション炎上”が
t2

637
00:40:37,471 --> 00:40:40,841
t1がt2の前に
起きたとします

638
00:40:41,108 --> 00:40:44,278
すると“炎上の原因”
という―

639
00:40:44,411 --> 00:40:47,848
新たなファクトを
右辺に主張できます

640
00:40:48,082 --> 00:40:50,417
ワーキングメモリに入ります

641
00:40:51,051 --> 00:40:53,554
第２のルールは―

642
00:40:53,654 --> 00:40:55,556
“原因のレコード”です

643
00:40:55,889 --> 00:41:01,328
“アプリケーション炎上”が
あって原因が分かれば―

644
00:40:55,889 --> 00:41:01,328
“アプリケーション炎上”が
あって原因が分かれば―

645
00:41:01,461 --> 00:41:04,365
アペンド側を関連づける
テーブルがあります

646
00:41:04,465 --> 00:41:07,101
モデラの出力側です

647
00:41:07,468 --> 00:41:13,740
定義する“炎上開始”スキーマに
テーブルが該当すれば―

648
00:41:14,475 --> 00:41:17,311
テーブルにローを作れます

649
00:41:17,444 --> 00:41:22,449
そして炎上を起こした人と
時間を値に設定します

650
00:41:23,817 --> 00:41:28,088
さらに最初のエキスパート
システムを作って―

651
00:41:28,188 --> 00:41:31,759
２つのルールに沿って
悪いパターンを調べます

652
00:41:33,427 --> 00:41:38,665
モデラかレコーダに
ルールが付加されています

653
00:41:38,832 --> 00:41:43,136
これらは modules in Clipsといい
両グループのルールに従いつつ―

654
00:41:43,303 --> 00:41:46,073
実行順を制御したりします

655
00:41:46,373 --> 00:41:49,643
出力を維持した場合は―

656
00:41:49,743 --> 00:41:52,412
レコーダモジュールの中の
テーブル出力が

657
00:41:52,512 --> 00:41:54,415
新たに生成される出力を
ルールするので

658
00:41:54,615 --> 00:41:57,084
その場合 検証の途中で―

659
00:41:57,184 --> 00:42:02,055
出力を書こうとは
しないはず

660
00:41:57,184 --> 00:42:02,055
出力を書こうとは
しないはず

661
00:42:02,156 --> 00:42:07,961
モデラのルールの実行が
レコーダより先だからです

662
00:42:09,496 --> 00:42:12,399
logical supportの期間に
ついて説明します

663
00:42:12,666 --> 00:42:15,602
logical supportとは―

664
00:42:15,836 --> 00:42:17,938
推論規則に関連します

665
00:42:18,105 --> 00:42:21,942
“AとBならCだ”のような
ルールです

666
00:42:22,042 --> 00:42:26,413
logical supportを
加えたとします

667
00:42:26,613 --> 00:42:31,285
AとBがワーキングメモリに
存在しない場合―

668
00:42:31,385 --> 00:42:33,454
Cは自動的に削除されます

669
00:42:33,554 --> 00:42:38,659
つまりAとBがCを論理的に
裏付けています

670
00:42:39,259 --> 00:42:43,797
ワーキングメモリの膨張を
制限することと

671
00:42:43,897 --> 00:42:48,168
ワーキングメモリから無効な
ファクトを削除することが重要です

672
00:42:48,268 --> 00:42:51,905
AもBも無効なら
Cも削除されます

673
00:42:52,439 --> 00:42:56,543
logical supportを
加えるために―

674
00:42:56,844 --> 00:43:00,848
keyword logicalと一緒に
パターンをまとめ

675
00:42:56,844 --> 00:43:00,848
keyword logicalと一緒に
パターンをまとめ

676
00:43:00,948 --> 00:43:03,350
ルールの右辺に
示すものは―

677
00:43:03,450 --> 00:43:06,920
進行していくと
自動的に取り消されます

678
00:43:07,021 --> 00:43:10,924
そして
この２つのファクトは―

679
00:43:11,125 --> 00:43:14,495
スキーマにちなんだ名前です

680
00:43:14,661 --> 00:43:17,798
モデラのクロックが
動いたら―

681
00:43:17,931 --> 00:43:20,067
インプットは取り消されます

682
00:43:22,069 --> 00:43:26,173
モデラの作り方の基本を
知ったうえで―

683
00:43:26,273 --> 00:43:29,910
Clips言語とルールを
見てきました

684
00:43:30,043 --> 00:43:35,816
悪いパターンや誤用を
階層で見つけるため―

685
00:43:36,750 --> 00:43:38,986
エキスパートシステムを
ネットワークInstrumentsに

686
00:43:39,086 --> 00:43:41,488
追加できるか見てみます

687
00:43:41,588 --> 00:43:45,125
キャスパーから
最後の実演です

688
00:43:45,759 --> 00:43:51,031
(拍手)

689
00:43:54,868 --> 00:43:58,906
アンチパターンを
検出するため―

690
00:43:59,006 --> 00:44:02,309
既存のログで書き込みます

691
00:43:59,006 --> 00:44:02,309
既存のログで書き込みます

692
00:44:02,643 --> 00:44:04,845
Trailblazerを使用中―

693
00:44:04,945 --> 00:44:09,683
速くスクロールすると欠陥が
現れるように思えますが

694
00:44:09,817 --> 00:44:12,452
画像は何度も入れ替わり―

695
00:44:12,753 --> 00:44:16,423
取り消しが機能していない
可能性もあります

696
00:44:17,257 --> 00:44:20,360
検証のため
モデラに書き込みます

697
00:44:21,094 --> 00:44:25,232
package definitionを
見てみましょう

698
00:44:25,499 --> 00:44:28,235
モデラエレメントを書いて
始めます

699
00:44:28,502 --> 00:44:32,673
モデラは
ID タイトル 目的を持ちます

700
00:44:33,273 --> 00:44:36,610
ドキュメンテーションに
この３つの領域が引用されます

701
00:44:37,444 --> 00:44:40,013
モデラの
全ロジックを含む―

702
00:44:40,314 --> 00:44:43,183
生成システムの
パスを特定します

703
00:44:45,018 --> 00:44:47,788
ここで　モデラに
出力を定義します

704
00:44:47,955 --> 00:44:50,424
それは ダウンローダ
ナラティブスキーマです

705
00:44:50,824 --> 00:44:56,130
要求される入力は
os signpostテーブルです

706
00:44:56,497 --> 00:44:59,933
このテーブルは
beginとendを含みます

707
00:45:00,801 --> 00:45:05,339
ダウンローダスキーマの
定義を見ましょう

708
00:45:11,345 --> 00:45:15,115
２つのカラムとタイムスタンプを
定義づけるポイントスキーマです

709
00:45:15,449 --> 00:45:18,785
タイムスタンプは診断メッセージの
ログの時間を追跡し

710
00:45:20,120 --> 00:45:24,157
何が誤作動したか説明します

711
00:45:26,393 --> 00:45:30,264
そこで テーブルに
Instrument定義を制作します

712
00:45:31,999 --> 00:45:36,637
ダウンローダスキーマと
ユニークIDをパスします

713
00:45:38,138 --> 00:45:42,376
ここで ナラティブ
エレメント定義を使います

714
00:45:44,745 --> 00:45:46,480
はい ナラティブが
定義できました

715
00:45:46,580 --> 00:45:50,317
すでに作成した
テーブルrefをパスし

716
00:45:51,018 --> 00:45:54,154
タイムカラムと
ナラティブカラムを定義します

717
00:45:55,856 --> 00:45:59,126
これでモデラのロジックを
定義できます

718
00:46:00,160 --> 00:46:04,965
モデラ定義で
参照したファイルを作ります

719
00:46:05,466 --> 00:46:09,036
Clipsファイルを作るには
“File”から“New”を選び―

720
00:46:11,605 --> 00:46:13,507
macOSのプラットフォームを
選択します

721
00:46:14,508 --> 00:46:17,010
“Clips file”をクリック

722
00:46:19,213 --> 00:46:21,014
名前を入力し―

723
00:46:24,184 --> 00:46:25,419
作成します

724
00:46:27,854 --> 00:46:31,091
１つ以上のリクエストが
同時に同一セルで

725
00:46:31,191 --> 00:46:33,126
実行されてるか
検出するアルゴリズムは

726
00:46:33,227 --> 00:46:34,395
次のとおりです

727
00:46:34,962 --> 00:46:38,932
ワーキングメモリの要求を
すべて追跡します

728
00:46:39,366 --> 00:46:42,669
最初にファクトの
テンプレートを作ります

729
00:46:45,038 --> 00:46:48,542
時間やセルのアドレスに―

730
00:46:48,875 --> 00:46:51,211
取り込んだsignpost ID

731
00:46:52,112 --> 00:46:54,515
要求した画像名など―

732
00:46:55,115 --> 00:46:57,551
ファクトに保管されています

733
00:46:57,784 --> 00:47:00,154
ここでは“ダウンロード開始”の
ファクトと呼びます

734
00:46:57,784 --> 00:47:00,154
ここでは“ダウンロード開始”の
ファクトと呼びます

735
00:47:01,321 --> 00:47:06,293
次にモデラのルールを
書き込みます

736
00:47:09,163 --> 00:47:12,232
これはos signpostを
認識します

737
00:47:12,466 --> 00:47:16,670
サブシステム 名前
イベントタイプを特定し

738
00:47:17,271 --> 00:47:20,708
欲しい情報すべてを特定し
取り込みます

739
00:47:21,041 --> 00:47:26,046
画像名 callerアドレス 時間
signpost IDを取り込みます

740
00:47:27,114 --> 00:47:30,317
ここで 新たなファクトを
ワーキングメモリに明示します

741
00:47:34,288 --> 00:47:38,225
ダウンロード後
クリーンにするため―

742
00:47:38,392 --> 00:47:41,128
ワーキングメモリから
このファクトを消す必要があります

743
00:47:44,465 --> 00:47:46,667
同じテーブルですが―

744
00:47:46,767 --> 00:47:52,005
endのイベントのみ
見ています

745
00:47:52,773 --> 00:47:55,142
signpost IDを取り込みます

746
00:47:55,642 --> 00:47:59,747
signpostのbeginとendは
同じIDだというファクトを

747
00:47:59,847 --> 00:48:02,015
ここで使っています

748
00:47:59,847 --> 00:48:02,015
ここで使っています

749
00:48:02,616 --> 00:48:05,752
signpost IDを持つ
ファクトを―

750
00:48:05,853 --> 00:48:08,989
ワーキングメモリで探します

751
00:48:09,389 --> 00:48:10,958
そして消します

752
00:48:14,395 --> 00:48:16,897
ナラティブデータを
生成する―

753
00:48:16,997 --> 00:48:20,601
レコーダルールを
書き込みます

754
00:48:24,438 --> 00:48:28,442
レコーダルールはスタンダード
ダウンロードファクト全部を認識し

755
00:48:28,642 --> 00:48:30,277
それを取り込みます

756
00:48:30,544 --> 00:48:34,348
時間 callerアドレス
画像名を取り込みました

757
00:48:34,681 --> 00:48:38,819
同じcallerアドレスを持つ
別の標準ダウンロードがある場合

758
00:48:38,919 --> 00:48:44,291
変数は同じで最初の
ファクトの前に発生したと

759
00:48:45,859 --> 00:48:49,029
気づくことができます

760
00:48:49,530 --> 00:48:53,901
アンチパターンや
重複リクエストがあります

761
00:48:54,635 --> 00:48:58,639
ダウンローダナラティブスキーマに
アクセスできるか確認し―

762
00:49:00,474 --> 00:49:01,975
新しいローを作ります

763
00:49:03,477 --> 00:49:07,614
最初のファクトの時間に
時刻カラムを設定し―

764
00:49:08,448 --> 00:49:10,450
ナラティブ記述を設定します

765
00:49:10,951 --> 00:49:17,458
後でデバッグできるよう
問題に関する情報を出力します

766
00:49:19,359 --> 00:49:22,262
ではInstrumentを実行します

767
00:49:24,264 --> 00:49:25,766
これで実行です

768
00:49:32,406 --> 00:49:35,108
Trailblazerネットワークを
テンプレートから選び―

769
00:49:37,511 --> 00:49:38,479
レコードします

770
00:49:40,047 --> 00:49:42,916
下まで速く
スクロールして―

771
00:49:43,450 --> 00:49:45,786
ナラティブテーブルを見ます

772
00:49:50,023 --> 00:49:55,329
多くのメッセージが
出力されています

773
00:49:55,896 --> 00:50:00,267
問題を確認して
調べることができます

774
00:49:55,896 --> 00:50:00,267
問題を確認して
調べることができます

775
00:50:00,734 --> 00:50:04,505
ナラティブは
インタラクティブの詳細です

776
00:50:04,771 --> 00:50:09,243
パスしたargumentを確認して
フィルタをかけられます

777
00:50:09,343 --> 00:50:13,380
このcallerアドレスを
詳細として加えて―

778
00:50:13,514 --> 00:50:16,083
詳細フィルタができます

779
00:50:17,384 --> 00:50:19,787
ではInstruments開発の―

780
00:50:19,887 --> 00:50:23,757
ベストプラクティスを
チャドが紹介します

781
00:50:24,324 --> 00:50:30,197
(拍手)

782
00:50:30,364 --> 00:50:31,598
ありがとう キャスパー

783
00:50:32,065 --> 00:50:35,068
Instrumentの中の
エキスパートシステムについて―

784
00:50:35,202 --> 00:50:38,072
基本の作り方を見てきました

785
00:50:38,605 --> 00:50:43,243
途中でも触れた
ベストプラクティスの話です

786
00:50:44,177 --> 00:50:47,981
まずInstrumentを
１つ以上書くこと

787
00:50:48,115 --> 00:50:50,417
練習を積むのでは
ありません

788
00:50:50,684 --> 00:50:54,121
すでにInstrumentを持っていても
それに新しい機能を追加したい場合

789
00:50:54,221 --> 00:50:58,559
単純にそれを追加したり
余計なグラフや詳細を足すでしょう

790
00:50:58,826 --> 00:51:01,962
でも それでいいか
考えてください

791
00:50:58,826 --> 00:51:01,962
でも それでいいか
考えてください

792
00:51:02,129 --> 00:51:05,332
きめ細かい
Instrumentなら―

793
00:51:05,432 --> 00:51:08,869
ユーザに選択肢を多く
提供できます

794
00:51:09,136 --> 00:51:12,306
欲しいInstrumentを
ライブラリにドラッグできてー

795
00:51:12,539 --> 00:51:15,642
ターゲットに対する
記録影響が最小限です

796
00:51:15,742 --> 00:51:20,280
多機能の１つのInstrumentは
全能か無能かのどちらかです

797
00:51:20,881 --> 00:51:23,917
もし Instrumentに―

798
00:51:24,017 --> 00:51:26,420
複数のInstrumentの
同じ問題に対して

799
00:51:26,520 --> 00:51:28,589
ターゲットを絞ったものを
組み合わせて作りたいなら

800
00:51:28,689 --> 00:51:31,892
全機能のものを
同時に使うよりは

801
00:51:32,226 --> 00:51:36,263
問題ごとにカスタムテンプレートを
作るほうがよいでしょう

802
00:51:36,597 --> 00:51:42,403
ドキュメントを作り
Instrumentをドラッグして設定し

803
00:51:42,503 --> 00:51:45,472
テンプレートとして
保存します

804
00:51:45,572 --> 00:51:50,210
キャスパーがネットワーク
テンプレートに追加した要素は―

805
00:51:50,310 --> 00:51:52,579
パッケージ内で使用できます

806
00:51:53,080 --> 00:51:56,817
１つ以上のInstrumentを書くのは
ツールを使う際 よりよい方法です

807
00:51:57,951 --> 00:52:00,954
２つ目の方法は大変です

808
00:51:57,951 --> 00:52:00,954
２つ目の方法は大変です

809
00:52:01,121 --> 00:52:04,725
immediate modeは
レコード形式で―

810
00:52:04,825 --> 00:52:09,730
ほぼリアルタイムで
データを可視化します

811
00:52:09,897 --> 00:52:12,666
大変な理由は２つあります

812
00:52:12,766 --> 00:52:15,636
まずは追加でサポートが
必要なこと

813
00:52:15,802 --> 00:52:19,606
時間が足りず
当日中に対応できません

814
00:52:19,873 --> 00:52:22,075
今 取り組んでいます

815
00:52:22,309 --> 00:52:25,412
そして重要な
２つ目の理由は―

816
00:52:26,080 --> 00:52:28,882
インターバルデータです

817
00:52:28,982 --> 00:52:33,320
Analysis Coreでは
beginとendを見れば―

818
00:52:33,420 --> 00:52:36,557
インターバルデータは それが
閉じるまではテーブルに入りません

819
00:52:36,657 --> 00:52:40,694
でも実演していると多くの
インターバルができます

820
00:52:40,794 --> 00:52:44,865
モデラが 実行可能な
出力として要求すれば

821
00:52:44,998 --> 00:52:48,535
upstreamにインターバルが
あると―

822
00:52:48,635 --> 00:52:50,804
インターバルが閉じるまで
全モデラクロックの

823
00:52:50,904 --> 00:52:53,307
ダウンストリームを
停止する必要があります

824
00:52:53,407 --> 00:52:56,844
モデラは時間順だからです

825
00:52:56,944 --> 00:53:01,682
インターバルのアップストリームが
閉じるまでクロックは動かせません

826
00:52:56,944 --> 00:53:01,682
インターバルのアップストリームが
閉じるまでクロックは動かせません

827
00:53:01,915 --> 00:53:05,786
長い区間でインターバルが
できていたら―

828
00:53:05,886 --> 00:53:08,655
出力は止まります

829
00:53:08,889 --> 00:53:12,659
ユーザが
レコード停止を押せば―

830
00:53:12,760 --> 00:53:17,331
インターバルは閉じ
元どおりにデータが入ります

831
00:53:17,498 --> 00:53:19,166
でも好ましくありません

832
00:53:19,333 --> 00:53:22,202
ディベロッパには
２つの選択肢があります

833
00:53:22,302 --> 00:53:26,573
Instrumentに
制限の要素を追加し―

834
00:53:26,673 --> 00:53:30,077
immediate modeで
サポートを選ぶこと

835
00:53:30,744 --> 00:53:36,216
もう１つは先ほどエキスパート
システムで実演したのと同じように

836
00:53:36,350 --> 00:53:39,720
モデラから出力として
インターバルデータを離す方法

837
00:53:39,820 --> 00:53:42,356
私たちは実際
インターバルよりも

838
00:53:42,456 --> 00:53:45,058
os signpost pointの
イベントを使います

839
00:53:45,158 --> 00:53:47,161
簡単に見えますが―

840
00:53:47,261 --> 00:53:50,330
immediateモードは
実装する時に注意が必要です

841
00:53:51,398 --> 00:53:53,901
３つ目の重要な点は―

842
00:53:54,034 --> 00:53:58,706
大量の入力データを
ターゲットしたInstrumentを作る時

843
00:53:58,906 --> 00:54:04,111
プリレコードタイムが
５秒モードのものが効率的です

844
00:53:58,906 --> 00:54:04,111
プリレコードタイムが
５秒モードのものが効率的です

845
00:54:04,211 --> 00:54:05,579
traceドキュメントに―

846
00:54:05,679 --> 00:54:08,215
レコード形式の
オプションを切り替える方法は

847
00:54:08,315 --> 00:54:12,853
immediateと deferredと
last end secondsモードです

848
00:54:13,153 --> 00:54:14,988
なぜ効率的なのか

849
00:54:15,088 --> 00:54:18,125
レコーディング技術が
バッファリングを使用し―

850
00:54:18,225 --> 00:54:20,294
パフォーマンスを改善するので

851
00:54:20,394 --> 00:54:23,163
データをInstrumentsから
リアルタイムで消費しないからです

852
00:54:23,263 --> 00:54:25,966
signpostデータには
大きな効果があり―

853
00:54:26,066 --> 00:54:31,872
最新の５秒のデータしか
見られませんが

854
00:54:32,139 --> 00:54:36,076
５秒モードでは
10倍もの速度で処理可能です

855
00:54:36,176 --> 00:54:41,248
Instrumentが生成する大量の
データの処理にはもってこいです

856
00:54:41,348 --> 00:54:43,684
System Traceや
Metal System Trace

857
00:54:43,784 --> 00:54:47,054
そしてゲームパフォーマンス
テンプレートでは一般的ですが

858
00:54:47,154 --> 00:54:49,723
このようなアプリケーションを
ターゲットとする場合―

859
00:54:49,823 --> 00:54:53,293
immediate modeは
選びません

860
00:54:53,394 --> 00:54:58,766
ユーザやInstrumentsに
問題はなく―

861
00:54:58,866 --> 00:55:01,101
データ取得やインターバルの
問題でもありません

862
00:54:58,866 --> 00:55:01,101
データ取得やインターバルの
問題でもありません

863
00:55:02,836 --> 00:55:04,671
終了の時間です

864
00:55:04,771 --> 00:55:06,840
多くのワークを経て―

865
00:55:07,041 --> 00:55:12,513
皆さんと分かち合えたことが
最高の喜びです

866
00:55:12,613 --> 00:55:16,116
皆さんの製品を見るのが
待ち遠しいです

867
00:55:16,450 --> 00:55:19,853
私たちと直接
話したい方は―

868
00:55:19,953 --> 00:55:23,223
３時に８番ラボへ
お越しください

869
00:55:23,323 --> 00:55:29,229
os signpost APIの使い方は
405セッションで紹介します

870
00:55:29,730 --> 00:55:30,931
楽しんでください

871
00:55:31,265 --> 00:55:35,536
(拍手)