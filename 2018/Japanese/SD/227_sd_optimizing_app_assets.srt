
1
00:00:07,140 --> 00:00:16,583
(音楽)

2
00:00:18,519 --> 00:00:25,225
(拍手)

3
00:00:25,325 --> 00:00:26,326
こんにちは

4
00:00:26,426 --> 00:00:28,729
Optimizing App Assetsへ
ようこそ

5
00:00:28,929 --> 00:00:31,832
Cocoaフレームワーク
エンジニアのウィルです

6
00:00:31,932 --> 00:00:34,801
今日は同僚のパトリックと

7
00:00:34,935 --> 00:00:39,506
アセットの最適化について
お話しします

8
00:00:41,608 --> 00:00:46,280
現在 多くのアプリケーションに
高品質のアセットが使われ

9
00:00:46,380 --> 00:00:50,717
すばらしいユーザ体験を
生み出しています

10
00:00:50,817 --> 00:00:56,690
アセットの活用で多くの人を
惹き付けているのです

11
00:00:56,857 --> 00:01:01,361
皆さんの役に立てるよう
今日はいくつかお話しします

12
00:00:56,857 --> 00:01:01,361
皆さんの役に立てるよう
今日はいくつかお話しします

13
00:01:01,528 --> 00:01:06,200
アセットカタログの
ベストプラクティスや―

14
00:01:06,333 --> 00:01:10,037
アセットのより効率的な
配備方法

15
00:01:10,137 --> 00:01:13,207
そして ユーザ体験を
向上させる方法です

16
00:01:15,209 --> 00:01:20,214
話の中で 基本的な
デザインや開発 配備など

17
00:01:20,314 --> 00:01:24,418
ワークフローの各工程に
触れていきます

18
00:01:24,785 --> 00:01:29,623
その中で
まず私がお話ししたいトピックは

19
00:01:30,090 --> 00:01:31,925
画像の圧縮です

20
00:01:34,461 --> 00:01:37,831
画像圧縮は
アセットカタログエディタの核です

21
00:01:39,066 --> 00:01:42,669
そしてコンパイル作業の
最終工程で

22
00:01:42,970 --> 00:01:47,841
他の工程の最適化にも
大きく関係します

23
00:01:49,376 --> 00:01:55,249
アセットカタログにはデフォルトで
様々な圧縮タイプがあります

24
00:01:55,649 --> 00:01:59,486
また使用する画像やテクスチャに

25
00:01:59,586 --> 00:02:02,489
最適な圧縮タイプを選べます

26
00:01:59,586 --> 00:02:02,489
最適な圧縮タイプを選べます

27
00:02:03,423 --> 00:02:05,993
これで十分とも言えますが

28
00:02:06,226 --> 00:02:10,364
すべてのオプションを知ることも
大切です

29
00:02:10,464 --> 00:02:13,667
さらにトレードオフや
プロジェクトへの影響を

30
00:02:13,767 --> 00:02:16,537
理解した方がいいでしょう

31
00:02:19,206 --> 00:02:23,410
さて画像圧縮の詳しい話を
進める前に

32
00:02:23,644 --> 00:02:28,115
アセットカタログの
もう１つの最適化の話をします

33
00:02:28,315 --> 00:02:31,852
その機能は
すべての圧縮に関連するもので

34
00:02:32,252 --> 00:02:34,288
Automatic Image Packing
といいます

35
00:02:37,891 --> 00:02:44,198
アセットカタログが導入される前は
アセットを配備するのに

36
00:02:44,298 --> 00:02:48,468
大量の画像ファイルを
ただ入れ込むだけでした

37
00:02:49,269 --> 00:02:53,740
注意すべき点は
この方法には多くの欠点と

38
00:02:53,841 --> 00:02:55,442
トレードオフがある点です

39
00:02:56,009 --> 00:03:00,380
まず２つの欠点を
覚えておいてください

40
00:02:56,009 --> 00:03:00,380
まず２つの欠点を
覚えておいてください

41
00:03:00,714 --> 00:03:05,853
１つはディスク容量が
追加で必要なことです

42
00:03:06,854 --> 00:03:09,656
従来の画像コンテナの
フォーマットは

43
00:03:10,123 --> 00:03:14,261
メタデータの保存に
余分な容量を必要とします

44
00:03:14,595 --> 00:03:16,763
画像の属性も同様です

45
00:03:17,564 --> 00:03:22,870
アプリケーションに膨大な数の
アセットとメタデータがある場合

46
00:03:23,003 --> 00:03:27,641
意味もなく同じ情報が
二重に保存されます

47
00:03:28,742 --> 00:03:32,813
それにアセットの大半が
小さい場合は

48
00:03:33,180 --> 00:03:36,483
画像圧縮の利点が
あまり生かされません

49
00:03:38,118 --> 00:03:43,690
もう１つの欠点は
構成上のオーバーヘッドです

50
00:03:44,358 --> 00:03:47,828
未整理の画像ファイルは
作業が大変です

51
00:03:48,428 --> 00:03:51,331
それをNSImageや
UIImageなどで処理するのは

52
00:03:51,431 --> 00:03:54,701
さらに大変なことです

53
00:03:55,736 --> 00:04:00,474
しかも統一されていない
フォーマットや―

54
00:03:55,736 --> 00:04:00,474
しかも統一されていない
フォーマットや―

55
00:04:00,574 --> 00:04:03,911
属性を扱う必要性が生じます

56
00:04:04,478 --> 00:04:06,713
例えばアートワークに

57
00:04:06,813 --> 00:04:11,852
透過性の画像とそうでないものが
混在するなどです

58
00:04:12,819 --> 00:04:17,124
同じことが
色空間と色域にも当てはまります

59
00:04:19,358 --> 00:04:22,162
アセットカタログは
すべて解決できます

60
00:04:22,262 --> 00:04:26,533
同じスペクトルの
カラープロファイルを持つ画像を

61
00:04:26,633 --> 00:04:30,437
グループ化し より大きな
画像のアトラスを作ります

62
00:04:31,104 --> 00:04:36,643
そうすれば同じメタデータを
何度も保存せずに済むのです

63
00:04:37,177 --> 00:04:41,448
また画像圧縮の利点を
より生かせます

64
00:04:42,683 --> 00:04:45,986
では実際の例を見ていきましょう

65
00:04:48,522 --> 00:04:52,392
左側に12個の
アートワークがあります

66
00:04:52,960 --> 00:04:58,298
我々のプラットフォームで
見たことがあるでしょう

67
00:04:59,266 --> 00:05:01,869
それぞれは小さいですが

68
00:04:59,266 --> 00:05:01,869
それぞれは小さいですが

69
00:05:02,402 --> 00:05:06,940
全体のサイズは50KBを超えます

70
00:05:10,210 --> 00:05:11,912
そこで
Automatic Image Packingです

71
00:05:12,379 --> 00:05:18,051
アセットカタログはこれらの画像が
よく似たスペクトルだと識別

72
00:05:18,519 --> 00:05:23,624
そしてグループ化し
１つの画像アトラスを生成します

73
00:05:24,825 --> 00:05:25,859
この方法では―

74
00:05:26,960 --> 00:05:32,733
全体のディスク容量が
元々のわずか20％に下がります

75
00:05:33,033 --> 00:05:36,703
つまり80％もサイズを減らせました

76
00:05:37,838 --> 00:05:42,209
この最適化の割合を把握することも
重要です

77
00:05:42,409 --> 00:05:46,313
アプリケーションの
アセットの数が増えるほど

78
00:05:46,580 --> 00:05:49,416
最適化の恩恵も大きくなります

79
00:05:52,486 --> 00:05:54,488
Automatic Image Packingでした

80
00:05:56,423 --> 00:05:59,426
次はロッシー圧縮の話をします

81
00:06:01,295 --> 00:06:06,266
これは画像の解像度を
少し落とす代わりに

82
00:06:06,433 --> 00:06:10,604
高い圧縮率を実現する方法です

83
00:06:11,171 --> 00:06:15,275
ロッシー圧縮を使用すべきかは

84
00:06:15,375 --> 00:06:17,945
アプリケーションの状態によります

85
00:06:19,479 --> 00:06:23,217
通常 スクリーン表示時間が短い
アートワークには

86
00:06:23,450 --> 00:06:26,553
ロッシー圧縮を推奨します

87
00:06:27,688 --> 00:06:31,658
例えばアプリケーションの
スプラッシュ画面や

88
00:06:32,125 --> 00:06:34,294
アニメーションや効果に
使う画像です

89
00:06:35,996 --> 00:06:39,900
これからご紹介するのは
アセットカタログの

90
00:06:40,334 --> 00:06:43,303
新しいロッシー圧縮です

91
00:06:43,937 --> 00:06:48,876
それは 今年サポートを
拡大することになるHEIF

92
00:06:49,009 --> 00:06:52,513
ハイ･エフィシエンシー･イメージ･
ファイル･フォーマットです

93
00:06:54,348 --> 00:06:57,050
昨年の発表を見た方は

94
00:06:57,217 --> 00:07:00,888
HEIFフォーマットの導入を
ご存知ですね

95
00:06:57,217 --> 00:07:00,888
HEIFフォーマットの導入を
ご存知ですね

96
00:07:01,021 --> 00:07:05,492
すべてのプラットフォームと
アセットカタログに採用しました

97
00:07:06,460 --> 00:07:09,096
今年はもう１歩前進します

98
00:07:09,196 --> 00:07:14,968
アセットカタログに
HEIFのロッシー圧縮を追加します

99
00:07:18,472 --> 00:07:21,675
(拍手)

100
00:07:21,775 --> 00:07:22,509
どうも

101
00:07:23,677 --> 00:07:29,249
では HEIFの長所を
手短にお話ししましょう

102
00:07:30,684 --> 00:07:34,922
最大の利点は
従来のロッシー圧縮に比べ

103
00:07:35,255 --> 00:07:39,359
HEIFの圧縮率は非常に高いことです

104
00:07:39,893 --> 00:07:43,964
従来のフォーマットとは
JPEGなどです

105
00:07:45,165 --> 00:07:48,235
他にも多くの長所があります

106
00:07:48,335 --> 00:07:52,406
すぐに使える透過性の
サポートなどです

107
00:07:53,841 --> 00:07:57,044
もっと重要な特徴もあります

108
00:07:57,377 --> 00:08:01,949
アセットカタログは
他のフォーマットの画像ファイルを

109
00:07:57,377 --> 00:08:01,949
アセットカタログは
他のフォーマットの画像ファイルを

110
00:08:02,149 --> 00:08:04,585
自動でHEIFに変換できます

111
00:08:05,018 --> 00:08:09,523
つまり画像アセットを
ロッシー圧縮にひも付けておけば

112
00:08:09,690 --> 00:08:14,394
開発側は
他に何もしなくていいのです

113
00:08:14,528 --> 00:08:18,999
コンパイル時にすべて自動で
行われます

114
00:08:20,667 --> 00:08:24,371
HEIFフォーマットの詳しい情報は

115
00:08:24,471 --> 00:08:27,508
昨年のセッションを参照ください

116
00:08:31,612 --> 00:08:34,815
ではロスレス圧縮の話に移ります

117
00:08:35,549 --> 00:08:38,684
これはデフォルトの圧縮タイプで

118
00:08:38,784 --> 00:08:41,855
アセットの大半に使われています

119
00:08:43,056 --> 00:08:48,595
ですからロスレス圧縮の最適化は
非常に重要です

120
00:08:51,498 --> 00:08:55,736
通常 アートワークは
カラースペクトルのプロファイルで

121
00:08:55,836 --> 00:08:58,172
２つのグループに分類されます

122
00:08:58,772 --> 00:09:03,544
ロスレス圧縮によるメリットは
それぞれ異なります

123
00:08:58,772 --> 00:09:03,544
ロスレス圧縮によるメリットは
それぞれ異なります

124
00:09:04,178 --> 00:09:05,546
見てみましょう

125
00:09:08,115 --> 00:09:12,619
１種類目はいわゆる
単純なアートワークです

126
00:09:13,587 --> 00:09:15,622
単純とされる理由は―

127
00:09:16,390 --> 00:09:19,059
カラースペクトルの範囲が狭いこと

128
00:09:19,159 --> 00:09:22,329
そして個別のカラー値が
小さいことです

129
00:09:23,464 --> 00:09:26,200
シンプルなデザインだからです

130
00:09:26,333 --> 00:09:29,469
多くのアイコンがこのタイプです

131
00:09:31,171 --> 00:09:36,543
もう一方のタイプはいわゆる
複雑なアートワークです

132
00:09:37,845 --> 00:09:43,083
前述のとおり ロスレス圧縮の
利点は各タイプで異なります

133
00:09:43,183 --> 00:09:47,855
両タイプともロスレス圧縮に
適しているため

134
00:09:47,955 --> 00:09:49,690
非常に効果的です

135
00:09:50,958 --> 00:09:55,562
我々はこの両方が重要だと
気付きました

136
00:09:56,129 --> 00:09:58,699
それに すべてのアセットを

137
00:09:58,799 --> 00:10:02,169
最高のロスレス圧縮で配備したい

138
00:09:58,799 --> 00:10:02,169
最高のロスレス圧縮で配備したい

139
00:10:03,070 --> 00:10:05,405
そこで新機能を追加しました

140
00:10:05,572 --> 00:10:09,810
アセットカタログの
新しいロスレス圧縮です

141
00:10:11,278 --> 00:10:14,681
その名はApple Deep Pixel
Image Compressionです

142
00:10:17,518 --> 00:10:21,989
(拍手)

143
00:10:22,089 --> 00:10:23,223
ありがとう

144
00:10:24,658 --> 00:10:28,862
この新機能は
カラースペクトルに適応する―

145
00:10:28,962 --> 00:10:31,598
フレキシブルな圧縮です

146
00:10:32,533 --> 00:10:36,203
カラースペクトルの特質に合わせ

147
00:10:36,303 --> 00:10:41,174
最適な圧縮アルゴリズムが
選択されるのです

148
00:10:42,376 --> 00:10:47,514
今年発表のこの新しい圧縮は
皆さんだけでなく

149
00:10:47,614 --> 00:10:51,919
我々のすべてのプラットフォームと
アプリケーションでも利用可能です

150
00:10:53,253 --> 00:10:56,423
これにより既存の全プロジェクトで

151
00:10:56,523 --> 00:11:01,161
平均20％のサイズ縮小が
可能になりました

152
00:10:56,523 --> 00:11:01,161
平均20％のサイズ縮小が
可能になりました

153
00:11:01,995 --> 00:11:03,497
大きな改良です

154
00:11:03,597 --> 00:11:07,367
(拍手)

155
00:11:08,869 --> 00:11:12,239
では数字を見てみましょう

156
00:11:15,008 --> 00:11:19,680
この表は各プラットフォームの
アセットカタログの

157
00:11:19,880 --> 00:11:22,649
全体のサイズを示しています

158
00:11:23,851 --> 00:11:26,653
すべてのプラットフォームで

159
00:11:26,753 --> 00:11:31,225
最大20％も
サイズが削減されていますね

160
00:11:35,829 --> 00:11:40,868
ロスレス圧縮で重要なのは
圧縮率だけではありません

161
00:11:41,335 --> 00:11:46,740
大半のアプリケーションで
使用されているため

162
00:11:47,007 --> 00:11:49,910
デコード時間も同様に大事です

163
00:11:50,577 --> 00:11:52,713
Apple Deep Pixel
Image Compressionは

164
00:11:52,946 --> 00:11:57,718
デコード時間も
最大20％短縮できます

165
00:12:02,723 --> 00:12:04,958
以上がロスレス圧縮でした

166
00:12:05,826 --> 00:12:09,696
今から
２つのトピックについて話します

167
00:12:09,797 --> 00:12:12,799
互いに関連するものです

168
00:12:13,400 --> 00:12:18,305
先ほど話した最適化と圧縮にも
大きく関連します

169
00:12:19,540 --> 00:12:22,042
それは配備とApp Thinningです

170
00:12:25,612 --> 00:12:28,182
まずはApp Thinningの概要です

171
00:12:28,549 --> 00:12:31,518
App Thinningは
App Store内のプロセスです

172
00:12:31,618 --> 00:12:35,989
全デバイスモデルと
配備ターゲットのバージョンに

173
00:12:36,123 --> 00:12:39,393
プロジェクトのバリアントを
生成します

174
00:12:41,195 --> 00:12:45,065
App Thinningが有効な時とは？

175
00:12:45,566 --> 00:12:50,204
それはアプリケーションの
配備ターゲットのバージョンが

176
00:12:50,437 --> 00:12:53,073
最新ではない場合です

177
00:12:53,674 --> 00:12:56,944
そうすれば
幅広く利用されるからです

178
00:12:58,479 --> 00:13:04,084
App Thinningは
すべてのバリアントを自動で生成し

179
00:12:58,479 --> 00:13:04,084
App Thinningは
すべてのバリアントを自動で生成し

180
00:13:04,184 --> 00:13:08,956
各ユーザに最適なものを
配備できます

181
00:13:10,591 --> 00:13:16,363
今年 Xcode 10と
iOS 12用のSDKで開発すれば

182
00:13:16,697 --> 00:13:22,703
自動的にあらゆる最適化と
最新の圧縮機能が利用できます

183
00:13:24,138 --> 00:13:29,343
しかし以前のバージョンを
配備ターゲットとする際は

184
00:13:30,644 --> 00:13:34,481
最新の最適化は適用されません

185
00:13:35,682 --> 00:13:39,653
旧バージョンと
互換性のあるバリアントを

186
00:13:39,753 --> 00:13:42,656
生成する必要があるからです

187
00:13:44,625 --> 00:13:49,363
しかし私たちはアセットを
最適な方法で配備したいので

188
00:13:49,463 --> 00:13:52,533
これは理想的ではありません

189
00:13:53,100 --> 00:13:58,305
そこで今年はApp Thinningの
新バージョンを発表します

190
00:13:58,405 --> 00:14:00,140
OS Variant Thinningです

191
00:13:58,405 --> 00:14:00,140
OS Variant Thinningです

192
00:14:02,276 --> 00:14:03,911
OS Variant Thinningでも

193
00:14:05,579 --> 00:14:11,752
古いプラットフォームを
配備ターゲットにできます

194
00:14:12,052 --> 00:14:15,589
例えばiOS 9からiOS 11です

195
00:14:17,090 --> 00:14:20,093
OS Variant Thinningは
最新のiOSに

196
00:14:20,494 --> 00:14:24,231
特別なバリアントを生成します

197
00:14:24,464 --> 00:14:27,968
そして最新の最適化と圧縮機能が
使えるのです

198
00:14:28,602 --> 00:14:33,941
つまり最も効率の良いバージョンを
みんなが利用でき

199
00:14:34,341 --> 00:14:35,742
みんなが満足できます

200
00:14:39,046 --> 00:14:42,883
(拍手)

201
00:14:43,684 --> 00:14:46,086
App Thinningと逆行の配備でした

202
00:14:47,287 --> 00:14:50,791
次はXcode上で
App Thinningを使い

203
00:14:50,891 --> 00:14:55,262
ローカルにエクスポートする方法を
ご説明します

204
00:14:56,663 --> 00:14:58,632
やり方は簡単です

205
00:14:58,966 --> 00:15:03,103
Xcodeの“Archive”を
選ぶだけです

206
00:14:58,966 --> 00:15:03,103
Xcodeの“Archive”を
選ぶだけです

207
00:15:03,937 --> 00:15:07,908
これでXcodeが
バリアントを生成できます

208
00:15:10,244 --> 00:15:14,615
次に“Organizer”を
クリックしてください

209
00:15:14,715 --> 00:15:19,620
すると生成したバリアントが
表示されます

210
00:15:22,089 --> 00:15:27,861
これがウインドウで
今回の例はGarageBandです

211
00:15:28,996 --> 00:15:33,901
まずは配信方法の選択画面が
表示されます

212
00:15:34,535 --> 00:15:37,404
すべてのバリアントの配信用です

213
00:15:38,405 --> 00:15:43,277
この例では配信は“Ad Hoc”を
選びます

214
00:15:46,213 --> 00:15:50,517
次のウインドウの
App Thinningのフィールドで

215
00:15:51,084 --> 00:15:55,155
“All compatible device
variants”を選択

216
00:15:56,056 --> 00:16:00,661
これでXcodeはサポートされる
全デバイス用のバリアントが

217
00:15:56,056 --> 00:16:00,661
これでXcodeはサポートされる
全デバイス用のバリアントが

218
00:16:00,894 --> 00:16:03,730
エクスポートされます

219
00:16:06,300 --> 00:16:10,504
次に生成したバリアントを含む
レポートが

220
00:16:10,771 --> 00:16:13,607
Xcodeで作られます

221
00:16:14,374 --> 00:16:17,578
アプリケーション配備の
詳細を知りたい時に

222
00:16:17,678 --> 00:16:20,714
レポートで確認できます

223
00:16:21,014 --> 00:16:24,284
基本的な質問もあると思います

224
00:16:24,651 --> 00:16:26,954
生成したバリアントの数は？

225
00:16:27,521 --> 00:16:29,556
そのサイズはどれくらい？

226
00:16:30,090 --> 00:16:35,462
特定のバリアントの最適化や
微調整をする余地は？

227
00:16:37,764 --> 00:16:43,337
このGarageBandでは
生成された半分がエクスポートに

228
00:16:43,804 --> 00:16:45,239
見てみましょう

229
00:16:47,341 --> 00:16:49,009
この表をご覧ください

230
00:16:50,577 --> 00:16:52,012
この表では―

231
00:16:52,112 --> 00:16:56,717
各デバイス用のバリアントの
サイズが比較できます

232
00:16:58,619 --> 00:17:03,724
これは iOS 11以前の
バージョンのバリアントです

233
00:16:58,619 --> 00:17:03,724
これは iOS 11以前の
バージョンのバリアントです

234
00:17:04,925 --> 00:17:10,531
GarageBandは膨大な数の画像を含み
容量が大きく

235
00:17:10,998 --> 00:17:16,837
バリアントのサイズは
90MBから100MB以上です

236
00:17:19,373 --> 00:17:22,776
そしてこれがiOS 12の数字です

237
00:17:23,844 --> 00:17:26,946
その差は一目瞭然でしょう

238
00:17:27,047 --> 00:17:32,286
10％から20％程度も
サイズが縮小されています

239
00:17:33,487 --> 00:17:35,856
数字に見覚えがありますね

240
00:17:36,290 --> 00:17:41,862
これはすべて 先ほど話した
最適化と圧縮によるものです

241
00:17:46,200 --> 00:17:47,935
以上が画像圧縮でした

242
00:17:48,669 --> 00:17:52,139
では次に同僚のパトリックが

243
00:17:52,372 --> 00:17:55,042
デザインと制作について話します

244
00:17:56,009 --> 00:17:58,979
(拍手)

245
00:17:59,079 --> 00:18:00,180
ウィル どうも

246
00:17:59,079 --> 00:18:00,180
ウィル どうも

247
00:18:02,282 --> 00:18:06,253
Xcodeのアセットカタログを使って

248
00:18:06,353 --> 00:18:09,990
簡単にアセットを
改良する方法でした

249
00:18:10,557 --> 00:18:13,660
あと少し
アセットカタログを活用して

250
00:18:13,760 --> 00:18:18,899
アセットを最適化するやり方を
説明しましょう

251
00:18:19,433 --> 00:18:23,036
まずはデザインと制作の話です

252
00:18:23,136 --> 00:18:25,706
これがすべての原点です

253
00:18:28,141 --> 00:18:33,547
アセット用の様々なツールや
ワークフローやソースがありますが

254
00:18:33,647 --> 00:18:37,784
結局はすべて
人間が作っているのです

255
00:18:37,951 --> 00:18:40,254
そこで情報を整理して

256
00:18:40,354 --> 00:18:45,692
アセットが開発のワークフローに
入るプロセスを理解しましょう

257
00:18:45,792 --> 00:18:51,365
そうすればアプリケーションは
大きく改善されます

258
00:18:52,666 --> 00:18:56,637
まずはカラーマネジメントの話です

259
00:18:56,737 --> 00:18:59,373
見過ごされがちですが重要です

260
00:19:01,041 --> 00:19:05,612
ディスク内の画像アセットは
色の無い状態では

261
00:19:05,712 --> 00:19:09,716
ただのバイトで
何の意味もありません

262
00:19:10,017 --> 00:19:14,221
ではどうやって
色が与えられるのでしょうか？

263
00:19:14,321 --> 00:19:16,723
カラープロファイルが使われます

264
00:19:16,857 --> 00:19:20,227
それが測色値をタプルに与えて

265
00:19:20,327 --> 00:19:25,265
システムに
どんな色を表示するのか教えます

266
00:19:25,632 --> 00:19:31,238
ソースアーティファクトで
カラープロファイルを保管します

267
00:19:31,338 --> 00:19:36,076
そのメタデータを利用すれば
デザイナーの意図を

268
00:19:36,243 --> 00:19:38,378
そのまま伝えられます

269
00:19:38,479 --> 00:19:42,849
これを余分なメタデータかと判断し

270
00:19:42,950 --> 00:19:45,652
プロファイルを
消去しないでください

271
00:19:45,752 --> 00:19:48,088
大事なソースアーティファクトです

272
00:19:48,188 --> 00:19:51,325
最適化はツールに任せましょう

273
00:19:53,494 --> 00:19:56,096
色の管理がなぜ大事なのか？

274
00:19:56,196 --> 00:20:01,401
それはデバイスによって
ディスプレイが異なるからです

275
00:19:56,196 --> 00:20:01,401
それはデバイスによって
ディスプレイが異なるからです

276
00:20:01,502 --> 00:20:05,339
そしてどのディスプレイにも
正しく色をマッチさせ

277
00:20:05,439 --> 00:20:08,709
表示し再現する必要があります

278
00:20:08,809 --> 00:20:11,311
それが
カラーマネジメントの仕事です

279
00:20:11,745 --> 00:20:13,747
計算が必要なので

280
00:20:14,014 --> 00:20:18,986
CPUかGPUで処理されますが
少々手間です

281
00:20:19,920 --> 00:20:24,391
そこでアセットカタログの出番です

282
00:20:24,491 --> 00:20:29,530
コンパイルの間に
カラーマッチングを行います

283
00:20:29,663 --> 00:20:35,202
つまりデバイス上での計算処理を
省略できます

284
00:20:35,636 --> 00:20:41,508
すぐにアセットをデバイスに
ロードし表示できるのです

285
00:20:41,975 --> 00:20:46,079
この処理にはオマケがあります

286
00:20:46,180 --> 00:20:49,950
カラープロファイルのペイロードを
削除します

287
00:20:50,250 --> 00:20:52,886
さらに効率の良いことに

288
00:20:52,986 --> 00:20:57,057
色空間とディスク上のピクセルの
注釈も付けられます

289
00:20:58,492 --> 00:21:00,294
カラーマネジメントでした

290
00:20:58,492 --> 00:21:00,294
カラーマネジメントでした

291
00:21:00,627 --> 00:21:04,331
次のトピックは
ワーキングスペースです

292
00:21:05,099 --> 00:21:07,234
ワーキングスペースとは

293
00:21:07,334 --> 00:21:10,504
アセットが最初に作られる
環境のことです

294
00:21:10,604 --> 00:21:15,576
アートワークを作る
デザイナーやエンジニアが

295
00:21:15,676 --> 00:21:18,745
デザインツールでコンテンツを
作ります

296
00:21:18,846 --> 00:21:22,783
ここで重要なのは
すべてのデザインファイルに

297
00:21:22,883 --> 00:21:25,352
一貫した
カラー設定を使用することです

298
00:21:25,452 --> 00:21:29,623
これは良い習慣で
技術的な利点もあります

299
00:21:29,723 --> 00:21:32,960
なぜなら
アプリケーション全体を

300
00:21:33,060 --> 00:21:38,198
きちんと管理することに
つながるからです

301
00:21:38,532 --> 00:21:43,504
作業用デザインファイルの作成時に
推奨されるフォーマットは

302
00:21:43,604 --> 00:21:45,739
２種類あります

303
00:21:45,839 --> 00:21:50,510
最もよく使われるのが
sRGB 8ビットです

304
00:21:50,611 --> 00:21:55,582
全デバイスとコンテンツに
幅広く適用されます

305
00:21:55,983 --> 00:22:01,088
しかし 斬新で
色鮮やかなデザインもありますね

306
00:21:55,983 --> 00:22:01,088
しかし 斬新で
色鮮やかなデザインもありますね

307
00:22:01,188 --> 00:22:03,824
例えばこのアイコンです

308
00:22:03,924 --> 00:22:09,263
これを幅広い色に対応可能な
デバイスで生かすため

309
00:22:09,363 --> 00:22:14,802
広い色域やカラーアセットを
使いたいでしょう

310
00:22:14,902 --> 00:22:18,605
その場合 Display P3が最適です

311
00:22:18,806 --> 00:22:24,778
デザインの損失を防ぐため
16ビット/チャンネルにします

312
00:22:24,945 --> 00:22:29,983
Xcodeや
ランタイムプラットフォームで

313
00:22:30,083 --> 00:22:33,654
広いカラーアセットを扱う方法は
多彩です

314
00:22:33,887 --> 00:22:37,057
ここでは詳細を省きますので

315
00:22:37,157 --> 00:22:41,495
２年前の“Working with
Wide Color”をご覧ください

316
00:22:41,595 --> 00:22:45,666
このトピックの詳細と背景が
分かります

317
00:22:45,766 --> 00:22:50,037
P3アセットの詳細は
ホームページを参照ください

318
00:22:50,137 --> 00:22:56,276
developer.apple.comの
iOS デザインリソースセクションです

319
00:22:58,245 --> 00:23:01,181
では次の話に移りましょう

320
00:22:58,245 --> 00:23:01,181
では次の話に移りましょう

321
00:23:02,382 --> 00:23:06,420
アートワークについて
皆さんが作る―

322
00:23:07,120 --> 00:23:12,326
UIは色々な表示やレイアウトに
対応する必要があり

323
00:23:12,726 --> 00:23:16,597
アートワークを
引き伸ばしたりして

324
00:23:16,697 --> 00:23:19,800
レイアウト変更に対処します

325
00:23:19,900 --> 00:23:21,768
どのように行うか？

326
00:23:22,302 --> 00:23:28,776
最も一般的な方法は
画像の伸縮部と非伸縮部の特定です

327
00:23:28,876 --> 00:23:29,943
違いは？

328
00:23:30,043 --> 00:23:34,748
スライドの例は
ある画像だと想像してください

329
00:23:34,848 --> 00:23:39,820
丸い角の美しい形状を
どのサイズでも保持したい

330
00:23:40,087 --> 00:23:43,657
青色の部分を
伸ばすことはできませんが

331
00:23:43,757 --> 00:23:45,859
黄色の部分は可能です

332
00:23:46,293 --> 00:23:50,464
通常これを行うには
デザインツールを使って

333
00:23:50,564 --> 00:23:53,066
すべてをスライスします

334
00:23:53,167 --> 00:23:56,904
次に各リージョンを
個別のアセットとして支給

335
00:23:57,004 --> 00:24:00,807
それを３または９分割の
APIを使って

336
00:23:57,004 --> 00:24:00,807
それを３または９分割の
APIを使って

337
00:24:00,908 --> 00:24:04,044
最終デザインのサイズにします

338
00:24:04,645 --> 00:24:08,849
長年 これが有効かつ
一般的な方法でした

339
00:24:09,149 --> 00:24:10,651
しかし短所があります

340
00:24:10,784 --> 00:24:14,855
最後の画像の再構築は
CPUの負荷が大きく

341
00:24:15,055 --> 00:24:18,759
複雑で非効率とも言える作業です

342
00:24:18,859 --> 00:24:24,364
現在のCore Animationのような
機能にも合っていません

343
00:24:25,766 --> 00:24:27,434
より良い方法は？

344
00:24:27,534 --> 00:24:30,137
それは単一の画像を使い

345
00:24:30,337 --> 00:24:36,109
そこに伸縮部分を特定する
メタデータを提供することです

346
00:24:36,777 --> 00:24:41,548
それは最適な
GPUアニメーションを可能にします

347
00:24:42,649 --> 00:24:46,653
アセットカタログでは
これが簡単にできます

348
00:24:47,454 --> 00:24:49,556
Show Slicingエディタです

349
00:24:50,224 --> 00:24:54,261
まずStart Slicingに進み

350
00:24:54,495 --> 00:24:58,098
境界線を操作します

351
00:24:58,232 --> 00:25:03,704
この線で画像の
伸縮部と非伸縮部を設定します

352
00:24:58,232 --> 00:25:03,704
この線で画像の
伸縮部と非伸縮部を設定します

353
00:25:03,804 --> 00:25:06,607
この例ではオレンジ色の両端と

354
00:25:06,740 --> 00:25:10,244
中間のスライスが伸縮部です

355
00:25:10,444 --> 00:25:11,378
見てのとおり

356
00:25:11,912 --> 00:25:16,884
白く影のかかった
大きな部分がありますね

357
00:25:16,984 --> 00:25:18,218
これは何か？

358
00:25:18,685 --> 00:25:22,723
面白いことに
アセットのこの部分は

359
00:25:22,823 --> 00:25:25,058
もう必要ありません

360
00:25:25,159 --> 00:25:28,829
残りの３つで
サイズを示せるからです

361
00:25:29,296 --> 00:25:31,265
これがなぜ重要か？

362
00:25:31,798 --> 00:25:36,703
ビルドの際にXcodeが
必要な部分を認識し

363
00:25:36,803 --> 00:25:40,307
その他の部分はそのまま残します

364
00:25:40,541 --> 00:25:45,712
不要な大部分を
ディスク容量から減らせるので

365
00:25:45,979 --> 00:25:46,914
便利です

366
00:25:47,080 --> 00:25:50,350
そして２次的な利点もあります

367
00:25:50,450 --> 00:25:53,020
私はこれが気に入っています

368
00:25:53,353 --> 00:25:55,722
デザイナーはアセットを

369
00:25:55,856 --> 00:25:59,560
自然なサイズで作ればいい

370
00:25:59,660 --> 00:26:05,933
効率的に配置するため
最小サイズで最適化するなどは

371
00:25:59,660 --> 00:26:05,933
効率的に配置するため
最小サイズで最適化するなどは

372
00:26:06,033 --> 00:26:09,603
気にしなくていい
それより長期的には―

373
00:26:09,703 --> 00:26:13,974
ソースコードを
分かりやすくするほうが大事です

374
00:26:14,107 --> 00:26:16,977
配置はツールに任せましょう

375
00:26:18,479 --> 00:26:22,683
伸縮部は図で確認や設定を
できますが

376
00:26:22,783 --> 00:26:27,020
Show Slicingインスペクタも
あります

377
00:26:27,120 --> 00:26:29,490
両端の微調整が可能で

378
00:26:29,590 --> 00:26:34,628
中心部のビヘイビアを
伸縮かタイルに設定できます

379
00:26:35,963 --> 00:26:40,434
その結果 伸縮のメタデータを
アートワークに近付け

380
00:26:40,534 --> 00:26:44,805
最終的に大きな利益を
もたらすのです

381
00:26:44,938 --> 00:26:47,875
デザインに変更を加える際は

382
00:26:48,008 --> 00:26:51,645
すべてを一括で更新するだけです

383
00:26:51,745 --> 00:26:55,382
コードの位置を覚える必要は
ありません

384
00:26:55,649 --> 00:26:58,519
１ヵ所にまとまっていますから

385
00:27:00,621 --> 00:27:01,455
どうも

386
00:27:01,555 --> 00:27:03,624
(拍手)

387
00:27:04,591 --> 00:27:07,561
次はベクターアセットです

388
00:27:08,362 --> 00:27:13,233
ディスプレイの解像度は
製品によって異なるので

389
00:27:13,333 --> 00:27:19,773
ターゲットに合わせ1x 2x 3xの
アセットを作成します

390
00:27:20,007 --> 00:27:22,209
これでうまくいっています

391
00:27:22,509 --> 00:27:27,481
しかしデザインごとに
アセットを２～３つも納品するのは

392
00:27:27,948 --> 00:27:30,050
無駄とも言えます

393
00:27:30,684 --> 00:27:33,854
アセット１つで対応可能か？

394
00:27:33,954 --> 00:27:39,426
アセットカタログのPDF用
ベクターアセットなら可能です

395
00:27:39,626 --> 00:27:43,096
Xcodeのアセットカタログは

396
00:27:43,464 --> 00:27:45,532
PDFを扱えます

397
00:27:45,732 --> 00:27:49,469
XcodeがPDFを必要な倍率に

398
00:27:49,570 --> 00:27:52,639
自動で生成しラスタライズします

399
00:27:53,240 --> 00:27:56,210
これで異なるターゲットに
適用できます

400
00:27:57,044 --> 00:28:02,249
PDFのベクターアセットを
レンダリングしなくて済むので

401
00:27:57,044 --> 00:28:02,249
PDFのベクターアセットを
レンダリングしなくて済むので

402
00:28:02,349 --> 00:28:07,221
デバイスのランタイム時に
コストがかかりません

403
00:28:08,155 --> 00:28:10,891
安心してベクターを使えます

404
00:28:11,258 --> 00:28:16,163
さてアセットには
最も自然なサイズがあります

405
00:28:16,263 --> 00:28:18,298
しかし場合によっては―

406
00:28:18,398 --> 00:28:23,203
違う大きさで
アセットを表示したい時もあります

407
00:28:23,604 --> 00:28:28,175
昨年からiOS 11とXcode 9では

408
00:28:28,275 --> 00:28:30,744
ベクターデータを保存できます

409
00:28:31,078 --> 00:28:35,215
ですから
その画像を自然なサイズより

410
00:28:35,315 --> 00:28:39,152
大きな画像ビューに入れられます

411
00:28:39,253 --> 00:28:42,823
そして元のPDFベクターデータを
見つけます

412
00:28:42,990 --> 00:28:46,160
これは無関係なメタデータや
プロファイルとは

413
00:28:46,293 --> 00:28:49,463
切り離されてスリムな状態です

414
00:28:49,730 --> 00:28:54,301
サイズを変える場合のみ
再度ラスタライズします

415
00:28:54,401 --> 00:28:57,805
それ以外は最適化された
ビットマップを使います

416
00:28:58,338 --> 00:29:03,143
アプリケーションは
より柔軟に動的タイプに対応

417
00:28:58,338 --> 00:29:03,143
アプリケーションは
より柔軟に動的タイプに対応

418
00:29:03,310 --> 00:29:07,681
UIImage Viewのサイズ変更時に
画像が

419
00:29:07,981 --> 00:29:10,617
自動的によりハッキリします

420
00:29:12,453 --> 00:29:13,821
ベクターアセットは以上です

421
00:29:14,922 --> 00:29:19,960
次は2x用のデザインについて
お話しします

422
00:29:21,028 --> 00:29:23,230
2xとはRetinaディスプレイです

423
00:29:23,797 --> 00:29:26,833
最もよく使われている表示密度で

424
00:29:26,934 --> 00:29:30,771
皆さんもよくご存じでしょう

425
00:29:30,871 --> 00:29:35,409
すばらしいディスプレイで
大きな前進でした

426
00:29:35,509 --> 00:29:40,047
しかし まだ
使用するデザインによっては―

427
00:29:41,348 --> 00:29:45,986
細かい線やエッジが
ぼやける場合があります

428
00:29:46,086 --> 00:29:51,358
エッジがシャープかファジーか
分からない程度の解像度です

429
00:29:52,059 --> 00:29:57,030
アセットのデザインにおいて
いまだに課題です

430
00:29:58,165 --> 00:30:02,202
この問題の解決に役立つ技術は？

431
00:29:58,165 --> 00:30:02,202
この問題の解決に役立つ技術は？

432
00:30:03,904 --> 00:30:09,176
１つがベクターデザインツールの
ポイントバウンダリスナッピングです

433
00:30:09,276 --> 00:30:13,747
１ポイント間隔でグリッドを設定し
スナッピングをオンにします

434
00:30:13,847 --> 00:30:17,718
形やコントロールポイントの調整は
スナップだけで

435
00:30:17,818 --> 00:30:22,790
スナップ先の境界線は
ピクセルの境界になります

436
00:30:23,090 --> 00:30:24,324
便利ですね

437
00:30:24,591 --> 00:30:28,562
しかし次のような場合もあります 

438
00:30:28,662 --> 00:30:31,632
なぜかエッジが
ポイントの間にくるが

439
00:30:32,866 --> 00:30:37,938
Retina 2xのデバイスのために―

440
00:30:38,071 --> 00:30:43,076
表示密度に合うよう アセットを
最適化したい場合などです

441
00:30:43,443 --> 00:30:46,980
そんな時は2xのグリッドを使い

442
00:30:47,080 --> 00:30:49,850
アセットを２倍のサイズにします

443
00:30:49,950 --> 00:30:54,154
つまり２ポイントが
１ピクセルグリッドで

444
00:30:54,254 --> 00:30:57,724
２単位が
Retinaの１ポイントになります

445
00:30:58,458 --> 00:31:02,596
次にアセットを調整し
ポイントスナッピングを使い

446
00:30:58,458 --> 00:31:02,596
次にアセットを調整し
ポイントスナッピングを使い

447
00:31:02,696 --> 00:31:05,933
線やエッジをポイントに合わせます

448
00:31:07,100 --> 00:31:10,070
では その後はどうするか？

449
00:31:10,170 --> 00:31:11,939
大きすぎて使えない？

450
00:31:12,105 --> 00:31:13,140
使えます

451
00:31:13,340 --> 00:31:19,012
アセットカタログのスケールビンの
2xに入れるだけです

452
00:31:19,113 --> 00:31:22,950
そうすればXcodeが
自動で処理します

453
00:31:23,050 --> 00:31:25,686
これは2xのアートワークで

454
00:31:25,786 --> 00:31:29,256
１ポイントは
Retinaの２ピクセルではない

455
00:31:29,356 --> 00:31:31,091
その逆だと認識します

456
00:31:31,191 --> 00:31:32,226
すべて計算し

457
00:31:32,326 --> 00:31:37,231
ラスタライズされたビットマップを
他の倍率にレンダリングします

458
00:31:37,331 --> 00:31:42,369
デザイナーは2xグリッドだけ
使えばいいのです

459
00:31:43,971 --> 00:31:49,810
自動のスケーリングが不十分で
まだ問題がある場合

460
00:31:49,910 --> 00:31:52,679
最終的に開発側で
コントロールできます

461
00:31:52,780 --> 00:31:57,451
ビットマップを適切な倍率のビンに
入れてください

462
00:31:57,551 --> 00:32:03,056
ラスタライズされたPDFより
それが優先されます

463
00:31:57,551 --> 00:32:03,056
ラスタライズされたPDFより
それが優先されます

464
00:32:04,658 --> 00:32:09,263
デザインと制作についての話は
以上です

465
00:32:09,363 --> 00:32:15,302
次はカタログ化と
Xcodeの構成について話します

466
00:32:16,270 --> 00:32:20,974
Xcodeのアセットカタログを
使ってみた方は

467
00:32:21,074 --> 00:32:26,880
できる事とオプションの数に
圧倒されたでしょう

468
00:32:27,147 --> 00:32:32,753
私は意味があるものだけを
使うことをおすすめします

469
00:32:32,953 --> 00:32:35,022
皆さんのプロジェクトや

470
00:32:35,455 --> 00:32:38,225
コンテンツに関わる項目だけです

471
00:32:38,325 --> 00:32:41,462
オプションは多くエンジンは強力で

472
00:32:41,562 --> 00:32:44,231
多くの機能が備わっています

473
00:32:44,331 --> 00:32:50,003
ですが目的に沿って
簡単な操作から始めてみてください

474
00:32:51,438 --> 00:32:57,711
これから役に立つ構成上の技法を
２つ説明していきます

475
00:32:57,978 --> 00:33:00,114
１つ目はバンドルです

476
00:32:57,978 --> 00:33:00,114
１つ目はバンドルです

477
00:33:00,414 --> 00:33:04,151
アセットに
なぜバンドルが関係するか？

478
00:33:04,251 --> 00:33:09,056
理由は
大型プロジェクトに有効だからです

479
00:33:09,156 --> 00:33:12,292
複数のフレームワークや

480
00:33:12,426 --> 00:33:16,830
複数のチームが関わる
大型プロジェクトもあります

481
00:33:16,930 --> 00:33:21,635
複数のアセットをすべてメインの
バンドルに集め

482
00:33:21,735 --> 00:33:24,104
管理するのは大変です

483
00:33:24,204 --> 00:33:28,175
そして該当箇所と
うまくひも付くよう

484
00:33:28,408 --> 00:33:31,345
名前を付ける必要があります

485
00:33:31,678 --> 00:33:36,517
対処法の１つは複数のバンドルを
作成することです

486
00:33:36,617 --> 00:33:42,289
Xcodeは各バンドルに単一の
アーティファクトを作るからです

487
00:33:42,456 --> 00:33:46,093
例えばアートワークだけの
バンドルを作る

488
00:33:46,193 --> 00:33:49,196
これは再利用のいい戦略です

489
00:33:49,296 --> 00:33:53,901
すべてのアートワークを
一貫したネームスペースで

490
00:33:54,034 --> 00:33:56,904
１つに整理して管理するのです

491
00:33:57,004 --> 00:34:01,942
アプリケーションの他の部分にも
画像を提供できます

492
00:33:57,004 --> 00:34:01,942
アプリケーションの他の部分にも
画像を提供できます

493
00:34:03,177 --> 00:34:05,479
どうやって取り出すか？

494
00:34:06,146 --> 00:34:11,217
イメージコンストラクタの
“UIImage.Name”“in: Bundle”

495
00:34:11,451 --> 00:34:14,321
などでバンドル引数を取得

496
00:34:14,420 --> 00:34:19,159
macOSにはNSBundleの
リソースがあります

497
00:34:19,993 --> 00:34:24,264
バンドルは
単一のネームスペースです

498
00:34:24,364 --> 00:34:28,335
つまりその中で
同じ名前にはできません

499
00:34:28,435 --> 00:34:32,105
ですが別のバンドルなら
命名規則も不要です

500
00:34:34,375 --> 00:34:38,645
ネームスペースについて話しますが

501
00:34:38,745 --> 00:34:41,114
これも大型プロジェクトの課題です

502
00:34:41,215 --> 00:34:44,685
次の例では大きい集まりの中に

503
00:34:44,784 --> 00:34:48,589
いくつかの構造が存在する場合です

504
00:34:49,322 --> 00:34:53,827
例えばアプリケーション内に
50の部屋があり

505
00:34:53,927 --> 00:34:57,965
各部屋にテーブルといす
そのアセットがあります

506
00:34:58,065 --> 00:35:03,404
コードにテーブルといすを
入れたいが50個もある

507
00:34:58,065 --> 00:35:03,404
コードにテーブルといすを
入れたいが50個もある

508
00:35:03,504 --> 00:35:04,705
さてどうするか？

509
00:35:05,138 --> 00:35:09,109
選択肢の１つは
ある命名規則を作り

510
00:35:09,209 --> 00:35:12,679
コードに入れますが
これは理想的ではない

511
00:35:12,980 --> 00:35:18,218
そこで“Provides Namespace”
オプションです

512
00:35:18,919 --> 00:35:24,057
アートワークをフォルダに整理し
ここをチェックします

513
00:35:24,157 --> 00:35:28,762
そうすればアセットカタログ内の
各画像の先頭に

514
00:35:28,862 --> 00:35:32,900
自動でフォルダ名を
追加するのです

515
00:35:33,267 --> 00:35:35,202
後で簡単に取り出せます

516
00:35:35,302 --> 00:35:39,773
アセットの大きな集まりを
うまく整理できます

517
00:35:40,574 --> 00:35:45,012
以上 カタログ化について
話しました

518
00:35:45,712 --> 00:35:48,749
次は配備について話しましょう

519
00:35:48,849 --> 00:35:51,552
この工程から楽しくなります

520
00:35:53,620 --> 00:35:55,989
前述のApp Thinningに関する

521
00:35:56,089 --> 00:36:00,194
アセットカタログの活用法を
見てみましょう

522
00:35:56,089 --> 00:36:00,194
アセットカタログの活用法を
見てみましょう

523
00:36:00,294 --> 00:36:05,065
概要としては全コンテンツの
バリアントの作成です

524
00:36:05,165 --> 00:36:09,436
各デバイスに合わせるための
作業です

525
00:36:09,536 --> 00:36:13,340
最も一般的な方法は
製品群ごとに分けるやり方です

526
00:36:13,440 --> 00:36:16,877
iPad iPhone TV Watchなど

527
00:36:16,977 --> 00:36:21,515
もしくは3xと2xの解像度ごとに
分けます

528
00:36:21,682 --> 00:36:25,018
コンテンツ最適化のため
バリアントを提供すると

529
00:36:25,219 --> 00:36:30,023
App Thinningが
正しいサブセットを選択

530
00:36:30,124 --> 00:36:33,760
アプリケーションを使うデバイスに
合わせます

531
00:36:36,263 --> 00:36:41,168
さてコンテンツの適応には
もう１つの方法があります

532
00:36:41,535 --> 00:36:45,672
その別のアプローチは
性能のクラスです

533
00:36:46,306 --> 00:36:52,579
もしアプリケーションが
すべての製品群を認識する際に

534
00:36:52,679 --> 00:36:58,218
先ほど述べた特徴ではなく
性能別で分けるとしたら？

535
00:36:58,685 --> 00:37:01,155
アセットカタログでは可能です

536
00:36:58,685 --> 00:37:01,155
アセットカタログでは可能です

537
00:37:01,321 --> 00:37:06,427
デバイスごとにハードウェアの
性能は大きく異なります

538
00:37:06,527 --> 00:37:12,266
例えばiOSでもiPhone 5と
最新のiPhone Xでは

539
00:37:12,366 --> 00:37:15,002
性能の差は非常に大きい

540
00:37:15,536 --> 00:37:20,941
それを利用すればサポートする
最も低性能のデバイスに

541
00:37:21,041 --> 00:37:24,611
アプリケーションを
合わせる必要もなくなります

542
00:37:24,978 --> 00:37:28,015
それを両立させるのがゴールです

543
00:37:28,115 --> 00:37:31,919
解決法はアダプティブリソースです

544
00:37:32,019 --> 00:37:33,854
これから説明します

545
00:37:34,388 --> 00:37:37,791
性能で区別するための
主な方法は２つ

546
00:37:37,891 --> 00:37:41,428
１つ目はメモリのクラスで
これは重要です

547
00:37:41,528 --> 00:37:44,631
１GBから４GBまで４段階あり

548
00:37:44,731 --> 00:37:48,669
様々な製品のメモリに対応します

549
00:37:48,769 --> 00:37:54,174
これはそれが何かに関わらず
すべての製品に当てはまります

550
00:37:55,476 --> 00:38:00,647
２つ目はグラフィックスの
クラスを使う方法です

551
00:37:55,476 --> 00:38:00,647
２つ目はグラフィックスの
クラスを使う方法です

552
00:38:00,748 --> 00:38:03,717
実際には２つのものに対応します

553
00:38:03,851 --> 00:38:07,454
１つ目がMetalのバージョンです

554
00:38:07,554 --> 00:38:11,491
それはGPUのコンセプトと同じです

555
00:38:11,692 --> 00:38:17,865
またデバイスの
特定のプロセッサにも一致します

556
00:38:18,098 --> 00:38:21,001
Metal 1はA7に対応し

557
00:38:21,101 --> 00:38:25,005
Metal 4はA11に対応します

558
00:38:25,138 --> 00:38:27,975
各グラフィックスのクラスに

559
00:38:28,075 --> 00:38:31,779
アセットを分類し割り当てられます

560
00:38:32,813 --> 00:38:36,049
どちらかだけでも強力ですが

561
00:38:36,149 --> 00:38:41,688
両方の特徴を組み合わせると
非常に興味深いのです

562
00:38:41,789 --> 00:38:45,792
性能のマトリックスを作り
アセットの適応先が

563
00:38:45,893 --> 00:38:49,797
どこになるか確認してみましょう

564
00:38:51,865 --> 00:38:53,434
具体的にどう働くか？

565
00:38:54,201 --> 00:38:57,838
簡単な例を使って説明しましょう

566
00:38:57,938 --> 00:39:02,843
これが仕組みを理解し
利用するためのキーとなります

567
00:38:57,938 --> 00:39:02,843
これが仕組みを理解し
利用するためのキーとなります

568
00:39:02,976 --> 00:39:05,946
この例のアセットは３つ

569
00:39:06,046 --> 00:39:11,051
“AnyとAny”は
より低性能のデバイス用です

570
00:39:11,151 --> 00:39:16,457
あと２つは最適化されたアセットで
３GBのMetal 3用と

571
00:39:16,657 --> 00:39:19,893
２GBのMetal 4用です

572
00:39:20,427 --> 00:39:24,398
私はiPhone 8 Plusを基準として

573
00:39:24,531 --> 00:39:27,334
アセットを選んでいるとします

574
00:39:27,534 --> 00:39:30,637
つまり４GBのMetal 4です

575
00:39:31,071 --> 00:39:35,409
メモリ軸の４GBには何もありません

576
00:39:35,909 --> 00:39:40,280
次に 他のものを探して
下がっていくと

577
00:39:40,380 --> 00:39:43,317
３GBが見つかりました

578
00:39:44,284 --> 00:39:47,154
そしてアセットを見つけ―

579
00:39:47,921 --> 00:39:49,423
選択します

580
00:39:49,556 --> 00:39:54,328
私がどのアセットを選んだかが
重要です

581
00:39:54,428 --> 00:39:56,296
３GBのMetal 3でした

582
00:39:56,396 --> 00:40:01,168
実はGPUのクラスには
一致するものがありました

583
00:39:56,396 --> 00:40:01,168
実はGPUのクラスには
一致するものがありました

584
00:40:01,301 --> 00:40:06,206
しかし メモリを
グラフィックスより先に探したため

585
00:40:06,306 --> 00:40:08,742
メモリから選択しました

586
00:40:08,842 --> 00:40:11,111
これは非常に重要です

587
00:40:11,211 --> 00:40:15,449
性能を決めるのは
メモリだと判断したのです

588
00:40:15,549 --> 00:40:19,486
それに従い
マトリックスを進みました

589
00:40:21,355 --> 00:40:24,191
この仕組みを生かしましょう

590
00:40:24,658 --> 00:40:28,428
メモリはデバイスの
ヘッドルーム全体や

591
00:40:28,562 --> 00:40:31,565
性能を最もよく示す指標です

592
00:40:31,665 --> 00:40:37,271
大きくリッチなアセットを
使いたいと思います

593
00:40:37,371 --> 00:40:42,009
それにはレンダリング時など
大量のメモリが必要です

594
00:40:42,309 --> 00:40:45,479
豊かなユーザ体験には
メモリが要ります

595
00:40:45,612 --> 00:40:47,748
高性能なグラフィックスは

596
00:40:47,848 --> 00:40:52,552
CPUとGPU両方の処理能力と
関連するため―

597
00:40:52,653 --> 00:40:54,855
複雑なアセットに向きます

598
00:40:55,255 --> 00:41:00,594
特定のGPUと機能でしかできない
シェーダを使ったり

599
00:40:55,255 --> 00:41:00,594
特定のGPUと機能でしかできない
シェーダを使ったり

600
00:41:00,694 --> 00:41:05,799
少し多めの処理が必要な
アセットを含めたり

601
00:41:06,233 --> 00:41:11,305
２つの例を挙げて
どうなるかを見せます

602
00:41:12,840 --> 00:41:16,543
NSDataAssetを用いて
説明します

603
00:41:16,777 --> 00:41:21,014
NSDataAssetはシンプルですが
とても強力です

604
00:41:21,115 --> 00:41:25,819
アセットカタログに
フレキシブルなコンテナを提供し

605
00:41:25,919 --> 00:41:29,356
任意のファイル周辺に
バリアントを格納

606
00:41:29,490 --> 00:41:33,126
画像だけでなく何でもいいのです

607
00:41:33,360 --> 00:41:37,498
App Thinningでこれを使い

608
00:41:37,598 --> 00:41:40,768
各データを各性能クラスへ
転送できます

609
00:41:40,868 --> 00:41:44,972
例えば ゲームの
カットシーン用の動画です

610
00:41:45,772 --> 00:41:51,011
性能スペクトルの中レベルの動画を
使うかもしれません

611
00:41:51,812 --> 00:41:55,749
またはスペクトルの最高レベルの

612
00:41:55,849 --> 00:42:00,788
高解像度の動画を
提供することも可能です

613
00:41:55,849 --> 00:42:00,788
高解像度の動画を
提供することも可能です

614
00:42:00,888 --> 00:42:03,023
もしくはローエンドな

615
00:42:03,123 --> 00:42:07,761
静止画や簡単な連続イメージも
使えます

616
00:42:07,861 --> 00:42:12,065
時間や過度なリソースを
かけないので

617
00:42:12,166 --> 00:42:14,635
使用時も反応が良いのです

618
00:42:15,869 --> 00:42:19,239
もう１つのより面白い例は
plistです

619
00:42:19,339 --> 00:42:24,244
なぜアセットカタログでplistを
使うのか？

620
00:42:24,344 --> 00:42:27,714
NSDataAssetと共に使い

621
00:42:27,814 --> 00:42:31,418
アプリケーションを調整できます

622
00:42:32,119 --> 00:42:37,558
NSDataAsset内で plistを
収めた性能クラスに対応する―

623
00:42:37,691 --> 00:42:40,127
設定パラメータを使うのです

624
00:42:40,227 --> 00:42:45,732
例えば雲をレンダリングする
アプリケーションで

625
00:42:45,833 --> 00:42:50,104
ハードウェアに合わせ
雲のサイズを設定できます

626
00:42:50,204 --> 00:42:54,541
使われている
実際のデバイスに合わせ

627
00:42:54,641 --> 00:42:56,977
コードが自動で調整されます

628
00:42:57,644 --> 00:43:00,981
以上が性能クラスの話でした

629
00:42:57,644 --> 00:43:00,981
以上が性能クラスの話でした

630
00:43:02,750 --> 00:43:05,786
次はSprite Atlasの話です

631
00:43:05,953 --> 00:43:09,790
数年前に発表された
Sprite Atlasは

632
00:43:09,923 --> 00:43:14,127
SpriteKitゲームを
サポートします

633
00:43:15,162 --> 00:43:20,367
しかし SpriteKitゲームではなく

634
00:43:20,467 --> 00:43:23,937
一般的なコンテキストで話します

635
00:43:25,305 --> 00:43:30,778
これはAutomatic Image Packingと
同様の属性を持ち

636
00:43:30,878 --> 00:43:34,915
Sprite Atlas内に
関連する画像を１つにまとめます

637
00:43:35,015 --> 00:43:40,120
画像は１度にロードされ
アトラス内で参照される全画像は

638
00:43:40,220 --> 00:43:44,425
アトラス内では軽量化されます

639
00:43:45,259 --> 00:43:46,460
すばらしいです

640
00:43:48,128 --> 00:43:53,934
重要なのはSpriteKitを
使わなくてもいい点です

641
00:43:54,034 --> 00:43:59,339
Sprite Atlasではグループを管理し

642
00:43:59,439 --> 00:44:00,874
名前を付けられます

643
00:43:59,439 --> 00:44:00,874
名前を付けられます

644
00:44:00,974 --> 00:44:05,379
そのように複数のものを
整理して管理できます

645
00:44:05,979 --> 00:44:11,251
またUIImageやNSImageのような
APIか名前で

646
00:44:11,351 --> 00:44:13,487
画像にアクセス可能です

647
00:44:13,754 --> 00:44:17,658
SpriteKit以外の
アプリケーションにも

648
00:44:17,758 --> 00:44:20,427
SpriteKitを使えます

649
00:44:20,527 --> 00:44:24,798
SKTextureAtlas.preloadTexture
AtlasesNamedです

650
00:44:24,898 --> 00:44:29,336
多量の画像を
すぐに読み込み使いたい時に

651
00:44:29,436 --> 00:44:31,939
このAPIが役立ちます

652
00:44:32,039 --> 00:44:35,476
それは事前に
もしくはその場でロードし

653
00:44:35,576 --> 00:44:38,912
デコードし
非同期でメモリに読み込みます

654
00:44:39,012 --> 00:44:44,585
完了ハンドラが名付けられた
アトラスを処理します

655
00:44:44,685 --> 00:44:47,254
使用の際は注意点もあります

656
00:44:47,421 --> 00:44:49,890
無差別に使わないでください

657
00:44:50,524 --> 00:44:53,594
指示内容を
そのまま実行するからです

658
00:44:53,694 --> 00:44:56,763
つまり大量のI/Oとメモリを消費し

659
00:44:56,864 --> 00:45:00,701
すべての画像をロードする
可能性があります

660
00:44:56,864 --> 00:45:00,701
すべての画像をロードする
可能性があります

661
00:45:00,801 --> 00:45:05,038
ですから すぐ使うべきか
正しく判断しないと

662
00:45:05,172 --> 00:45:07,341
大変なことになります

663
00:45:09,943 --> 00:45:14,081
Sprite Atlasの強みはまだあります

664
00:45:14,181 --> 00:45:16,350
Sprite Atlas内の全画像は

665
00:45:16,517 --> 00:45:21,088
アセットカタログの画像と
同じ機能が使えます

666
00:45:21,188 --> 00:45:25,225
例えばカタログ化や圧縮の
すべての設定と

667
00:45:25,325 --> 00:45:27,494
App Thinningなどです

668
00:45:27,594 --> 00:45:32,266
画像を自動で分割し
順番に並べます

669
00:45:32,566 --> 00:45:37,204
分割はピクセルやデバイスや
圧縮のタイプによります

670
00:45:37,304 --> 00:45:41,575
そしてすべてが適切に
読み込まれ最適化され

671
00:45:41,675 --> 00:45:44,244
すぐにデバイスに送られます

672
00:45:46,813 --> 00:45:49,283
以上が配備の話でした

673
00:45:49,383 --> 00:45:51,051
さあ あと少しです

674
00:45:51,185 --> 00:45:54,755
では重要なポイントを
おさらいしましょう

675
00:45:54,855 --> 00:45:56,924
何よりもまず肝心なこと

676
00:45:57,424 --> 00:46:01,729
画像リソースの管理には
アセットカタログが最良の選択です

677
00:45:57,424 --> 00:46:01,729
画像リソースの管理には
アセットカタログが最良の選択です

678
00:46:01,962 --> 00:46:04,631
今年は新しい圧縮で10～20％も

679
00:46:04,731 --> 00:46:08,435
ディスクの容量を削減できます

680
00:46:08,635 --> 00:46:11,138
App Thinningの改良により

681
00:46:11,238 --> 00:46:16,610
iOS 12のユーザは
最適化された状態を楽しめます

682
00:46:16,710 --> 00:46:20,180
配備ターゲットは関係ないのです

683
00:46:20,581 --> 00:46:26,020
アプリケーションのリソースを
デバイスに適応させる―

684
00:46:26,120 --> 00:46:28,422
カタログ化機能も紹介しました

685
00:46:29,723 --> 00:46:32,826
その他の情報は
こちらのリンクをご覧ください

686
00:46:33,260 --> 00:46:35,095
それでは―

687
00:46:35,729 --> 00:46:37,464
皆さん 良い１日を

688
00:46:37,564 --> 00:46:38,398
ありがとう

689
00:46:38,499 --> 00:46:41,235
(拍手)