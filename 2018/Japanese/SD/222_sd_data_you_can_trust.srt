
1
00:00:07,074 --> 00:00:16,550
(音楽)

2
00:00:23,123 --> 00:00:28,228
(拍手)

3
00:00:28,328 --> 00:00:29,630
おはようございます

4
00:00:29,963 --> 00:00:33,033
お集まりいただき感謝します

5
00:00:33,167 --> 00:00:35,869
Foundationチームのイタイです

6
00:00:36,570 --> 00:00:41,041
アプリケーションを流れる
データが及ぼす影響と

7
00:00:41,308 --> 00:00:45,212
信頼できるデータで
顧客を守る方法を説明します

8
00:00:45,846 --> 00:00:47,014
始めましょう

9
00:00:48,482 --> 00:00:52,519
アプリケーションを便利にするのは

10
00:00:52,619 --> 00:00:57,791
ディスク ネットワーク 顧客など
外部ソースです

11
00:00:57,925 --> 00:01:01,962
データを活用してサービスにします

12
00:00:57,925 --> 00:01:01,962
データを活用してサービスにします

13
00:01:02,796 --> 00:01:07,968
データは既知の形式でないと
使用できません

14
00:01:08,669 --> 00:01:10,404
形式が違う場合は？

15
00:01:11,805 --> 00:01:16,643
通常は破損や無効として
データは無視されます

16
00:01:17,477 --> 00:01:22,416
しかし アプリケーションに
影響する時があり

17
00:01:22,516 --> 00:01:26,253
誤作動やクラッシュの
原因となります

18
00:01:27,921 --> 00:01:33,093
顧客はアップデートを
待つしかありません

19
00:01:33,760 --> 00:01:38,498
起動時にクラッシュして
使用できないと最悪です

20
00:01:38,599 --> 00:01:42,836
復旧を待つ間に
評価は落ちていきます

21
00:01:43,070 --> 00:01:44,872
嫌な経験です

22
00:01:46,340 --> 00:01:49,877
フレームワーク開発者にとっては
深刻な問題です

23
00:01:49,977 --> 00:01:54,515
多数のアプリケーションに
影響する場合があるためです

24
00:01:56,650 --> 00:01:58,752
今日の主な内容は

25
00:01:59,119 --> 00:02:03,056
信頼できるデータの構築方法です

26
00:01:59,119 --> 00:02:03,056
信頼できるデータの構築方法です

27
00:02:03,156 --> 00:02:04,858
要点は２つ

28
00:02:05,692 --> 00:02:09,863
１つ目は データが
使用前に変更されていないこと

29
00:02:10,430 --> 00:02:15,469
２つ目は データが
望んだ形式や構造であることです

30
00:02:17,271 --> 00:02:21,642
データのライフサイクルを見ながら

31
00:02:21,742 --> 00:02:25,612
各段階で検証すべきことを
説明しましょう

32
00:02:26,613 --> 00:02:32,452
NSSecureCodingプロトコルでの
検証方法に触れ

33
00:02:32,953 --> 00:02:36,123
同じ概念をCodableで使います

34
00:02:37,024 --> 00:02:38,192
始めます

35
00:02:40,260 --> 00:02:46,200
データの説明のために
メンタルモデルを構築します

36
00:02:47,835 --> 00:02:53,173
最も基本的なデータは
バイトのストリームです

37
00:02:54,241 --> 00:02:59,847
よく見ないと分かりませんが
これがRAWデータです

38
00:03:01,548 --> 00:03:07,187
作業を進めるにあたり
既知の形式や構造に準拠させます

39
00:03:07,354 --> 00:03:12,259
今回はコードポイントが
UTF-8に対応しています

40
00:03:12,359 --> 00:03:15,229
読みやすくしましょう

41
00:03:15,329 --> 00:03:16,930
JSONのようです

42
00:03:17,664 --> 00:03:23,604
このようなデータを
フォーマット済みデータといいます

43
00:03:24,872 --> 00:03:29,877
このデータから
プリミティブ値を作り出します

44
00:03:29,977 --> 00:03:35,382
文字列 配列 辞書など
アルゴリズムに使う要素が

45
00:03:35,816 --> 00:03:37,818
プリミティブデータです

46
00:03:39,553 --> 00:03:45,726
最もよく使われる要素は
プリミティブ値ではなくモデル型で

47
00:03:46,426 --> 00:03:51,231
これを構造化データと呼んで
使用しています

48
00:03:52,566 --> 00:03:58,238
これらのデータ形式は
抽象化の順で時間軸に並びます

49
00:03:59,006 --> 00:04:02,242
RAWデータが
最も抽象的でなく

50
00:03:59,006 --> 00:04:02,242
RAWデータが
最も抽象的でなく

51
00:04:02,342 --> 00:04:05,279
構造化したモデル型は
最も抽象的

52
00:04:05,379 --> 00:04:10,317
今日は可能な限り
この図の先へ進みます

53
00:04:10,450 --> 00:04:14,388
アプリケーションは
どこでも止まれますが

54
00:04:14,488 --> 00:04:17,690
重要なのは
独自のモデル型です

55
00:04:18,625 --> 00:04:23,096
ただし今日の目標は
図の先に進むだけでなく

56
00:04:23,197 --> 00:04:25,933
信頼性を築くことです

57
00:04:26,366 --> 00:04:31,772
各段階でデータが複雑化し
検証内容も増えますが

58
00:04:31,872 --> 00:04:34,875
それで信頼性が増します

59
00:04:36,210 --> 00:04:39,847
フォーマット済みデータは省きます

60
00:04:39,947 --> 00:04:44,718
プリミティブへの
足がかりに過ぎないからです

61
00:04:45,619 --> 00:04:50,691
例えばJSONSerializationが
ありますが

62
00:04:50,791 --> 00:04:54,127
見ることも使うこともありません

63
00:04:54,895 --> 00:04:58,632
RAW プリミティブ 構造化に
着目します

64
00:05:00,100 --> 00:05:02,169
まずはRAWデータです

65
00:05:02,769 --> 00:05:07,841
先ほども言いましたが
バイトのストリームです

66
00:05:08,375 --> 00:05:12,713
調べて意味を与えないと
役に立ちません

67
00:05:13,680 --> 00:05:19,152
これを読み解く前に
見方を知った方がいいでしょう

68
00:05:19,253 --> 00:05:20,921
安全でしょうか？

69
00:05:21,922 --> 00:05:25,626
データの長さで検証ができます

70
00:05:26,226 --> 00:05:31,532
１キロバイトのはずが
１ギガバイトだったとします

71
00:05:32,132 --> 00:05:35,569
そんなデータを読み込みますか？

72
00:05:35,969 --> 00:05:37,237
やめますよね

73
00:05:38,572 --> 00:05:42,075
長さの予測ができない場合は

74
00:05:42,176 --> 00:05:45,846
おそらく外部データなのでしょう

75
00:05:46,813 --> 00:05:51,485
チェックサムや電子署名でも
検証が可能です

76
00:05:51,585 --> 00:05:55,455
中身が不明でも性質が表れます

77
00:05:56,023 --> 00:05:58,392
チェックサムはハッシュ化します

78
00:05:58,492 --> 00:06:02,963
原因が何であれ小さな変化があると

79
00:05:58,492 --> 00:06:02,963
原因が何であれ小さな変化があると

80
00:06:03,063 --> 00:06:07,334
ブロックや接続に不具合が生じます

81
00:06:07,534 --> 00:06:12,439
チェックサムや電子署名が
無効になるので

82
00:06:12,539 --> 00:06:17,544
読み込む前に
信頼できないと分かります

83
00:06:19,279 --> 00:06:24,418
しかし チェックサムが
常に働くとは限らないので

84
00:06:24,518 --> 00:06:29,523
この段階でできるのは
読んで検証するくらいです

85
00:06:30,557 --> 00:06:33,594
次はプリミティブデータです

86
00:06:34,661 --> 00:06:37,331
RAWデータから生成し

87
00:06:37,431 --> 00:06:41,735
JSONSerializationなどを
通過させます

88
00:06:42,769 --> 00:06:47,741
これで使える文字列と辞書
数字の配列を得て

89
00:06:48,008 --> 00:06:50,978
２つのことが分かります

90
00:06:52,212 --> 00:06:55,182
１つ目はデータ形式の適切性

91
00:06:55,282 --> 00:06:58,585
XMLはJSONSerializationを
通りません

92
00:06:59,620 --> 00:07:02,222
２つ目はデシリアライザの信頼性

93
00:06:59,620 --> 00:07:02,222
２つ目はデシリアライザの信頼性

94
00:07:02,322 --> 00:07:06,260
Runtimeオブジェクトは有効です

95
00:07:06,393 --> 00:07:11,832
JSONSerializationで
文字列 数字 配列を得られます

96
00:07:12,332 --> 00:07:14,434
この値は信頼できます

97
00:07:15,802 --> 00:07:17,771
ここで知りたいのは

98
00:07:17,871 --> 00:07:22,776
データの使用法や信頼性
他に必要な検証です

99
00:07:24,645 --> 00:07:30,083
このデータの内容は
調べないと分かりません

100
00:07:30,417 --> 00:07:34,955
データの構造も
まったく不明でしょう

101
00:07:35,255 --> 00:07:40,127
動的なデシリアライゼーションは
ダウンキャストを生みます

102
00:07:40,360 --> 00:07:44,064
データの行く末を予測できません

103
00:07:44,398 --> 00:07:48,268
データの中身の確認が必要です

104
00:07:49,503 --> 00:07:54,675
開発中の「Sell My Old Junk」を
例に挙げましょう

105
00:07:54,775 --> 00:07:58,312
不用品を売るための
アプリケーションです

106
00:07:58,712 --> 00:08:03,584
アプリケーションを開くと
サーバに要求が出ます

107
00:07:58,712 --> 00:08:03,584
アプリケーションを開くと
サーバに要求が出ます

108
00:08:03,851 --> 00:08:08,989
販売中の商品リストを求める
リクエストです

109
00:08:10,123 --> 00:08:15,596
サーバはJSONを使い
商品リストを返します

110
00:08:17,197 --> 00:08:20,968
こちらがAPIのレスポンスです

111
00:08:21,502 --> 00:08:25,906
リストの配列に
面白いフィールドがあります

112
00:08:27,241 --> 00:08:32,913
例えば“製品ID”です
自然数で製品を識別しています

113
00:08:33,013 --> 00:08:36,383
ここでは連続した整数ですね

114
00:08:37,317 --> 00:08:40,220
“名前”と“説明”は文字列です

115
00:08:40,320 --> 00:08:43,123
他にも注目点があります

116
00:08:43,991 --> 00:08:48,695
例えば在庫を
ブーリアン型で示しています

117
00:08:49,930 --> 00:08:54,535
構造タグのリストは
文字列で記されます

118
00:08:55,969 --> 00:08:58,639
文字列は他にもありますが

119
00:08:58,739 --> 00:09:04,111
URLや日付など
形式の異なるデータは要注意です

120
00:08:58,739 --> 00:09:04,111
URLや日付など
形式の異なるデータは要注意です

121
00:09:05,612 --> 00:09:07,181
これらを使います

122
00:09:07,781 --> 00:09:11,718
URLSessionでデータをフェッチし

123
00:09:11,818 --> 00:09:13,520
長さを検証します

124
00:09:13,620 --> 00:09:17,825
サーバがチェックサムを
生成するかもしれません

125
00:09:19,960 --> 00:09:23,964
次にJSONSerializationに
データを渡します

126
00:09:24,531 --> 00:09:29,836
デシリアライズするのに失敗すると
エラーが投げられ

127
00:09:29,937 --> 00:09:32,072
顧客に知らせます

128
00:09:33,640 --> 00:09:40,447
これで RAWデータから
プリミティブデータができました

129
00:09:40,681 --> 00:09:43,116
失敗しても修正できます

130
00:09:44,484 --> 00:09:47,487
このデータの使い方は？

131
00:09:47,688 --> 00:09:51,658
JSONは
実際の値を持つ変数なので

132
00:09:51,892 --> 00:09:55,729
辞書の配列に
ダウンキャストできます

133
00:09:56,663 --> 00:10:00,100
ここでは音楽関連のリストに絞り

134
00:09:56,663 --> 00:10:00,100
ここでは音楽関連のリストに絞り

135
00:10:00,334 --> 00:10:04,071
musicタグのない製品を外します

136
00:10:04,171 --> 00:10:09,776
タグリストが文字列の配列を
ダウンキャストします

137
00:10:11,478 --> 00:10:12,479
大変です

138
00:10:13,780 --> 00:10:17,618
ダウンキャストに
致命的なエラーです

139
00:10:18,151 --> 00:10:19,853
片方が失敗するのは

140
00:10:19,953 --> 00:10:25,025
APIやデータが
組み込まれる前に変わったからです

141
00:10:25,125 --> 00:10:27,594
データの破損や悪意ある変更で

142
00:10:28,228 --> 00:10:29,630
両方 失敗します

143
00:10:29,730 --> 00:10:35,536
アプリケーションがクラッシュし
顧客に悪い印象を与えます

144
00:10:36,670 --> 00:10:38,405
原因を探ります

145
00:10:39,006 --> 00:10:41,742
これはAPIのレスポンスです

146
00:10:42,509 --> 00:10:44,878
タグリストに注目します

147
00:10:45,512 --> 00:10:49,216
２つ目のタグが文字列ではなく

148
00:10:49,483 --> 00:10:51,451
数字に変わっています

149
00:10:51,552 --> 00:10:56,323
第三者の仕業か通常の破損かは
分かりません

150
00:10:57,791 --> 00:11:02,229
この変更でダウンキャストが
失敗するのです

151
00:10:57,791 --> 00:11:02,229
この変更でダウンキャストが
失敗するのです

152
00:11:02,329 --> 00:11:05,332
事前の確認はしませんでした

153
00:11:06,867 --> 00:11:12,072
常に検証して実行すれば
失敗は避けられます

154
00:11:13,073 --> 00:11:17,244
分かっていると言う前に
確認しましょう

155
00:11:17,344 --> 00:11:18,879
過信は危険です

156
00:11:19,313 --> 00:11:20,848
対策を考えます

157
00:11:21,548 --> 00:11:24,117
再び最初のダウンキャストです

158
00:11:24,218 --> 00:11:29,122
値を強制的ではなく
条件付きでダウンキャストします

159
00:11:32,559 --> 00:11:34,995
これで検証が可能です

160
00:11:35,529 --> 00:11:38,098
必要な内容を含んでいます

161
00:11:38,198 --> 00:11:40,167
もし失敗しても

162
00:11:40,634 --> 00:11:43,370
致命的にはなりません

163
00:11:44,438 --> 00:11:48,041
２つ目も同様に
ダウンキャストします

164
00:11:48,141 --> 00:11:52,412
強制的ではなく
条件付きで行うのです

165
00:11:52,513 --> 00:11:58,018
これだとエラーを投げず
デフォルト値で実行でき

166
00:11:58,118 --> 00:12:02,789
有効なタグリストがないと
無視できます

167
00:11:58,118 --> 00:12:02,789
有効なタグリストがないと
無視できます

168
00:12:03,123 --> 00:12:06,059
エラーを投げない選択です

169
00:12:07,794 --> 00:12:12,966
この段階では
型以外の検証も行いたいですね

170
00:12:13,367 --> 00:12:17,738
nullに換えるとJSONで有効です

171
00:12:19,006 --> 00:12:20,974
クラッシュしません

172
00:12:22,109 --> 00:12:25,746
Swiftでnull化可能性は
型の一部です

173
00:12:25,846 --> 00:12:30,851
nullは文字列に
ダウンキャストできません

174
00:12:32,820 --> 00:12:36,223
すべて正しい型のnull化可能でも

175
00:12:36,323 --> 00:12:39,193
要注意の検証事項があります

176
00:12:39,827 --> 00:12:45,666
製品リストには連続した自然数の
IDが付いていますが

177
00:12:45,933 --> 00:12:48,635
負の数でも平気でしょうか？

178
00:12:49,102 --> 00:12:50,103
ダメです

179
00:12:50,204 --> 00:12:55,542
正の数だとしても
非常に大きな値はどうでしょう？

180
00:12:55,943 --> 00:12:57,845
商品が多すぎます

181
00:12:57,945 --> 00:13:03,083
誰かがオーバーフローを
狙っているかもしれません

182
00:12:57,945 --> 00:13:03,083
誰かがオーバーフローを
狙っているかもしれません

183
00:13:03,517 --> 00:13:05,452
警戒が必要です

184
00:13:06,920 --> 00:13:09,823
値域と長さの検証は似ています

185
00:13:10,057 --> 00:13:13,193
各商品に説明がありますが

186
00:13:13,560 --> 00:13:15,896
空白でも大丈夫でしょうか？

187
00:13:16,797 --> 00:13:20,100
私は製品をアップするたびに

188
00:13:20,300 --> 00:13:24,738
説明を書くので
空白だと間違っています

189
00:13:26,206 --> 00:13:31,111
説明があっても
長い戯曲が書かれていたら？

190
00:13:31,211 --> 00:13:35,516
これも変です
何かが間違っています

191
00:13:37,951 --> 00:13:40,787
さて 追加の検証があります

192
00:13:40,888 --> 00:13:46,226
型が正しく null化可能で
値域と長さが適切なら

193
00:13:46,326 --> 00:13:49,329
その値も内容も重要でしょう

194
00:13:50,197 --> 00:13:55,402
各製品には詳細を見られるURLも
付いています

195
00:13:55,936 --> 00:13:59,439
これは文字列のようですが
実際はURLです

196
00:13:59,540 --> 00:14:03,577
任意の文字列は
ふさわしくありません

197
00:13:59,540 --> 00:14:03,577
任意の文字列は
ふさわしくありません

198
00:14:03,877 --> 00:14:07,047
URLだという確認が要ります

199
00:14:07,548 --> 00:14:12,820
たとえURLでも
私のドメインとは限りません

200
00:14:12,920 --> 00:14:15,355
細心の注意が必要です

201
00:14:15,456 --> 00:14:17,524
顧客の安全は重要です

202
00:14:17,624 --> 00:14:19,760
私が送ったURLで

203
00:14:19,860 --> 00:14:24,398
フィッシングサイトに
誘導してはいけません

204
00:14:25,332 --> 00:14:27,935
ここは用心が必要です

205
00:14:29,436 --> 00:14:31,705
各フィールドが有効でも

206
00:14:31,805 --> 00:14:35,809
関係性が問題となる場合もあります

207
00:14:36,910 --> 00:14:41,548
リストの作成日と更新日を
書くとします

208
00:14:42,115 --> 00:14:43,750
それぞれ有効でも

209
00:14:43,851 --> 00:14:48,455
最後の更新日が
作成日の前では変です

210
00:14:48,989 --> 00:14:53,060
この例では安全性に関わりません

211
00:14:53,160 --> 00:14:59,366
しかし注意は必要です
変なデータは信頼できません

212
00:15:00,767 --> 00:15:02,903
何から始めましょう？

213
00:15:03,604 --> 00:15:08,775
あるリストの全内容を
検証する関数を書きます

214
00:15:09,710 --> 00:15:13,080
まずリストの製品IDを出します

215
00:15:13,614 --> 00:15:19,253
強制的ではなく条件付きで
ダウンキャストしましょう

216
00:15:19,453 --> 00:15:22,589
失敗するとエラーを投げます

217
00:15:23,524 --> 00:15:28,795
ここでは止まらず
製品IDを値域で検証します

218
00:15:28,896 --> 00:15:30,564
適切でした

219
00:15:30,664 --> 00:15:33,167
変だとエラーが出ます

220
00:15:36,904 --> 00:15:39,606
次にURLを確認しますが

221
00:15:39,706 --> 00:15:43,844
強制的なダウンキャストは避けます

222
00:15:44,211 --> 00:15:45,412
リンクです

223
00:15:45,512 --> 00:15:48,982
私のサーバは
長いURLを作りません

224
00:15:49,082 --> 00:15:52,753
とても長いURLなら無効です

225
00:15:54,021 --> 00:15:58,592
有効ならばURL型へ送り
ドメイン用の検証を行い

226
00:15:58,692 --> 00:16:01,662
本当にURLか確認します

227
00:15:58,692 --> 00:16:01,662
本当にURLか確認します

228
00:16:01,762 --> 00:16:04,431
変ならエラーを投げます

229
00:16:05,699 --> 00:16:09,002
本当のURLだと分かったら

230
00:16:09,102 --> 00:16:13,974
私のドメインかどうか
続けて検証します

231
00:16:15,309 --> 00:16:18,812
同種の検証を別項目でも使えます

232
00:16:18,912 --> 00:16:21,415
変ならエラーを投げます

233
00:16:21,682 --> 00:16:26,620
関数はダウンロードした
全リストに適用します

234
00:16:27,387 --> 00:16:31,024
変な場所があれば実行を止めます

235
00:16:33,827 --> 00:16:39,800
このように検証しましたが
プリミティブデータは総体的です

236
00:16:40,601 --> 00:16:45,906
文字列は 場合により
日付にもなることが可能です

237
00:16:46,406 --> 00:16:48,809
URLにもなり得ます

238
00:16:50,244 --> 00:16:54,581
セマンティクスが
気になる時もあります

239
00:16:54,681 --> 00:17:00,220
通常の文字列ではなく
自分のURLか確認を要します

240
00:16:54,681 --> 00:17:00,220
通常の文字列ではなく
自分のURLか確認を要します

241
00:17:01,388 --> 00:17:05,459
辞書はリストなどモデルを示します

242
00:17:05,559 --> 00:17:09,195
または未知の顧客データを示します

243
00:17:10,097 --> 00:17:14,768
同じ検証で
すべてを確認するのではなく

244
00:17:14,867 --> 00:17:19,406
保証された独自のモデル型を
使いたいですよね

245
00:17:21,108 --> 00:17:25,679
できれば 構造化データに
したいと思いました

246
00:17:25,779 --> 00:17:30,484
プリミティブデータよりも
魅力を感じます

247
00:17:31,251 --> 00:17:32,853
どうしましょう？

248
00:17:35,422 --> 00:17:39,560
アプリケーションに
Purchase型があります

249
00:17:40,460 --> 00:17:43,931
データがディスクに保存され

250
00:17:44,031 --> 00:17:49,169
ネットワークに繋がなくても
購入履歴が分かります

251
00:17:50,003 --> 00:17:53,273
関連する商品リストを追跡し

252
00:17:53,373 --> 00:17:56,810
購入するとレシートが出ます

253
00:17:58,245 --> 00:18:03,417
NSCodingとNSKeyを使い
データを保存します

254
00:17:58,245 --> 00:18:03,417
NSCodingとNSKeyを使い
データを保存します

255
00:18:04,051 --> 00:18:09,957
解凍したRAWデータと
プリミティブデータは検証します

256
00:18:10,624 --> 00:18:14,194
符号化の働きを見てみましょう

257
00:18:14,495 --> 00:18:17,364
これに見覚えはありませんか？

258
00:18:17,698 --> 00:18:20,334
まずリストを復号化します

259
00:18:20,434 --> 00:18:24,638
条件付きダウンキャストを
行ってください

260
00:18:25,072 --> 00:18:29,543
初期化子なので
変でもnilを返すだけです

261
00:18:30,978 --> 00:18:35,282
復号されると
プロパティに割り当てられます

262
00:18:35,649 --> 00:18:39,286
購入データも日付に
ダウンキャストします

263
00:18:39,386 --> 00:18:41,922
何か変だと失敗します

264
00:18:42,022 --> 00:18:44,324
これを繰り返します

265
00:18:45,859 --> 00:18:50,697
購入履歴を残したい時は
関数を使うことで

266
00:18:50,797 --> 00:18:54,501
バイナリデータに保存できます

267
00:18:55,169 --> 00:18:59,506
ディスクやデータベースにも
残せます

268
00:19:01,041 --> 00:19:05,612
ロードして戻したいなら
同様にRAWデータを得て

269
00:19:05,846 --> 00:19:09,650
KeyedUnarchiverに渡すと
オブジェクトが戻ります

270
00:19:11,318 --> 00:19:15,122
データは複雑になっていきます

271
00:19:15,222 --> 00:19:18,826
信頼するために行う検証も増えます

272
00:19:19,359 --> 00:19:21,562
問題は何でしょう？

273
00:19:21,662 --> 00:19:23,430
検証がまだなのは？

274
00:19:23,831 --> 00:19:26,533
このダウンキャストがヒントです

275
00:19:27,901 --> 00:19:31,972
オブジェクトの解凍後に
ダウンキャストしました

276
00:19:32,606 --> 00:19:34,341
失敗はあり得ません

277
00:19:35,142 --> 00:19:37,444
何かが起きています

278
00:19:37,544 --> 00:19:39,046
説明しましょう

279
00:19:40,614 --> 00:19:45,285
これはアーカイブ内の
モデルオブジェクトです

280
00:19:46,153 --> 00:19:48,889
全項目がコーディングされ

281
00:19:48,989 --> 00:19:53,093
それぞれが
構造やコンテンツを持ちます

282
00:19:53,727 --> 00:19:55,329
興味深いことに

283
00:19:55,596 --> 00:20:00,434
オブジェクトのクラス名も
含んでいます

284
00:19:55,596 --> 00:20:00,434
オブジェクトのクラス名も
含んでいます

285
00:20:01,401 --> 00:20:04,671
KeyedUnarchiverの働きを見ます

286
00:20:05,239 --> 00:20:08,275
先ほど復号コールで

287
00:20:08,375 --> 00:20:13,046
KeyedUnarchiverを生成し
オブジェクトを復号化します

288
00:20:14,681 --> 00:20:20,020
KeyedUnarchiverは
オブジェクトのクラス名を見つけ

289
00:20:20,120 --> 00:20:21,321
取り出します

290
00:20:21,555 --> 00:20:25,125
同時に同名のクラスを探します

291
00:20:26,560 --> 00:20:29,696
クラスのインスタンスを割り当て

292
00:20:29,797 --> 00:20:33,567
コンテンツを復号するため
初期化します

293
00:20:34,635 --> 00:20:38,472
そのあとオブジェクトを
呼び起こします

294
00:20:40,807 --> 00:20:43,243
これは効果的です

295
00:20:43,343 --> 00:20:47,047
しかし想定外のクラスを含むと

296
00:20:47,147 --> 00:20:50,017
どうなるのでしょう？

297
00:20:51,452 --> 00:20:55,656
こちらの全過程が
別の型で行われます

298
00:20:56,390 --> 00:21:02,029
想定外のクラスを割り当て
初期化して呼び起こします

299
00:20:56,390 --> 00:21:02,029
想定外のクラスを割り当て
初期化して呼び起こします

300
00:21:02,796 --> 00:21:04,364
その影響は？

301
00:21:06,033 --> 00:21:08,702
先ほどの
条件付きダウンキャストが

302
00:21:08,802 --> 00:21:12,639
想定外のクラスを避けてくれます

303
00:21:12,739 --> 00:21:15,776
想定した型のみ使えるのです

304
00:21:15,876 --> 00:21:18,345
ダウンキャストが失敗なら失敗です

305
00:21:20,714 --> 00:21:24,484
復号はアプリケーションに
影響を与えます

306
00:21:24,585 --> 00:21:28,522
allocメソッドは
大域状態を変えます

307
00:21:28,622 --> 00:21:31,959
Singletonを割り当てるでしょう

308
00:21:33,393 --> 00:21:37,764
オブジェクトを投げて
失敗すると衝撃が続き

309
00:21:37,865 --> 00:21:40,334
誤作動につながります

310
00:21:40,434 --> 00:21:45,806
悪影響を与えるアーカイブが
構築される可能性も

311
00:21:46,640 --> 00:21:49,209
これを防ぐ検証方法は？

312
00:21:50,177 --> 00:21:52,913
NSSecureCodingの出番です

313
00:21:53,781 --> 00:21:57,551
これはNSCodingを継承する
プロトコルで

314
00:21:57,851 --> 00:22:01,655
この種の攻撃を防ぐ目的で
作られました

315
00:21:57,851 --> 00:22:01,655
この種の攻撃を防ぐ目的で
作られました

316
00:22:02,890 --> 00:22:08,629
任意のコードの実行を防ぐために
型の情報を事前に渡し

317
00:22:08,729 --> 00:22:14,001
アーカイブを検証して
想定内の型のみだと確認します

318
00:22:15,903 --> 00:22:21,208
オブジェクトを復号化する
代替メソッドが２つあるため

319
00:22:21,308 --> 00:22:24,177
先に型の情報を渡せます

320
00:22:24,645 --> 00:22:28,015
これでNSKeyedUnarchiverが
安全を守ります

321
00:22:28,949 --> 00:22:33,687
主要なコールの
復号化オブジェクトを見ましょう

322
00:22:34,655 --> 00:22:38,659
Variant型を使うと
先にクラスを渡すので

323
00:22:38,792 --> 00:22:40,928
Purchaseを復号します

324
00:22:41,428 --> 00:22:45,099
アーカイブの内容に関わらず

325
00:22:45,599 --> 00:22:48,168
まずクラスを確認します

326
00:22:49,102 --> 00:22:51,205
この説明をします

327
00:22:52,839 --> 00:22:55,475
セキュアコーディングがあると

328
00:22:55,576 --> 00:22:59,646
NSKeyedUnarchiverは
クラスリストを維持します

329
00:23:01,048 --> 00:23:06,854
このようなコールで
使ったオブジェクトを取り出し

330
00:23:06,954 --> 00:23:09,456
許容クラスリストを作ります

331
00:23:10,858 --> 00:23:13,927
アーカイブのオブジェクトを
復号化すると

332
00:23:14,027 --> 00:23:17,264
そのクラスがチェックされます

333
00:23:17,364 --> 00:23:21,301
リストにないと
コールは却下されます

334
00:23:22,769 --> 00:23:27,407
オブジェクトのクラスが
リストにある場合は

335
00:23:27,508 --> 00:23:29,643
いくつか確認します

336
00:23:30,510 --> 00:23:35,082
NSSecureCodingに合う
クラスでないとダメです

337
00:23:35,816 --> 00:23:41,321
違うと 自身の復号化を
続けるのも安全と言えず

338
00:23:41,422 --> 00:23:44,424
オブジェクトを復号化できません

339
00:23:44,892 --> 00:23:48,862
このPurchaseクラスは大丈夫です

340
00:23:49,997 --> 00:23:54,368
親と子のクラスに関する
確認もあります

341
00:23:55,602 --> 00:24:00,307
親と子の両クラスが
NSCodingに従い

342
00:23:55,602 --> 00:24:00,307
親と子の両クラスが
NSCodingに従い

343
00:24:00,407 --> 00:24:03,710
親はNSSecureCodingにも
適合します

344
00:24:03,911 --> 00:24:06,580
子はその適合性を継承します

345
00:24:07,748 --> 00:24:13,420
子クラスがinitを
書き換えられない場合があるので

346
00:24:13,687 --> 00:24:15,455
対策を用意しました

347
00:24:17,024 --> 00:24:19,593
セキュアコーディングは

348
00:24:19,693 --> 00:24:22,196
使わなくても平気です

349
00:24:22,296 --> 00:24:25,599
まだ自分には早いと言えばいい

350
00:24:26,733 --> 00:24:29,303
それでも必要なら

351
00:24:29,403 --> 00:24:35,542
NSSecureCodingへの適合性を
親クラスから継承してください

352
00:24:35,642 --> 00:24:40,781
または両方のメソッドを
オーバーライドしても

353
00:24:40,881 --> 00:24:42,483
適合します

354
00:24:44,084 --> 00:24:49,022
このPurchaseは
両方の要求を満たしています

355
00:24:51,492 --> 00:24:55,462
Purchaseとリストを復号化すると

356
00:24:55,562 --> 00:24:59,333
同型のコールで
リストを要求できます

357
00:25:01,001 --> 00:25:06,140
NSKeyedUnarchiverが作る
新しい許容リストが

358
00:25:06,240 --> 00:25:09,009
すべての照合先となります

359
00:25:09,810 --> 00:25:15,282
復号化すると同じ確認をしますが
これは有効です

360
00:25:17,751 --> 00:25:23,624
想定外のクラスオブジェクトは
リストになく却下されます

361
00:25:25,659 --> 00:25:28,762
どのように却下するのでしょう？

362
00:25:28,862 --> 00:25:33,500
“復号化の失敗”は
他にも注意すべき点があります

363
00:25:33,634 --> 00:25:38,038
セキュアコーディングの違反も
見られますが

364
00:25:38,138 --> 00:25:40,140
他の原因もあります

365
00:25:41,275 --> 00:25:43,477
例えば型の不一致です

366
00:25:43,577 --> 00:25:48,649
オブジェクトの場所に
プリミティブ値があるかも

367
00:25:48,982 --> 00:25:52,052
プリミティブを復号化したいのに

368
00:25:52,152 --> 00:25:56,523
オブジェクトなどを
見つけるかもしれません

369
00:25:56,957 --> 00:25:58,792
失敗の原因です

370
00:26:00,460 --> 00:26:02,763
他の失敗もあり得ます

371
00:26:02,863 --> 00:26:09,269
アーカイブが激しく破損し
NSKeyedUnarchiverに合わないと

372
00:26:09,369 --> 00:26:10,971
復号化できません

373
00:26:11,071 --> 00:26:12,940
同様の失敗です

374
00:26:14,808 --> 00:26:20,681
decodingFailurePolicyが
失敗への対処を決定します

375
00:26:20,781 --> 00:26:22,015
選択肢は２つ

376
00:26:22,750 --> 00:26:24,918
例外を発生させるか

377
00:26:25,686 --> 00:26:29,356
情報を保存できるなら
実行を続けます

378
00:26:29,823 --> 00:26:32,259
今の設定は例外の発生です

379
00:26:33,927 --> 00:26:38,265
これはリストを復号化する
コールです

380
00:26:38,365 --> 00:26:41,668
想定外のクラスを見つけると

381
00:26:42,069 --> 00:26:45,772
failWithErrorメソッドが呼ばれ

382
00:26:46,039 --> 00:26:49,476
事象や場所を示すエラーが
渡されます

383
00:26:50,477 --> 00:26:53,614
failWithErrorは決定します

384
00:26:54,047 --> 00:26:58,819
decodingFailurePolicyが
例外を発生させます

385
00:26:59,253 --> 00:27:02,022
Swiftだと心配でしょう

386
00:26:59,253 --> 00:27:02,022
Swiftだと心配でしょう

387
00:27:02,289 --> 00:27:07,728
Objective-CやC++の例外を
認知できないためです

388
00:27:08,061 --> 00:27:11,832
クラッシュや満足度低下の
原因となります

389
00:27:13,267 --> 00:27:16,236
decodingFailurePolicyが
エラーを設定すると

390
00:27:16,336 --> 00:27:21,375
エラーはUnarchiverに割り当てられ
実行は継続します

391
00:27:21,642 --> 00:27:26,480
この例では
復号化のコールが何かを返します

392
00:27:26,580 --> 00:27:30,150
何も復号できない時はnilです

393
00:27:31,752 --> 00:27:38,025
プリミティブ型を復号するのに
不適切な型がある場合も

394
00:27:38,125 --> 00:27:39,760
同じ流れです

395
00:27:39,860 --> 00:27:43,997
この場合 nilではなく
ゼロが返されます

396
00:27:47,568 --> 00:27:50,104
failWithErrorは
NSKeyedUnarchiverのAPIです

397
00:27:50,204 --> 00:27:55,175
独自のコードで
失敗の日時や原因を示しましょう

398
00:27:55,542 --> 00:28:00,013
failWithErrorはnilを返さず
情報を記録します

399
00:27:55,542 --> 00:28:00,013
failWithErrorはnilを返さず
情報を記録します

400
00:28:01,315 --> 00:28:03,484
注意事項があります

401
00:28:04,384 --> 00:28:07,421
decodingFailurePolicyが
エラーを設定する際

402
00:28:07,521 --> 00:28:12,025
Unarchiver上だと
あとで変更できません

403
00:28:12,726 --> 00:28:17,564
復号化の失敗は
連鎖することが多いからです

404
00:28:17,664 --> 00:28:20,134
最初の情報が重要です

405
00:28:22,269 --> 00:28:25,205
所定のfailWithErrorコールは

406
00:28:25,305 --> 00:28:30,477
例外を投げるか 実行を続けると
覚えていてください

407
00:28:30,577 --> 00:28:34,047
特にObjective-Cは
例外が見つけやすく

408
00:28:34,181 --> 00:28:35,716
対処できます

409
00:28:37,017 --> 00:28:39,887
nilやゼロの戻り値は

410
00:28:40,354 --> 00:28:45,826
エラーを設定し戻す場合に
復号化の失敗で生じます

411
00:28:45,926 --> 00:28:50,731
またはデータが消えたか
nilで符号化したかです

412
00:28:50,964 --> 00:28:55,335
エラーのプロパティで
原因が分かります

413
00:28:57,604 --> 00:28:59,640
盛りだくさんですね

414
00:28:59,807 --> 00:29:04,645
NSSecureCodingを導入する
方法を確認しましょう

415
00:28:59,807 --> 00:29:04,645
NSSecureCodingを導入する
方法を確認しましょう

416
00:29:05,345 --> 00:29:11,552
まずオブジェクトを変換して
先に型の情報を渡します

417
00:29:12,586 --> 00:29:17,424
問題があればfailWithErrorで
事象を記録します

418
00:29:18,559 --> 00:29:24,364
これは未検証の場所の失敗を調べる
すばらしい機会です

419
00:29:24,698 --> 00:29:26,033
ぜひ行いましょう

420
00:29:27,134 --> 00:29:30,304
リストを復号化するコールです

421
00:29:30,404 --> 00:29:35,976
型の情報を渡すと
条件付きダウンキャストが消えます

422
00:29:36,844 --> 00:29:41,014
ジェネリックのオーバーロードに
型情報を渡すと

423
00:29:41,115 --> 00:29:46,286
条件付きダウンキャストが
不要になるのです

424
00:29:47,488 --> 00:29:52,326
失敗はnilを返すだけでなく
有意義にしたいので

425
00:29:52,426 --> 00:29:56,497
事象と場所の分かるエラーにします

426
00:29:57,064 --> 00:30:00,534
CocoaErrorの機能を使用して

427
00:29:57,064 --> 00:30:00,534
CocoaErrorの機能を使用して

428
00:30:00,634 --> 00:30:05,539
問題の場所と事象を示す
エラーを返します

429
00:30:06,740 --> 00:30:10,911
デバッグの記録を
残すこともできます

430
00:30:11,011 --> 00:30:14,581
しかし nilの前に
failWithErrorが必要です

431
00:30:16,950 --> 00:30:20,320
ここで購入日を復号化しています

432
00:30:20,787 --> 00:30:25,626
初めての場所で
さらなる検証を加えています

433
00:30:26,527 --> 00:30:30,164
日付を復号化できても保存せず

434
00:30:30,430 --> 00:30:33,300
有効な日付か確認します

435
00:30:33,400 --> 00:30:39,072
アプリケーションの配信前は
購入できないはずです

436
00:30:39,173 --> 00:30:43,510
ここでも問題があれば
有意義な失敗にします

437
00:30:44,211 --> 00:30:45,979
データはありますが

438
00:30:46,079 --> 00:30:50,384
破損しているか
無効のデータのようです

439
00:30:53,220 --> 00:30:56,590
同じことを私たちの型で行いました

440
00:30:56,690 --> 00:31:00,260
セキュアコーディングが
要求できます

441
00:30:56,690 --> 00:31:00,260
セキュアコーディングが
要求できます

442
00:31:00,661 --> 00:31:05,199
ランタイムに示さず
NSSecureCodingに適合させる

443
00:31:05,299 --> 00:31:08,535
これが私たちの目的でした

444
00:31:10,404 --> 00:31:14,875
そしてNSSecureCodingバッジを
獲得しました

445
00:31:14,975 --> 00:31:16,710
実物は別売です

446
00:31:19,346 --> 00:31:23,884
NSSecureCodingバッジの獲得は
重要だと思います

447
00:31:23,984 --> 00:31:26,653
今年は新APIと
NSKeyedUnarchiverを加え

448
00:31:26,753 --> 00:31:29,957
NSSecureCodingを使います

449
00:31:31,191 --> 00:31:35,362
これらはセキュアコーディングが
デフォルトで

450
00:31:35,462 --> 00:31:39,133
指針のデフォルトは
setErrorAndReturnです

451
00:31:39,233 --> 00:31:44,071
指針を変えなければ
例外の心配も要りません

452
00:31:45,539 --> 00:31:50,744
古い初期化子やメソッドは
非推奨となります

453
00:31:50,844 --> 00:31:52,579
新しくしてください

454
00:31:53,680 --> 00:31:57,351
NSKeyedArchiverのAPIも
紹介しました

455
00:31:57,451 --> 00:32:01,889
セキュアコーディングが
簡単に使えます

456
00:31:57,451 --> 00:32:01,889
セキュアコーディングが
簡単に使えます

457
00:32:01,989 --> 00:32:07,361
NSSecureCodingに合わない
オブジェクトの保存を防ぎ

458
00:32:07,461 --> 00:32:09,463
あとで復号できません

459
00:32:10,464 --> 00:32:13,734
古い初期化子とメソッドは
非推奨です

460
00:32:13,867 --> 00:32:16,803
古いコードはこうなります

461
00:32:17,171 --> 00:32:20,140
保存にSecureCodingを使います

462
00:32:20,440 --> 00:32:24,812
これを型情報を渡すメソッドに
換えます

463
00:32:25,512 --> 00:32:29,850
ここでSecureCodingバッジが
使えます

464
00:32:31,018 --> 00:32:35,055
自分の型が合わないか
または 合わない型に依存して―

465
00:32:35,155 --> 00:32:40,394
セキュアコーディングを
使えなくても大丈夫です

466
00:32:40,661 --> 00:32:44,231
Nコードでは要求が止まり

467
00:32:44,331 --> 00:32:48,001
デコードではSecureCodingが
常に使用可能に

468
00:32:48,735 --> 00:32:52,172
新しい初期化子で
KeyedUnarchiverを作ります

469
00:32:52,272 --> 00:32:54,975
SecureCodingは
手動で止めます

470
00:32:55,876 --> 00:33:01,381
decodingFailurePolicyは
必要ならデフォルトに戻せます

471
00:32:55,876 --> 00:33:01,381
decodingFailurePolicyは
必要ならデフォルトに戻せます

472
00:33:02,883 --> 00:33:06,520
Unarchiverがあれば
復号ができます

473
00:33:08,889 --> 00:33:10,591
Swiftを使えば

474
00:33:10,691 --> 00:33:16,430
NSSecureCoding以外でも
モデル型を変換できます

475
00:33:17,631 --> 00:33:22,269
昨年はSwift 4で
Codableプロトコルを紹介しました

476
00:33:22,870 --> 00:33:27,541
NSSecureCodingで下された
設計の決定を

477
00:33:27,641 --> 00:33:30,177
Codableは初日から示しました

478
00:33:31,011 --> 00:33:34,915
Codableは型の情報を書かないので

479
00:33:35,015 --> 00:33:37,017
何も信頼できません

480
00:33:37,117 --> 00:33:42,189
復号したい静的な型の情報を
先に要求することで

481
00:33:42,289 --> 00:33:44,792
この種の攻撃を防げます

482
00:33:46,260 --> 00:33:50,998
フィールドの中が
すべてCodableな型があると

483
00:33:51,098 --> 00:33:55,302
initの実装を統合して
要求を符号化します

484
00:33:55,936 --> 00:34:00,040
統合された実装は型と
null化可能性をチェックします

485
00:33:55,936 --> 00:34:00,040
統合された実装は型と
null化可能性をチェックします

486
00:34:00,140 --> 00:34:05,846
しかし 外部ソースの型は
多くが追加の検証を要します

487
00:34:06,680 --> 00:34:08,549
さらに検証します

488
00:34:09,750 --> 00:34:14,353
デコーダのinitで上書きすると
可能になります

489
00:34:14,455 --> 00:34:17,491
やはりJSONはレスポンスが早く

490
00:34:17,591 --> 00:34:22,728
同名のフィールドで型を作り
Codable型に変えます

491
00:34:23,630 --> 00:34:28,469
すべてCodableなので
initの実装を得て符号化します

492
00:34:28,802 --> 00:34:34,341
プリミティブ値の時と同じ検証を
行いたいと思います

493
00:34:34,908 --> 00:34:37,344
やり方は同じです

494
00:34:38,478 --> 00:34:43,784
ペイロードのIDを
古いコードが復号した場所で

495
00:34:43,884 --> 00:34:47,387
デコーダの整数を復号します

496
00:34:48,422 --> 00:34:51,692
ペイロードの型が異なったりすると

497
00:34:51,792 --> 00:34:55,094
事象を示すエラーを投げます

498
00:34:56,330 --> 00:35:01,568
さらに重要なのは
メソッドのために加えた検証です

499
00:34:56,330 --> 00:35:01,568
さらに重要なのは
メソッドのために加えた検証です

500
00:35:02,002 --> 00:35:06,406
同じ検証を続けて
IDの有効性を確認します

501
00:35:06,507 --> 00:35:11,044
ここでは
エラーを投げるメソッドが使えます

502
00:35:13,380 --> 00:35:18,052
文字列として日付を生成する
関数を検証し

503
00:35:18,152 --> 00:35:23,624
それをフォーマッタに渡して
有効な日付を戻します

504
00:35:25,359 --> 00:35:27,394
JSONデコーダがあるので

505
00:35:27,494 --> 00:35:32,299
型の変更を気にせず
日付を復号できます

506
00:35:32,666 --> 00:35:38,305
JSONデコーダの指針で
変更の種類も分かります

507
00:35:38,672 --> 00:35:42,109
この変更は１行なので便利です

508
00:35:42,709 --> 00:35:45,512
別の復号コールも１行です

509
00:35:45,612 --> 00:35:49,483
そのため検証に
着目しやすくなります

510
00:35:51,585 --> 00:35:57,558
それからタグの下部構造を
文字列の配列として取り出します

511
00:35:57,658 --> 00:36:02,562
文字列をマッピングし
あとで さらに検証します

512
00:35:57,658 --> 00:36:02,562
文字列をマッピングし
あとで さらに検証します

513
00:36:03,931 --> 00:36:07,935
タグがCodableに適合するおかげで

514
00:36:08,035 --> 00:36:11,338
直接 タグの配列を復号化できます

515
00:36:11,605 --> 00:36:13,073
これは自動です

516
00:36:13,173 --> 00:36:17,811
型の変更ではなく
データの検証に集中できるので

517
00:36:18,145 --> 00:36:21,148
信頼性に確信を持てます

518
00:36:24,385 --> 00:36:26,453
多くを説明しました

519
00:36:27,087 --> 00:36:32,860
RAWデータからモデル型に至る
抽象化の過程を説明し

520
00:36:33,327 --> 00:36:36,497
信頼できるデータを構築しました

521
00:36:38,599 --> 00:36:44,471
チェックサムやデータの長さから
有効に働くかを検証し

522
00:36:44,571 --> 00:36:47,174
形式に合うか確認しました

523
00:36:47,274 --> 00:36:50,210
既知の形式に適合すれば

524
00:36:50,544 --> 00:36:55,883
フォーマット済みデータから
プリミティブ値が生じます

525
00:36:57,117 --> 00:37:00,921
プリミティブ値の
コンテンツや構造で

526
00:36:57,117 --> 00:37:00,921
プリミティブ値の
コンテンツや構造で

527
00:37:01,021 --> 00:37:05,426
独自のモデル型ができるか
分かりました

528
00:37:06,393 --> 00:37:09,930
セマンティックとモデル型の関係で

529
00:37:10,030 --> 00:37:13,734
信頼できるデータか検証しました

530
00:37:15,802 --> 00:37:17,137
次はどうします？

531
00:37:18,105 --> 00:37:22,676
自分のコードを見て
検証を始めてください

532
00:37:23,310 --> 00:37:27,848
データが変化する各段階で
検証を行います

533
00:37:27,948 --> 00:37:33,320
型やnull化可能性より
値域や長さなどが重要です

534
00:37:34,755 --> 00:37:36,023
NSCoding型があれば

535
00:37:36,123 --> 00:37:38,792
NSSecureCodingバッジを
得られます

536
00:37:38,892 --> 00:37:42,629
セキュアコーディングを
利用しましょう

537
00:37:43,564 --> 00:37:45,499
新しいデータ型では

538
00:37:45,599 --> 00:37:49,803
Codableを導入して
検証してください

539
00:37:50,170 --> 00:37:53,574
信頼できるデータだけ使うのです

540
00:37:55,175 --> 00:37:59,947
Codableの詳細は
“What's New in Foundation”で

541
00:38:00,047 --> 00:38:05,152
質問がある方や
適用方法で助言が欲しい方は

542
00:38:05,252 --> 00:38:09,156
Foundationラボまで
お越しください

543
00:38:10,324 --> 00:38:12,626
ご清聴に感謝します

544
00:38:13,160 --> 00:38:14,161
よい１日を

545
00:38:14,261 --> 00:38:17,431
(拍手)