
1
00:00:07,107 --> 00:00:15,516
(音楽)

2
00:00:20,721 --> 00:00:26,159
(拍手)

3
00:00:26,894 --> 00:00:27,928
どうも

4
00:00:28,529 --> 00:00:31,164
昨年 Metal 2を紹介して

5
00:00:31,265 --> 00:00:35,235
レンダリングパイプラインの
新しい手法を提案しました

6
00:00:35,936 --> 00:00:39,673
今年は ゲーム開発の
課題を解決する―

7
00:00:39,773 --> 00:00:42,442
より画期的な機能を
紹介します

8
00:00:43,010 --> 00:00:47,281
私 ブライアン･ロスと
同僚のマイケルが

9
00:00:47,381 --> 00:00:53,520
アプリケーションを改善する
新しい方法を探ります

10
00:00:54,988 --> 00:00:59,960
まず 私が解決したい
課題についてお話しします

11
00:01:00,761 --> 00:01:06,166
ゲーム開発は 膨大な数の
オブジェクトを使用します

12
00:01:06,967 --> 00:01:11,505
「INSIDE」では
多くの特殊効果を用いて

13
00:01:11,605 --> 00:01:14,608
独特の雰囲気を
演出しています

14
00:01:16,210 --> 00:01:19,446
こうしたゲームを作るには

15
00:01:19,546 --> 00:01:23,550
GPUをフル活用する
必要があります

16
00:01:25,085 --> 00:01:30,724
臨場感あるゲームには
高い処理速度が求められます

17
00:01:30,924 --> 00:01:37,831
「トゥームレイダー」の
美しく精細な背景の裏では

18
00:01:38,432 --> 00:01:43,403
複雑なシミュレーションを
AIが行っています

19
00:01:44,004 --> 00:01:48,108
高速なレンダリングが
求められます

20
00:01:49,977 --> 00:01:56,583
「フォートナイト」のような
AAAタイトルの開発者たちは

21
00:01:56,683 --> 00:02:02,723
家庭用ゲームをiOSに移植し
手元で遊べるようにしました

22
00:01:56,683 --> 00:02:02,723
家庭用ゲームをiOSに移植し
手元で遊べるようにしました

23
00:02:02,890 --> 00:02:05,225
すばらしい功績です

24
00:02:05,392 --> 00:02:08,428
しかし
課題は多く残っています

25
00:02:08,662 --> 00:02:12,666
例えば バッテリー消費との
兼ね合いです

26
00:02:13,200 --> 00:02:17,304
Metalが
この問題を解決します

27
00:02:19,373 --> 00:02:22,509
CPUとGPUの並列処理による

28
00:02:22,609 --> 00:02:27,181
複雑な描画を行う仕組みを
お見せします

29
00:02:29,416 --> 00:02:32,819
また パフォーマンスを
改善するための

30
00:02:32,920 --> 00:02:37,324
明示的な制御についても
お話しします

31
00:02:39,993 --> 00:02:45,098
さらに 新機能である
２種類のバッファを用いた

32
00:02:45,199 --> 00:02:48,135
GPUパイプラインの構築も
紹介します

33
00:02:48,268 --> 00:02:50,938
こうしたAPIの改善に加え

34
00:02:51,305 --> 00:02:55,375
ハードウェアの動作を
理解することも重要です

35
00:02:55,742 --> 00:02:58,812
そこで 次のセクションでは

36
00:02:58,912 --> 00:03:04,651
アプリケーションをA11に
最適化する方法を示します

37
00:02:58,912 --> 00:03:04,651
アプリケーションをA11に
最適化する方法を示します

38
00:03:05,552 --> 00:03:12,793
最後は エピック･ゲームズの
ニック･ペンワーデン氏に

39
00:03:12,893 --> 00:03:18,699
Metalで家庭用ゲームを
移植した方法を伺います

40
00:03:19,333 --> 00:03:20,734
では 始めます

41
00:03:23,170 --> 00:03:26,240
CPUとGPUの並列処理は

42
00:03:26,340 --> 00:03:30,644
最も重要かつ
簡単にできる最適化でしょう

43
00:03:32,045 --> 00:03:35,816
シングルスレッドでの
コマンド処理は時代遅れです

44
00:03:36,183 --> 00:03:38,385
最新のiPhoneは６コア

45
00:03:38,485 --> 00:03:40,721
iMac Proは最大18コアです

46
00:03:41,088 --> 00:03:44,558
高いパフォーマンスを
得るためには

47
00:03:45,325 --> 00:03:48,095
マルチスレッド構造が
カギです

48
00:03:50,030 --> 00:03:52,165
Metalは
マルチスレッド対応です

49
00:03:52,266 --> 00:03:55,569
CPUを並列化する
２つの方法と

50
00:03:55,802 --> 00:04:01,708
MetalによるGPUの
自動並列化を紹介します

51
00:03:55,802 --> 00:04:01,708
MetalによるGPUの
自動並列化を紹介します

52
00:04:02,976 --> 00:04:06,113
ゲームの描画の流れを
見てみましょう

53
00:04:06,713 --> 00:04:09,283
シングルスレッドによる
レンダリングでは

54
00:04:09,750 --> 00:04:15,789
１つのコマンドバッファに
GPUへの実行命令を入れます

55
00:04:16,356 --> 00:04:20,560
通常は それをフレームの
一部に収めます

56
00:04:21,128 --> 00:04:26,800
GPUがバッファを使うには
符号化する必要があるため

57
00:04:26,900 --> 00:04:29,169
遅延時間が長くなります

58
00:04:29,369 --> 00:04:31,572
改善の余地があります

59
00:04:31,672 --> 00:04:36,877
そこで提案するのが
CPUを用いた並列処理です

60
00:04:39,980 --> 00:04:44,484
Metalの基本要素は
描画とパス計算です

61
00:04:44,952 --> 00:04:48,188
複数のコマンドバッファを
用意して

62
00:04:48,388 --> 00:04:52,159
別々のスレッドで
符号化するだけです

63
00:04:53,961 --> 00:04:56,063
処理の順序は自由です

64
00:04:56,163 --> 00:05:00,501
最後に追加した命令は
最後に実行されます

65
00:04:56,163 --> 00:05:00,501
最後に追加した命令は
最後に実行されます

66
00:05:01,468 --> 00:05:04,605
コードも極めてシンプルです

67
00:05:07,541 --> 00:05:09,910
ご覧の通り 短いコードです

68
00:05:10,010 --> 00:05:15,449
最初に コマンドバッファを
キューから取り出します

69
00:05:16,250 --> 00:05:23,156
次に GPUの実行命令を
キューに入れて定義します

70
00:05:23,257 --> 00:05:29,163
コマンドバッファの符号化を
待つ必要はありません

71
00:05:30,330 --> 00:05:35,802
最後に 各スレッドと
呼び出し元関数を作成します

72
00:05:35,903 --> 00:05:38,372
これだけで完了です

73
00:05:38,472 --> 00:05:41,642
非常に高速かつシンプルです

74
00:05:42,209 --> 00:05:46,180
先ほどの図で
別の例を見てみます

75
00:05:48,148 --> 00:05:52,719
CPUを用いた並列処理は
効果的でしたが

76
00:05:53,387 --> 00:05:57,124
長いレンダリングパスが
ある場合はどうでしょうか

77
00:05:58,692 --> 00:06:03,897
Metalは この場合に特化した
並列符号化により

78
00:05:58,692 --> 00:06:03,897
Metalは この場合に特化した
並列符号化により

79
00:06:04,331 --> 00:06:10,337
コマンドバッファも使用して
複数のスレッドで処理します

80
00:06:11,004 --> 00:06:13,473
こちらもコードは簡単です

81
00:06:15,309 --> 00:06:17,411
大きな変化はありません

82
00:06:17,678 --> 00:06:21,381
まず 複数のエンコーダを
準備します

83
00:06:21,782 --> 00:06:25,519
ここで下位のエンコーダを
多数 作成します

84
00:06:25,619 --> 00:06:30,324
GPUの実行命令を定義する
場所になります

85
00:06:32,292 --> 00:06:36,663
次に 別々のスレッドを
作成してから

86
00:06:36,763 --> 00:06:40,767
Ｇバッファを
それぞれ符号化します

87
00:06:41,902 --> 00:06:47,674
スレッドが終了したら
通知が出るように設定して

88
00:06:48,141 --> 00:06:51,011
エンコーダの
符号化を終わらせます

89
00:06:51,111 --> 00:06:54,281
これで レンダリングパスの
並列化が実現します

90
00:06:54,381 --> 00:06:56,550
高速かつシンプルです

91
00:06:57,084 --> 00:07:00,220
CPUの並列化は以上です

92
00:06:57,084 --> 00:07:00,220
CPUの並列化は以上です

93
00:07:00,721 --> 00:07:04,691
次に紹介するのは
GPUの自動並列化です

94
00:07:06,293 --> 00:07:08,762
最初の図に戻りましょう

95
00:07:09,897 --> 00:07:12,633
GPUはどう処理を
実行するのか

96
00:07:13,200 --> 00:07:18,071
Metalは 開発環境に応じて
データの従属性を分析し

97
00:07:18,172 --> 00:07:21,375
自動的に並列化を行います

98
00:07:21,475 --> 00:07:23,944
例を２つ見てみましょう

99
00:07:24,578 --> 00:07:27,915
粒子シミュレーションで
データを描画する例です

100
00:07:28,015 --> 00:07:31,752
このデータを使って
粒子を描きます

101
00:07:33,020 --> 00:07:37,291
同様に Ｇバッファパスで
ジオメトリを生成し

102
00:07:37,391 --> 00:07:41,428
物質の陰影を描くために
使用します

103
00:07:43,430 --> 00:07:49,636
Metalは この情報をもとに
自動的に全体のパスを特定し

104
00:07:49,736 --> 00:07:52,773
非同期演算などを用いて
描画します

105
00:07:56,276 --> 00:08:01,081
GPUの並列化と非同期演算が
手軽に実現できます

106
00:07:56,276 --> 00:08:01,081
GPUの並列化と非同期演算が
手軽に実現できます

107
00:08:01,181 --> 00:08:04,818
開発者側の
特別な操作は不要です

108
00:08:05,586 --> 00:08:09,423
手軽なGPU最適化は
誰もが望みますが

109
00:08:09,623 --> 00:08:14,394
開発者の皆さんは
深い部分も気になるでしょう

110
00:08:15,229 --> 00:08:20,934
コードの重要な部分でも
Metalは貢献します

111
00:08:21,435 --> 00:08:27,674
参照カウントを手動化して
CPUの負担を減らせます

112
00:08:28,809 --> 00:08:33,746
アロケーションの制御には
Metalのヒープが有用です

113
00:08:35,148 --> 00:08:38,684
フェンスとイベントで
補完されています

114
00:08:38,784 --> 00:08:42,756
GPUの並列処理の
明示的制御が可能です

115
00:08:45,125 --> 00:08:49,229
昨今のゲームは
大量のリソースを使います

116
00:08:49,763 --> 00:08:52,533
アロケーションの際は
OSを往復して

117
00:08:52,633 --> 00:08:56,603
毎回 メモリを初期化する
必要があります

118
00:08:56,803 --> 00:08:59,206
レンダーターゲットが
一時的なものだと

119
00:08:59,306 --> 00:09:03,110
この動作による
処理落ちの恐れもあります

120
00:08:59,306 --> 00:09:03,110
この動作による
処理落ちの恐れもあります

121
00:09:03,577 --> 00:09:06,680
これを解消するのが
ヒープです

122
00:09:07,414 --> 00:09:12,286
あらかじめ 一部のメモリを
割り当てておき

123
00:09:12,386 --> 00:09:18,025
テクスチャやバッファを
あとで追加する際に使います

124
00:09:19,359 --> 00:09:23,297
３つのテクスチャを
処理する場合

125
00:09:23,764 --> 00:09:27,201
Metalでは
３つに割り振ります

126
00:09:27,668 --> 00:09:30,771
これらを
１つのヒープで処理して

127
00:09:30,871 --> 00:09:35,475
ヒープ作成時に
メモリ割り当てを実行します

128
00:09:35,576 --> 00:09:39,646
結果 テクスチャ作成の
コストが激減します

129
00:09:40,514 --> 00:09:43,851
さらに
隣接する領域を使えば

130
00:09:43,951 --> 00:09:47,688
メモリの有効利用にも
効果的です

131
00:09:48,856 --> 00:09:54,761
従来は割り当てを解除すると
メモリが一度OSに返され

132
00:09:54,862 --> 00:09:59,299
再度 テクスチャを使うと
一から割り当てます

133
00:09:59,399 --> 00:10:05,973
ヒープなら OSを往復せずに
再割り当てが可能になります

134
00:09:59,399 --> 00:10:05,973
ヒープなら OSを往復せずに
再割り当てが可能になります

135
00:10:08,408 --> 00:10:12,713
また 各メモリ領域に
別名を割り当てられます

136
00:10:14,047 --> 00:10:18,519
レンダーターゲットが
多いときに有用です

137
00:10:18,619 --> 00:10:22,055
メモリの無用な占有を
防ぐことで

138
00:10:22,156 --> 00:10:25,826
数百メガバイトを
節約できます

139
00:10:26,994 --> 00:10:29,730
高速なアロケーションは
利点ですが

140
00:10:29,830 --> 00:10:33,300
従属性の把握には
計算が必要です

141
00:10:33,400 --> 00:10:36,670
フレームを見ながら
説明します

142
00:10:38,672 --> 00:10:43,410
Metalは 個々のリソースを
把握しません

143
00:10:43,510 --> 00:10:47,014
よって Ｇバッファなどの
パス間の従属性を

144
00:10:47,114 --> 00:10:50,317
自動で読み書きできません

145
00:10:51,552 --> 00:10:56,356
そこで フェンスを用いて
データを生成するパスと

146
00:10:56,456 --> 00:10:58,692
消費するパスを明示します

147
00:10:58,792 --> 00:11:03,997
この例では Ｇバッファと
遅延シェーディングです

148
00:10:58,792 --> 00:11:03,997
この例では Ｇバッファと
遅延シェーディングです

149
00:11:04,565 --> 00:11:06,200
では ここで―

150
00:11:07,868 --> 00:11:10,737
実際のコードを
見てみましょう

151
00:11:14,241 --> 00:11:18,979
まず フェンスの概念を
このコードに導入します

152
00:11:19,880 --> 00:11:23,617
まず レンダーターゲットを
ヒープから割り当てます

153
00:11:23,717 --> 00:11:27,521
テクスチャの割り当てでは
一般的な作法です

154
00:11:28,755 --> 00:11:32,593
次に レンダーターゲットを
描画します

155
00:11:33,227 --> 00:11:38,198
フラグメント処理の完了後
フェンスを更新します

156
00:11:38,298 --> 00:11:43,337
次のパスに使われる前に
全データを出力できます

157
00:11:44,171 --> 00:11:47,708
今度は遅延シェーディングに
注目します

158
00:11:48,041 --> 00:11:52,946
レンダーターゲットを使って
物質の陰影を描きます

159
00:11:55,048 --> 00:11:59,853
フェンスが生成されるまで
待機します

160
00:12:00,487 --> 00:12:05,959
このフェンスは 他の処理に
再利用が可能なので

161
00:12:06,059 --> 00:12:08,095
メモリを節約できます

162
00:12:08,829 --> 00:12:14,034
並列処理による最適化の
方法をお話ししました

163
00:12:15,102 --> 00:12:19,873
しかし GPUをもっと
活用する方法があります

164
00:12:21,008 --> 00:12:23,844
GPUパイプラインです

165
00:12:25,546 --> 00:12:30,117
昨今のゲームは
複雑なロジックで動作します

166
00:12:31,652 --> 00:12:37,958
大量のオブジェクトを扱う
場合はなおさらです

167
00:12:38,926 --> 00:12:42,963
Metal 2では
新しい重要な一歩として

168
00:12:43,063 --> 00:12:45,732
GPUパイプラインに
着目しました

169
00:12:46,099 --> 00:12:49,369
昨年 紹介した
間接アーギュメントバッファは

170
00:12:49,469 --> 00:12:55,509
CPUの使用率を下げ
GPUの負担も軽減します

171
00:12:55,943 --> 00:13:00,180
今年 紹介するのは
間接コマンドバッファです

172
00:12:55,943 --> 00:13:00,180
今年 紹介するのは
間接コマンドバッファです

173
00:13:01,582 --> 00:13:05,853
レンダリング全体を
GPU上で処理できます

174
00:13:07,221 --> 00:13:10,591
アーギュメントバッファの
要点をまとめます

175
00:13:11,358 --> 00:13:14,862
構造は極めてシンプルです

176
00:13:15,729 --> 00:13:16,730
この通り

177
00:13:17,664 --> 00:13:23,337
定数に加え テクスチャと
サンプラーを使用します

178
00:13:23,537 --> 00:13:27,007
従来はシェーダが必要でした

179
00:13:28,642 --> 00:13:33,247
この構造なら Metalの
シェーディング言語を

180
00:13:33,347 --> 00:13:36,016
柔軟かつ簡単に
利用できます

181
00:13:36,116 --> 00:13:39,186
下部構造や配列だけでなく

182
00:13:39,286 --> 00:13:42,122
アーギュメントバッファの
ポインタも追加できます

183
00:13:43,023 --> 00:13:45,492
テクスチャと
サンプラーを編集すれば

184
00:13:45,592 --> 00:13:49,863
CPUを介さず GPU上に
マテリアルを生成できます

185
00:13:50,697 --> 00:13:56,270
配列と単一インスタンスの
ドローコールを利用した

186
00:13:56,670 --> 00:13:59,273
複数オブジェクトの
描画も可能です

187
00:14:00,340 --> 00:14:04,878
マテリアル管理を
GPUに委ねることで

188
00:14:05,078 --> 00:14:08,715
貴重なCPUリソースを
節約できます

189
00:14:08,815 --> 00:14:12,619
今年は もう少し
機能を拡張しました

190
00:14:13,820 --> 00:14:16,823
まず ２種類の
アーギュメントを加えました

191
00:14:17,491 --> 00:14:20,494
パイプライン状態と
コマンドバッファです

192
00:14:20,928 --> 00:14:25,165
間接コマンドバッファを
支えるものです

193
00:14:26,667 --> 00:14:31,338
これにより シーン全体を
GPU上で符号化できます

194
00:14:31,438 --> 00:14:34,675
スレッドの少ない
CPUとは違って

195
00:14:34,775 --> 00:14:40,647
GPUには 同時に利用できる
大量のスレッドがあります

196
00:14:41,615 --> 00:14:46,286
新機能はこの超並列の性質を
フル活用できます

197
00:14:47,487 --> 00:14:50,991
間接コマンドバッファは
再利用も可能です

198
00:14:51,091 --> 00:14:55,562
一度符号化を行えば
繰り返し使用できます

199
00:14:55,829 --> 00:15:01,902
直接アクセスできるので
いつでも内容を編集できます

200
00:14:55,829 --> 00:15:01,902
直接アクセスできるので
いつでも内容を編集できます

201
00:15:02,002 --> 00:15:07,007
例えば シェーダの種類や
カメラ行列です

202
00:15:07,274 --> 00:15:10,811
もちろん
GPUでレンダリングを行えば

203
00:15:10,911 --> 00:15:17,518
CPUとGPUの同期が不要になり
コストを大幅に減らせます

204
00:15:18,252 --> 00:15:20,087
例を紹介します

205
00:15:21,488 --> 00:15:23,457
典型的なゲームでは

206
00:15:23,557 --> 00:15:26,760
レンダリングに
共通する部分があります

207
00:15:26,960 --> 00:15:31,832
まずシーングラフを調査して
描画するオブジェクトを決定

208
00:15:33,066 --> 00:15:37,638
視すい台カリングで
視界に入る物体を判定します

209
00:15:37,805 --> 00:15:42,543
もっと複雑な手法を使う
開発者もいるでしょう

210
00:15:42,843 --> 00:15:47,281
詳細度の設定も
この時点で行われます

211
00:15:47,514 --> 00:15:52,452
コマンドバッファを送ると
GPUがそれを消費します

212
00:15:55,722 --> 00:16:00,861
可視オブジェクトの判定を
GPUで行うゲームは多いです

213
00:15:55,722 --> 00:16:00,861
可視オブジェクトの判定を
GPUで行うゲームは多いです

214
00:16:01,428 --> 00:16:06,099
GPUは複雑なシーンの処理に
向いているのです

215
00:16:06,900 --> 00:16:11,205
ただし この処理では
同期点が生じます

216
00:16:12,873 --> 00:16:18,245
GPUがデータを生成するまで
CPUは描画できません

217
00:16:18,345 --> 00:16:20,581
これを調整するには

218
00:16:20,681 --> 00:16:24,985
同期に使用時間を
浪費するしかありません

219
00:16:25,619 --> 00:16:28,522
その点
新機能の効果は絶大です

220
00:16:28,622 --> 00:16:32,459
最終ビットを
GPUに委ねることで

221
00:16:32,559 --> 00:16:36,029
データ移動に使う
同期点をなくします

222
00:16:36,129 --> 00:16:39,399
結果 CPUとGPUの
使用率が改善します

223
00:16:39,766 --> 00:16:44,304
また CPUのオーバーヘッドを
一定量減らせます

224
00:16:45,739 --> 00:16:48,475
符号化の詳細を見てみます

225
00:16:50,277 --> 00:16:53,080
まずは 前の例を応用して

226
00:16:53,180 --> 00:16:57,584
GPUが持つ超並列の性質に
注目しましょう

227
00:16:58,185 --> 00:17:03,423
最初に 可視オブジェクトと
詳細度をリスト化します

228
00:16:58,185 --> 00:17:03,423
最初に 可視オブジェクトと
詳細度をリスト化します

229
00:17:03,857 --> 00:17:07,426
アーギュメントバッファの
機能をここで活用します

230
00:17:07,761 --> 00:17:13,200
各エレメントはプロパティを
参照しているので

231
00:17:13,300 --> 00:17:16,236
複数のバッファを
兼用できます

232
00:17:18,505 --> 00:17:21,942
メモリを節約し
パフォーマンスを改善します

233
00:17:22,041 --> 00:17:25,479
構築する情報リストが
小さいためです

234
00:17:25,779 --> 00:17:30,250
数段階の詳細度で
ジオメトリを保管します

235
00:17:30,851 --> 00:17:36,957
ジオメトリは 配置情報や
頂点バッファなどを含みます

236
00:17:37,424 --> 00:17:41,595
オブジェクトごとに詳細度を
１つ選んで描画します

237
00:17:43,130 --> 00:17:46,233
カーネルで符号化を実行し

238
00:17:46,333 --> 00:17:49,069
間接コマンドバッファに
格納します

239
00:17:49,736 --> 00:17:54,107
１つのドローコールを
各スレッドで符号化します

240
00:17:54,474 --> 00:17:57,311
プロパティと一緒に
オブジェクトを読み込み

241
00:17:58,011 --> 00:18:00,247
符号化を実行します

242
00:17:58,011 --> 00:18:00,247
符号化を実行します

243
00:18:01,915 --> 00:18:04,117
間接コマンドバッファは

244
00:18:04,251 --> 00:18:07,588
描画コマンドの配列だと
考えられます

245
00:18:07,688 --> 00:18:13,760
シェーダやドローコールで
構成されたパイプラインです

246
00:18:14,628 --> 00:18:17,464
また 並列処理が可能なため

247
00:18:17,564 --> 00:18:20,567
符号化は
同時進行で行われます

248
00:18:21,001 --> 00:18:23,971
Metalはシンプルなので

249
00:18:24,071 --> 00:18:27,174
CPUで処理するような
軽快さです

250
00:18:28,342 --> 00:18:32,646
加えて 各コマンドは
個別のプロパティを持てます

251
00:18:32,880 --> 00:18:36,316
これは大きな前進です

252
00:18:36,416 --> 00:18:40,154
間接レンダリングが
再現できるのです

253
00:18:40,888 --> 00:18:43,357
コードを見てみましょう

254
00:18:44,825 --> 00:18:47,828
ドローコールの符号化は
簡単です

255
00:18:48,362 --> 00:18:53,433
まず スレッドIDを取得して
描画コマンドを選びます

256
00:18:55,402 --> 00:18:57,404
次にプロパティを設定します

257
00:18:57,504 --> 00:19:00,908
この例では
シェーダを設けます

258
00:18:57,504 --> 00:19:00,908
この例では
シェーダを設けます

259
00:19:02,142 --> 00:19:05,345
ジオメトリ用のバッファも
用意しました

260
00:19:06,113 --> 00:19:08,849
最後がドローコールの
符号化です

261
00:19:08,949 --> 00:19:13,520
シェーディング言語により
符号化は簡単になります

262
00:19:13,821 --> 00:19:19,293
GPUでの符号化ですが
CPUのようにシンプルです

263
00:19:20,094 --> 00:19:21,962
もう１つの例です

264
00:19:22,996 --> 00:19:29,203
間接コマンドバッファを
生成し 実行するコードです

265
00:19:29,837 --> 00:19:32,839
まず 記述子に値を入れます

266
00:19:33,140 --> 00:19:35,309
記述子に含まれるのは

267
00:19:35,676 --> 00:19:40,447
継承されたプロパティや
ドロータイプなどです

268
00:19:40,547 --> 00:19:43,884
バッファの挙動を記述します

269
00:19:46,353 --> 00:19:48,088
符号化の際は

270
00:19:48,188 --> 00:19:52,626
エンコーダを作成して
リソースを割り当てます

271
00:19:53,927 --> 00:19:58,298
符号化が終わると
最適化が実行できます

272
00:19:58,398 --> 00:20:01,235
すると冗長コードが削除され

273
00:19:58,398 --> 00:20:01,235
すると冗長コードが削除され

274
00:20:01,335 --> 00:20:05,472
無駄のない
GPUコマンドが残ります

275
00:20:06,373 --> 00:20:11,645
符号化と最適化が済んだら
バッファの実行を予約します

276
00:20:11,879 --> 00:20:16,717
実行するコマンドの範囲を
指定することも可能です

277
00:20:17,251 --> 00:20:22,856
この例では 間接バッファを
GPUで符号化しています

278
00:20:25,459 --> 00:20:29,596
一度 符号化すれば
再利用できるので

279
00:20:29,696 --> 00:20:32,499
オーバーヘッドは
無視できます

280
00:20:32,766 --> 00:20:37,638
実際の挙動が分かる
サンプルをご用意しました

281
00:20:39,439 --> 00:20:43,110
複数台のバスが
街に停車しています

282
00:20:43,944 --> 00:20:50,617
それぞれ50万枚のポリゴンと
2000個のパーツから成ります

283
00:20:51,785 --> 00:20:54,121
各パーツに対して

284
00:20:54,221 --> 00:20:58,025
ドローコールや
各種バッファが必要です

285
00:20:58,792 --> 00:21:02,629
大量のAPIコールが
生じますが

286
00:20:58,792 --> 00:21:02,629
大量のAPIコールが
生じますが

287
00:21:02,729 --> 00:21:07,701
間接コマンドバッファなら
すべてGPUで処理できます

288
00:21:09,736 --> 00:21:15,008
最適な詳細度を選べば
負担を増やさずに

289
00:21:15,109 --> 00:21:19,479
複数のオブジェクトを
描画できます

290
00:21:19,613 --> 00:21:22,749
左は通常のカメラの映像

291
00:21:22,849 --> 00:21:25,252
右はバスの拡大表示です

292
00:21:25,352 --> 00:21:28,288
詳細度が変化していきます

293
00:21:29,690 --> 00:21:34,127
この他にも
驚くべき最適化を行います

294
00:21:35,796 --> 00:21:39,500
ポリゴンを数百枚ごとに
チャンクに分割し

295
00:21:39,600 --> 00:21:42,503
個別のカーネルで分析します

296
00:21:43,270 --> 00:21:46,006
各チャンクを
色分けしています

297
00:21:47,007 --> 00:21:51,111
各スレッドが
カメラに映らない部分や

298
00:21:51,211 --> 00:21:55,249
オブジェクトで隠れる部分を
判断します

299
00:21:55,682 --> 00:22:00,254
ポリゴンではなく
チャンクごとに計算するので

300
00:21:55,682 --> 00:22:00,254
ポリゴンではなく
チャンクごとに計算するので

301
00:22:00,354 --> 00:22:02,723
処理は非常に高速です

302
00:22:03,490 --> 00:22:07,761
見えるチャンクだけを
GPUに描画させます

303
00:22:10,631 --> 00:22:13,233
次はこちらの比較映像です

304
00:22:13,333 --> 00:22:17,905
左はカメラの視点
右は別角度から見たバスです

305
00:22:18,438 --> 00:22:21,175
赤色やピンク色の部分は

306
00:22:21,275 --> 00:22:24,645
見えないと
判断された部分です

307
00:22:26,046 --> 00:22:28,448
GPUの処理が生じないため

308
00:22:28,549 --> 00:22:32,953
ジオメトリの描画コストは
半分以下になります

309
00:22:36,590 --> 00:22:41,028
この映像を見れば
効果の大きさが分かります

310
00:22:41,728 --> 00:22:46,333
多くのバスや救急車は
視界の外にあります

311
00:22:50,771 --> 00:22:53,240
画期的な技術です

312
00:22:53,507 --> 00:22:56,276
ぜひ一度
コードをご覧ください

313
00:22:56,376 --> 00:23:00,147
近い将来 皆さんが
この技術を導入して

314
00:22:56,376 --> 00:23:00,147
近い将来 皆さんが
この技術を導入して

315
00:23:00,280 --> 00:23:04,785
新時代のゲームを
開発することを願っています

316
00:23:05,252 --> 00:23:08,422
続いては 同僚のマイケルが

317
00:23:08,522 --> 00:23:13,260
A11に最適化する方法を
お伝えします

318
00:23:13,360 --> 00:23:14,695
ありがとう

319
00:23:14,795 --> 00:23:20,267
(拍手)

320
00:23:20,601 --> 00:23:21,568
どうも

321
00:23:22,269 --> 00:23:27,608
彼が紹介した技術は
iOS tvOS macOSで使えます

322
00:23:28,242 --> 00:23:33,514
次はAppleの最新GPU
A11 Bionicを紹介します

323
00:23:33,614 --> 00:23:37,351
メモリのバンド幅を減らして
消費電力を抑え

324
00:23:37,451 --> 00:23:41,054
ゲームのパフォーマンスを
向上させます

325
00:23:45,192 --> 00:23:48,695
Apple製GPUはタイルベースの
遅延レンダリングで

326
00:23:48,796 --> 00:23:51,865
高性能と低消費電力を
実現します

327
00:23:52,266 --> 00:23:56,837
高帯域かつ低遅延の
タイルメモリを活用して

328
00:23:56,937 --> 00:24:00,240
オーバードローを
排除しているのです

329
00:23:56,937 --> 00:24:00,240
オーバードローを
排除しているのです

330
00:24:02,509 --> 00:24:08,115
Metalはこの機能を
各レンダリングパスに適用し

331
00:24:08,315 --> 00:24:13,620
アクションやアタッチの
読み書きを行います

332
00:24:16,290 --> 00:24:20,060
A11はこの構造が
さらに強化されました

333
00:24:20,327 --> 00:24:25,232
新機能が追加され
プログラム制御も可能です

334
00:24:25,732 --> 00:24:30,270
高度なレンダリング技術への
最適化が可能です

335
00:24:30,370 --> 00:24:33,907
遅延シェーディングや
順番に依存しない透明処理

336
00:24:34,007 --> 00:24:36,777
粒子レンダリングなどです

337
00:24:37,611 --> 00:24:41,181
では 最初に
この構造を見てみましょう

338
00:24:44,051 --> 00:24:47,988
このブロック図の左側が
A11 Bionicで

339
00:24:48,088 --> 00:24:49,990
右がシステムメモリです

340
00:24:51,725 --> 00:24:56,997
頂点のレンダリング時に
A11が全ジオメトリを処理し

341
00:24:57,097 --> 00:25:02,169
タイル化された
頂点バッファに変換します

342
00:24:57,097 --> 00:25:02,169
タイル化された
頂点バッファに変換します

343
00:25:02,536 --> 00:25:05,305
これらはシステムメモリに
保存されます

344
00:25:07,508 --> 00:25:12,846
次に A11でフラグメントの
一部として処理されます

345
00:25:13,547 --> 00:25:18,218
この構造は ２つの面で
ゲームを最適化できます

346
00:25:19,987 --> 00:25:22,856
まず タイル化された
プリミティブが

347
00:25:22,956 --> 00:25:26,593
陰影処理の前に
ラスタライズされること

348
00:25:26,760 --> 00:25:31,098
これにより
オーバードローをなくせます

349
00:25:32,933 --> 00:25:38,071
次に 柔軟なタイルメモリに
フラグメントを保存すること

350
00:25:38,272 --> 00:25:43,177
シェーダが近いので
データのやりとりが高速です

351
00:25:44,978 --> 00:25:50,784
タイルメモリは陰影処理後に
一度書き込まれるだけなので

352
00:25:51,151 --> 00:25:55,556
バンド幅が小さくなり
消費電力も減ります

353
00:25:56,723 --> 00:26:00,227
Metalを導入した
iOSさえあれば

354
00:25:56,723 --> 00:26:00,227
Metalを導入した
iOSさえあれば

355
00:26:00,360 --> 00:26:02,663
これらが実現します

356
00:26:03,197 --> 00:26:08,969
メモリの明示的制御により
レンダリングも最適化します

357
00:26:11,071 --> 00:26:13,240
A11の開発にあたって

358
00:26:13,340 --> 00:26:18,178
我々は レンダリング技術の
分析を重ねました

359
00:26:18,645 --> 00:26:21,448
その結果 多くの共通点と

360
00:26:21,548 --> 00:26:25,119
タイルメモリの明示的制御の
有効性に気付きます

361
00:26:26,987 --> 00:26:31,792
そこで明示的制御に着目した
新機能を開発しました

362
00:26:32,559 --> 00:26:34,261
ご紹介します

363
00:26:41,535 --> 00:26:45,372
プログラマブルブレンディングは
シェーダのカスタム調整や

364
00:26:45,505 --> 00:26:51,111
レンダリングパスの統合を
iOSのGPUで実現します

365
00:26:52,346 --> 00:26:56,049
イメージブロックは
ピクセル配置を直接制御して

366
00:26:56,150 --> 00:26:59,353
タイルメモリを
無駄なく使います

367
00:27:01,188 --> 00:27:06,860
タイルシェーディングは
合成と演算処理の新技術です

368
00:27:08,428 --> 00:27:11,932
パーシステント･
スレッドグループメモリは

369
00:27:12,032 --> 00:27:14,868
ドローとディスパッチの
通信を可能にします

370
00:27:16,770 --> 00:27:18,872
マルチサンプル･カラー
カバレッジコントロールは

371
00:27:18,972 --> 00:27:23,811
予備の操作をタイルメモリで
直接 実行します

372
00:27:24,912 --> 00:27:28,682
プログラマブルブレンディングを
最初に紹介します

373
00:27:31,752 --> 00:27:36,190
これを使うと シェーダが
ピクセルに読み書きして

374
00:27:36,390 --> 00:27:39,026
ブレンディングの
カスタム操作が可能です

375
00:27:40,861 --> 00:27:44,164
また 複数の
レンダリングパスをまとめて

376
00:27:44,264 --> 00:27:48,168
システムメモリの
バンド幅を小さくします

377
00:27:49,837 --> 00:27:54,741
遅延シェーディングは
この機能と相性がいいのです

378
00:27:58,412 --> 00:28:02,816
従来の遅延シェーディングは
２パスを使います

379
00:27:58,412 --> 00:28:02,816
従来の遅延シェーディングは
２パスを使います

380
00:28:02,983 --> 00:28:08,455
１パス目は アタッチに
ジオメトリ属性を入力します

381
00:28:08,555 --> 00:28:11,658
例えば
法線やアルベドなどです

382
00:28:12,292 --> 00:28:16,230
２パス目は フラグメントの
陰影処理をします

383
00:28:18,999 --> 00:28:23,537
システムメモリに
Ｇバッファが保存されるので

384
00:28:23,704 --> 00:28:28,175
タイルメモリとの往復で
ゲームが重くなります

385
00:28:28,275 --> 00:28:31,345
Ｇバッファは
バンド幅が広いからです

386
00:28:32,412 --> 00:28:36,016
プログラマブルブレンディングなら
メモリ間の往復を省けます

387
00:28:36,116 --> 00:28:39,353
ピクセルをタイルメモリから
読み込むからです

388
00:28:42,489 --> 00:28:44,825
もう２パスは使いません

389
00:28:44,925 --> 00:28:50,597
１つのレンダリングパスで
陰影処理が実行できます

390
00:28:51,465 --> 00:28:56,270
システムメモリへの
Ｇバッファの複製も不要です

391
00:28:57,838 --> 00:29:03,410
無記憶レンダーターゲットは
簡単にメモリを節約できます

392
00:28:57,838 --> 00:29:03,410
無記憶レンダーターゲットは
簡単にメモリを節約できます

393
00:29:03,510 --> 00:29:06,180
テクスチャに
フラグを設定するだけで

394
00:29:06,280 --> 00:29:10,517
アクションを参照せずに
アタッチを使えます

395
00:29:12,453 --> 00:29:15,956
この機能をシェーダに
導入するのは簡単です

396
00:29:19,293 --> 00:29:23,730
フラグメントシェーダの
典型的なコードです

397
00:29:24,431 --> 00:29:27,901
プログラマブルブレンディングは
読み書き時に使用可能です

398
00:29:28,001 --> 00:29:33,240
この例では Ｇバッファを
入力と出力に指定しています

399
00:29:35,475 --> 00:29:38,479
最初に 陰影を計算します

400
00:29:38,779 --> 00:29:42,750
サンプリングはせず
Ｇバッファを用います

401
00:29:44,651 --> 00:29:50,524
次に 蓄えた計算結果を
Ｇバッファに返します

402
00:29:52,326 --> 00:29:54,261
これで終了です

403
00:29:54,361 --> 00:29:59,733
同一のアタッチを参照する
複数のパスの処理に有効です

404
00:30:01,468 --> 00:30:03,637
イメージブロックを使えば

405
00:30:03,737 --> 00:30:07,007
複数のレンダーパスを
統合できます

406
00:30:12,346 --> 00:30:15,415
データは
タイルメモリで処理します

407
00:30:15,582 --> 00:30:16,884
Metalでは

408
00:30:16,984 --> 00:30:21,021
レンダーパスの配列としての
画素を使いません

409
00:30:21,321 --> 00:30:26,126
直接 シェーディング言語に
置き換えられます

410
00:30:27,861 --> 00:30:30,464
使用しているテクスチャの
圧縮フォーマットに合わせ

411
00:30:30,564 --> 00:30:32,499
シェーディング言語に
書き換えます

412
00:30:32,733 --> 00:30:37,004
シェーダにアクセスすると
圧縮や解凍されるのです

413
00:30:37,604 --> 00:30:42,709
頂点バッファと
定数バッファもこの方法で

414
00:30:42,810 --> 00:30:44,812
データを圧縮できます

415
00:30:46,947 --> 00:30:50,951
より複雑な画像データも
描画できます

416
00:30:51,051 --> 00:30:56,256
配列や構造体のネスト
または両方を使えます

417
00:30:58,959 --> 00:31:01,395
ピクセル配列を変更すれば

418
00:30:58,959 --> 00:31:01,395
ピクセル配列を変更すれば

419
00:31:01,495 --> 00:31:04,498
パス上のレイアウトも
変わります

420
00:31:04,865 --> 00:31:07,935
レンダーパスを統合して
バンド幅を減らす方法は

421
00:31:08,035 --> 00:31:11,038
プログラマブルブレンディング
だけでは不可能でした

422
00:31:11,538 --> 00:31:13,040
例を見ましょう

423
00:31:15,609 --> 00:31:18,145
先ほどはプログラマブル
ブレンディングで

424
00:31:18,245 --> 00:31:20,414
遅延シェーディングを
１パスで実行しました

425
00:31:20,714 --> 00:31:24,184
これをイメージブロックを
使用して行います

426
00:31:25,319 --> 00:31:29,223
イメージブロックには
リソースがありません

427
00:31:29,923 --> 00:31:32,693
アルゴリズムを
そのまま書ける上に

428
00:31:32,826 --> 00:31:38,098
Ｇバッファを反映したタイル
メモリを再利用できます

429
00:31:38,699 --> 00:31:44,304
タイルメモリを再利用し
透明処理技術を加えます

430
00:31:44,404 --> 00:31:46,440
マルチレイヤー
アルファブレンディングです

431
00:31:51,311 --> 00:31:53,781
この方法はMLABとも呼ばれ

432
00:31:54,148 --> 00:31:58,218
画素ごとの固定長配列で
透過を行います

433
00:31:58,519 --> 00:32:01,655
フラグメントは配列の深度で
ソートされます

434
00:31:58,519 --> 00:32:01,655
フラグメントは配列の深度で
ソートされます

435
00:32:02,389 --> 00:32:05,325
フラグメント深度が最後の
配列より深ければ

436
00:32:05,425 --> 00:32:09,563
エレメントは
統合されることになります

437
00:32:11,565 --> 00:32:15,035
MLABではタイルメモリを使い
高速でソートをします

438
00:32:15,702 --> 00:32:20,641
同じことをオフチップで
すると費用がかさみます

439
00:32:23,210 --> 00:32:28,015
A11では高度な
ピクセル処理を行えます

440
00:32:29,183 --> 00:32:32,019
しかし Ｇバッファと
MLABのデータ構造を―

441
00:32:32,119 --> 00:32:34,888
同時に処理することは
できないのです

442
00:32:35,522 --> 00:32:38,492
ただ この２つを同時に
処理する必要はありません

443
00:32:38,826 --> 00:32:43,697
イメージブロックで
ピクセル配列を変更できます

444
00:32:45,732 --> 00:32:48,135
ピクセル配列の
変更に必要な―

445
00:32:48,235 --> 00:32:50,537
タイルシェーディングの
説明をします

446
00:32:56,743 --> 00:32:59,313
タイルシェーディングは
新しいプログラム工程であり

447
00:32:59,413 --> 00:33:02,316
レンダーパスに対し
処理能力を発揮します

448
00:32:59,413 --> 00:33:02,316
レンダーパスに対し
処理能力を発揮します

449
00:33:02,583 --> 00:33:03,784
この工程で―

450
00:33:03,884 --> 00:33:06,520
タイルごとのスレッド
グループを実行します

451
00:33:06,720 --> 00:33:09,189
１スレッドを
タイル単位で使っても

452
00:33:09,289 --> 00:33:11,191
ピクセル単位で使っても
いいのです

453
00:33:14,194 --> 00:33:16,296
ドローコールと
スレッドグループを

454
00:33:16,396 --> 00:33:19,466
インターリーブできます

455
00:33:19,666 --> 00:33:22,202
タイルシェーダはタイル
メモリにアクセスするので

456
00:33:22,302 --> 00:33:24,838
イメージブロックの
ピクセルを読み書きできます

457
00:33:26,406 --> 00:33:29,243
タイル単位の
前方シェーディングを

458
00:33:29,343 --> 00:33:31,645
最適化する過程を
見てみましょう

459
00:33:34,915 --> 00:33:38,285
前方シェーディングの技術も
レイヤー化されています

460
00:33:38,519 --> 00:33:42,489
MSAやマテリアルが
必要な時に使われます

461
00:33:42,689 --> 00:33:45,893
透過や不透過のジオメトリに
同じような効果があります

462
00:33:47,494 --> 00:33:50,731
前方シェーディングは
３つのパスで構成されます

463
00:33:51,231 --> 00:33:54,601
シーンの深度バッファを
出力するレンダーパス

464
00:33:55,002 --> 00:33:59,606
その深度バッファを使い
タイルごとの深度バウンドや

465
00:33:59,706 --> 00:34:02,776
ライトリストを
計算するコンピュートパス

466
00:33:59,706 --> 00:34:02,776
ライトリストを
計算するコンピュートパス

467
00:34:03,277 --> 00:34:08,415
そして シャドウを投影する
別のレンダーパスです

468
00:34:11,618 --> 00:34:15,589
これらのレンダーは
組み合わせて使われます

469
00:34:15,688 --> 00:34:19,560
パス同士のやりとりには
システムメモリを使いますが

470
00:34:20,060 --> 00:34:24,398
計算を同時に行うことで
レンダーパスを統合できます

471
00:34:26,967 --> 00:34:28,569
タイルシェーダで
深度バウンドと

472
00:34:28,668 --> 00:34:32,873
ライトカリングを行い
シングルパスに統合できます

473
00:34:33,373 --> 00:34:38,679
深度はパスのどの地点
からでもアクセス可能です

474
00:34:42,783 --> 00:34:46,587
つまり情報量を減らすことが
可能なのです

475
00:34:46,820 --> 00:34:49,889
タイルシェーダの出力先は
システムメモリです

476
00:34:50,757 --> 00:34:54,561
ディスパッチは描画と
同時に進行できますが

477
00:34:54,661 --> 00:34:57,464
次の機能を使えば
操作性が向上します

478
00:34:57,564 --> 00:34:59,133
スレッドグループメモリです

479
00:35:05,406 --> 00:35:08,575
Metalの機能としても
知られていますが

480
00:35:08,809 --> 00:35:12,946
スレッドが高速なオンチップ
メモリでデータを共有します

481
00:35:13,680 --> 00:35:17,718
スレッドグループメモリは
レンダーパスから使えます

482
00:35:18,552 --> 00:35:23,023
その際に 今までとは異なる
２つの特性があります

483
00:35:23,557 --> 00:35:25,092
フラグメントシェーダが

484
00:35:25,192 --> 00:35:27,828
同一のスレッドグループ
メモリにアクセスすることと

485
00:35:28,095 --> 00:35:30,564
スレッドグループメモリの
コンテンツが

486
00:35:30,664 --> 00:35:32,432
タイルと共に
持続することです

487
00:35:33,834 --> 00:35:36,670
描画と演算の
データを共有するための

488
00:35:36,770 --> 00:35:39,606
強力なツールになるのです

489
00:35:40,407 --> 00:35:45,979
以前は倍の容量のスレッド
グループメモリでした

490
00:35:46,079 --> 00:35:48,649
多くの中間データを
保存するためです

491
00:35:50,651 --> 00:35:52,820
スレッドグループの
パーシステンスを使い

492
00:35:52,920 --> 00:35:55,422
前方シェーディングを
最適化します

493
00:35:58,158 --> 00:36:03,197
パーシステンスを用いて
タイルシェーディング段階の

494
00:35:58,158 --> 00:36:03,197
パーシステンスを用いて
タイルシェーディング段階の

495
00:36:03,297 --> 00:36:07,468
描画データをスレッド
グループメモリに記述します

496
00:36:08,902 --> 00:36:11,638
中間データは
GPUに残りません

497
00:36:11,772 --> 00:36:15,509
最終イメージのみがシステム
メモリに保存されます

498
00:36:16,410 --> 00:36:22,049
情報量を最小化することで
パフォーマンスが向上します

499
00:36:23,684 --> 00:36:27,821
シェーディング言語で
パーシステンスを利用します

500
00:36:31,558 --> 00:36:35,729
上側の関数は
ライトカリングの命令です

501
00:36:35,829 --> 00:36:40,634
タイルごとの視すい台で
ライトマスクを計算します

502
00:36:42,069 --> 00:36:45,506
下側は前方シェーディングの
関数です

503
00:36:45,806 --> 00:36:49,610
タイルを横切るライトのみに
シェーディングします

504
00:36:51,879 --> 00:36:53,714
このような機能を用いて

505
00:36:53,814 --> 00:36:56,183
スレッドグループメモリを
共有します

506
00:36:56,283 --> 00:36:59,453
各ポイントの
シェーダを利用するのです

507
00:37:00,187 --> 00:37:03,156
これがパーシステンスを
使用する利点です

508
00:37:06,026 --> 00:37:09,062
それでは次の話題に移ります

509
00:37:09,163 --> 00:37:12,166
透明処理の例を
見てみましょう

510
00:37:14,101 --> 00:37:18,472
イメージブロックには
タイルシェーディングが関係します

511
00:37:19,039 --> 00:37:21,942
タイルシェーディングの
同期によって

512
00:37:22,042 --> 00:37:24,478
安全にレイアウトを
変更します

513
00:37:25,345 --> 00:37:29,416
ライティングとMLABの間に
タイルシェードが必要です

514
00:37:33,086 --> 00:37:39,159
ＧバッファからMLABへの移行
前にライティングをします

515
00:37:39,526 --> 00:37:45,098
ライティングバリューは
MLABへと持ち越せます

516
00:37:49,002 --> 00:37:53,173
それでは
次のテーマに移りましょう

517
00:37:53,273 --> 00:37:59,012
アンチエイリアスと
カバレッジコントロールです

518
00:38:03,150 --> 00:38:06,687
アンチエイリアスにより
画像の品質が向上します

519
00:38:06,787 --> 00:38:09,323
深度 ステンシル
ブレンディングを変更します

520
00:38:09,423 --> 00:38:11,425
シェードはピクセルにつき
一度です

521
00:38:11,792 --> 00:38:16,163
マルチサンプルを
アベレージングし仕上げます

522
00:38:18,031 --> 00:38:21,235
AシリーズのGPUで
効果を発揮します

523
00:38:21,335 --> 00:38:23,637
サンプルが
タイルメモリに保存され

524
00:38:23,737 --> 00:38:27,307
素早いアクセスを可能に
するからです

525
00:38:29,710 --> 00:38:33,046
A11のGPUでは
より早く最適化を行います

526
00:38:33,146 --> 00:38:35,716
画素ごとに色彩を
トラッキングするのです

527
00:38:36,149 --> 00:38:41,054
色ごとに
ブレンディングができます

528
00:38:41,555 --> 00:38:46,727
トライアングルの内部は
１色なので手間が省けます

529
00:38:49,129 --> 00:38:54,134
カラーカバレッジ
コントロールと呼ばれ

530
00:38:54,234 --> 00:38:55,903
GPUによって実行されます

531
00:38:56,437 --> 00:38:59,773
しかし色の読み込みや設定は
タイルシェーダが行います

532
00:39:00,741 --> 00:39:03,076
この機能はタイルメモリの
所定の位置に対し

533
00:39:03,177 --> 00:39:05,779
設定を選んで使うことが
できます

534
00:39:06,113 --> 00:39:08,348
マルチサンプリングされ

535
00:39:08,448 --> 00:39:11,485
粒子状にレンダリングされた
シーンを見てみます

536
00:39:14,388 --> 00:39:17,091
シーンジオメトリを不透過に
レンダリングしたあと

537
00:39:17,191 --> 00:39:18,959
粒子は透過表示されます

538
00:39:19,493 --> 00:39:24,031
マルチサンプリングでは
メリットがありません

539
00:39:24,731 --> 00:39:30,571
余計なコストを避けるため
レンダーに２パス使います

540
00:39:30,871 --> 00:39:36,076
１つ目のパスでは不透過の
シーンジオメトリを生成し

541
00:39:36,543 --> 00:39:39,479
色彩と深度を
システムメモリに解像します

542
00:39:39,580 --> 00:39:43,183
粒子データは後から
付け足せます

543
00:39:43,917 --> 00:39:47,221
２つ目のパスでは
マルチサンプリングなしで

544
00:39:47,321 --> 00:39:49,890
粒子をレンダリングします

545
00:39:51,425 --> 00:39:53,026
もうお分かりでしょう

546
00:39:53,126 --> 00:39:55,696
中間メモリの通信量を
減らすため

547
00:39:55,796 --> 00:39:58,365
２パスを使いタイル
シェーディングをしたのです

548
00:40:01,001 --> 00:40:02,803
それだけでは不十分です

549
00:40:02,903 --> 00:40:04,538
カラーカバレッジ
コントロールにより

550
00:40:04,638 --> 00:40:06,940
マルチサンプリングレートを
変更します

551
00:40:07,474 --> 00:40:11,311
効果的で 操作も簡単です

552
00:40:11,411 --> 00:40:12,813
シェーダを見てみます

553
00:40:16,150 --> 00:40:20,087
画素ごとのサンプルの
平均化が目的です

554
00:40:20,187 --> 00:40:24,491
結果のピクセル値はイメージ
ブロックに再保存します

555
00:40:26,093 --> 00:40:29,663
それぞれのサンプルから
色を使い回すのではなく

556
00:40:29,763 --> 00:40:32,833
A11のカラーレート
ケイパビリティを使います

557
00:40:32,933 --> 00:40:35,202
固有の色を設定するのです

558
00:40:37,204 --> 00:40:39,139
適正な平均化のため

559
00:40:39,239 --> 00:40:42,442
関連するサンプルの数で
色彩を計測します

560
00:40:42,542 --> 00:40:47,581
カラーカバレッジマスクの
ビット数も計算します

561
00:40:49,149 --> 00:40:52,519
更に サンプルの合計数で
平均値を出します

562
00:40:54,021 --> 00:40:56,990
最後に イメージブロックに
その結果を書き出します

563
00:40:57,091 --> 00:41:01,495
出力したサンプルマスクで
Metalが結果を適用し

564
00:40:57,091 --> 00:41:01,495
出力したサンプルマスクで
Metalが結果を適用し

565
00:41:01,962 --> 00:41:04,932
すべてのサンプルが
同じ値になります

566
00:41:05,032 --> 00:41:08,969
サンプルごとではなく
ピクセルごとに描画をします

567
00:41:11,305 --> 00:41:13,374
それでは次の話題に移ります

568
00:41:15,943 --> 00:41:18,912
Apple GPUの最適化は
重要で―

569
00:41:19,012 --> 00:41:22,750
パフォーマンスを最大化し
プレイ時間を伸ばします

570
00:41:22,950 --> 00:41:26,253
タイルをiOSに搭載するには
更にすることがあります

571
00:41:26,353 --> 00:41:29,323
元々はコンピュータ用に
設計されたものだからです

572
00:41:29,523 --> 00:41:33,060
ここまで話したことを
具体的に説明してもらいます

573
00:41:33,160 --> 00:41:35,929
エピック･ゲームズの
ニックを呼びましょう

574
00:41:36,030 --> 00:41:36,697
ニック

575
00:41:37,464 --> 00:41:40,534
(拍手)

576
00:41:40,968 --> 00:41:42,069
ありがとう マイケル

577
00:41:43,003 --> 00:41:48,709
コンピュータ用に設計した
ゲームを

578
00:41:49,476 --> 00:41:53,647
Metalを使いiOS向けに
移植する話をします

579
00:41:55,382 --> 00:41:57,584
技術的に難しいことが
いくつもありました

580
00:41:57,684 --> 00:42:00,254
「バトルロイヤル」の
マップは１つで

581
00:41:57,684 --> 00:42:00,254
「バトルロイヤル」の
マップは１つで

582
00:42:00,420 --> 00:42:02,156
６平方キロメートル以上
ありました

583
00:42:02,823 --> 00:42:06,193
メモリに
収まりきらなかったのです

584
00:42:06,360 --> 00:42:09,062
時間経過や破壊もありました

585
00:42:09,163 --> 00:42:11,965
プレイヤーはほぼすべての
物を壊せます

586
00:42:12,399 --> 00:42:14,601
建物を建てることもできます

587
00:42:14,701 --> 00:42:18,172
地図は動的なものとなり
前もって計算できません

588
00:42:19,006 --> 00:42:21,175
マップには100人の
プレイヤーがいて

589
00:42:21,275 --> 00:42:26,914
５万以上の登場人物が
サーバー上にいました

590
00:42:27,014 --> 00:42:28,815
クライアントへも
複製されていました

591
00:42:29,750 --> 00:42:32,052
クロスプレイを
実現したかったので

592
00:42:32,152 --> 00:42:35,823
モバイル端末もサポートする
必要がありました

593
00:42:36,056 --> 00:42:41,328
それを実現するには
ゲームの容量を減らし

594
00:42:41,795 --> 00:42:46,867
端末ごとに制限される
パフォーマンスに合わせます

595
00:42:46,967 --> 00:42:50,504
しかし プレイを
制限することはできません

596
00:42:50,604 --> 00:42:53,740
遠くにある
小さなオブジェクトは

597
00:42:53,841 --> 00:42:56,477
通常なら消してしまいます

598
00:42:56,577 --> 00:42:59,713
しかし プレイヤーがそこに
隠れる場合に備え

599
00:42:59,813 --> 00:43:01,215
残す必要がありました

600
00:42:59,813 --> 00:43:01,215
残す必要がありました

601
00:43:02,783 --> 00:43:05,786
ここでMetalの話をします

602
00:43:05,886 --> 00:43:08,889
できるだけ早くゲームを
リリースするために

603
00:43:08,989 --> 00:43:11,592
Metalが重要になってきます

604
00:43:11,692 --> 00:43:14,161
クオリティの面からもです

605
00:43:14,361 --> 00:43:19,500
複雑なシーンを描くため
ドローコールの性能は重要で

606
00:43:20,467 --> 00:43:24,438
Metalはレンダリングの
機能も十分です

607
00:43:24,571 --> 00:43:26,340
更にプログラマブル
ブレンディングのような

608
00:43:26,440 --> 00:43:28,408
ハードウェア上の機能にも
アクセスできます

609
00:43:28,509 --> 00:43:32,079
GPUのパフォーマンスも
最大化できます

610
00:43:32,179 --> 00:43:34,681
「フォートナイト」を
iOS向けに構成する際にも

611
00:43:34,781 --> 00:43:37,251
レンダリング技術を活用
できる機能があります

612
00:43:38,719 --> 00:43:40,454
レンダリングの際に

613
00:43:40,554 --> 00:43:44,024
カスケードシャドウマップで
指向性ライトを動かせます

614
00:43:44,124 --> 00:43:47,327
時間の変化で太陽や空の
光を変化させるのです

615
00:43:47,961 --> 00:43:51,131
物理ベースマテリアルを
扱う際に―

616
00:43:51,331 --> 00:43:54,701
HDRでレンダリングし
トーンマッピングします

617
00:43:55,569 --> 00:43:57,871
粒子法シミュレーションも
GPUで実行できますし

618
00:43:57,971 --> 00:44:01,208
アーティストが作成した
マテリアルもサポートします

619
00:43:57,971 --> 00:44:01,208
アーティストが作成した
マテリアルもサポートします

620
00:44:01,575 --> 00:44:03,877
これが重要な理由は―

621
00:44:03,977 --> 00:44:08,148
マテリアルの一部が
複雑なことにあります

622
00:44:08,248 --> 00:44:10,417
ディスタンス
エフィシエンシーにおいて

623
00:44:10,517 --> 00:44:13,153
レンダーツリーに使う
インポスターがあります

624
00:44:13,253 --> 00:44:16,090
弊社のテクニカル
アーティストによって

625
00:44:16,190 --> 00:44:21,061
設計図とシェーダグラフを
組み合わせ 創作されます

626
00:44:22,863 --> 00:44:26,867
「フォートナイト」の
Mac上での画面です

627
00:44:26,967 --> 00:44:29,203
ハイスケーラビリティの
設定です

628
00:44:29,903 --> 00:44:34,141
これはミディアム
スケーラビリティ設定

629
00:44:34,708 --> 00:44:37,111
これはiPhone 8 Plusです

630
00:44:37,411 --> 00:44:39,146
iPhone上での表示は

631
00:44:39,279 --> 00:44:44,852
ミディアム設定のMacと
同程度の品質を実現しました

632
00:44:46,753 --> 00:44:49,156
スケーラビリティについて
お話しします

633
00:44:49,389 --> 00:44:51,458
クロスプラット
フォームと―

634
00:44:51,558 --> 00:44:53,927
エコシステムの観点から
説明します

635
00:44:54,094 --> 00:44:58,732
クロスプラットフォームに
必要なことがあります

636
00:44:59,233 --> 00:45:04,104
表示されないようLODを
メッシュから省いたり

637
00:44:59,233 --> 00:45:04,104
表示されないようLODを
メッシュから省いたり

638
00:45:04,204 --> 00:45:08,509
登場人物の数を
減らしたりすることです

639
00:45:08,809 --> 00:45:12,045
特定レベルでの
CPUコストを減らすためです

640
00:45:12,679 --> 00:45:15,382
iOSでは
スケーラビリティのため

641
00:45:15,482 --> 00:45:18,152
ロー ミッド ハイの
３バケットを定義しています

642
00:45:18,252 --> 00:45:22,556
これは他の世代のiPhoneにも
当てはまります

643
00:45:22,656 --> 00:45:26,693
iPhone 6sはロー
iPhone 7はミッドレンジで

644
00:45:26,793 --> 00:45:29,196
iPhone 8とiPhone Xは
ハイエンドです

645
00:45:31,198 --> 00:45:34,601
解像度は
単純かつ効果的な―

646
00:45:34,701 --> 00:45:37,571
スケーラビリティの
選択肢です

647
00:45:37,671 --> 00:45:39,439
端末ごとに調整できます

648
00:45:39,740 --> 00:45:44,111
私たちは可能な限り
バックバッファを使います

649
00:45:44,645 --> 00:45:49,016
余計なアップサンプリングの
コストがかからないからです

650
00:45:49,116 --> 00:45:53,454
３Ｄ画像を低解像度で
生成するサポートもします

651
00:45:53,554 --> 00:45:56,790
クリスプなUIを
作成する時にも行います

652
00:45:56,890 --> 00:46:00,394
例えばiPhone 6では
3D解像度を低く生成し

653
00:45:56,890 --> 00:46:00,394
例えばiPhone 6では
3D解像度を低く生成し

654
00:46:00,494 --> 00:46:04,832
パフォーマンスの目標に
合わせる必要がありました

655
00:46:06,366 --> 00:46:09,603
シャドウも
重要なポイントです

656
00:46:09,703 --> 00:46:12,740
CPUとGPUの両方に
影響があるからです

657
00:46:12,940 --> 00:46:16,410
ローエンド端末では
シャドウを生成しません

658
00:46:16,510 --> 00:46:18,912
ミッドレンジでは
1024x1024テクセルの

659
00:46:19,012 --> 00:46:21,281
１カスケード表示をします

660
00:46:21,381 --> 00:46:25,219
建物のサイズに合わせ
距離を設定しますが

661
00:46:25,319 --> 00:46:28,455
構造物の中に入っても
外から入る光はありません

662
00:46:28,622 --> 00:46:31,925
ハイエンドにはもう１つ
カスケードが加えられます

663
00:46:32,025 --> 00:46:34,828
人物にクリスプなシャドウと
距離のあるシャドウを―

664
00:46:34,928 --> 00:46:36,330
加えることができます

665
00:46:37,331 --> 00:46:39,733
草木も
スケーラビリティの軸です

666
00:46:39,833 --> 00:46:42,536
ローエンドでは
草木を生成しません

667
00:46:42,636 --> 00:46:46,673
ミッドレンジでは出力可能な
30％の密度で生成します

668
00:46:46,773 --> 00:46:51,612
ハイエンドでは100％の
密度で生成します

669
00:46:54,147 --> 00:46:56,683
スケーラビリティでは
メモリは面白い動きをします

670
00:46:56,783 --> 00:46:59,253
パフォーマンスと
相関関係がありません

671
00:46:59,353 --> 00:47:02,156
iPhone 8は
iPhone 7 Plusよりも

672
00:46:59,353 --> 00:47:02,156
iPhone 8は
iPhone 7 Plusよりも

673
00:47:02,256 --> 00:47:04,157
メモリが小さいのです

674
00:47:04,358 --> 00:47:06,193
アカウントの
スケーラビリティの観点では

675
00:47:06,293 --> 00:47:08,162
メモリの扱いが変わります

676
00:47:08,262 --> 00:47:11,932
直交座標系として
扱うのです

677
00:47:12,099 --> 00:47:15,569
メモリの２つのバケットが
ローメモリとハイメモリです

678
00:47:15,936 --> 00:47:19,206
ローメモリではシャドウや
草木を作れません

679
00:47:19,306 --> 00:47:21,475
メモリプールの領域も
減らします

680
00:47:21,575 --> 00:47:25,612
GPUの粒子を１万6000に
制限し

681
00:47:25,712 --> 00:47:29,583
装飾やテクスチャメモリ用の
プールを減らしました

682
00:47:31,418 --> 00:47:36,123
端末に合わせ
メモリの最適化もします

683
00:47:36,223 --> 00:47:38,692
一番重要なのが
レベルストリーミングで

684
00:47:38,792 --> 00:47:41,895
プレイヤーの周囲以外の
情報をメモリから消します

685
00:47:42,663 --> 00:47:46,200
ASTCのテクスチャ圧縮を使い

686
00:47:46,300 --> 00:47:50,671
クオリティよりもサイズを
優先する場合が多いです

687
00:47:50,771 --> 00:47:54,441
クリエイターに
多くのツールを提供し

688
00:47:54,908 --> 00:47:58,445
不必要なLODを
使わないようにします

689
00:47:58,545 --> 00:48:02,683
プラットフォームごとの
音響の変化も減らします

690
00:47:58,545 --> 00:48:02,683
プラットフォームごとの
音響の変化も減らします

691
00:48:04,852 --> 00:48:06,920
フレームレートターゲットの
話をします

692
00:48:07,021 --> 00:48:11,959
iOSで目指す30fpsは
最高レベルの再現性ですが

693
00:48:12,059 --> 00:48:17,531
それぞれの端末でCPUやGPUを
限界までは使えません

694
00:48:17,998 --> 00:48:20,300
OSがダウンクロックを起こし

695
00:48:20,400 --> 00:48:22,803
フレームレートが
出なくなります

696
00:48:23,504 --> 00:48:25,239
バッテリー消費も問題です

697
00:48:25,339 --> 00:48:28,942
利用者が短時間にいくつもの
ゲームをプレイする場合

698
00:48:29,309 --> 00:48:33,347
端末への負担を考慮
しなければなりません

699
00:48:34,448 --> 00:48:39,119
その結果 60fpsを
目指すことにしました

700
00:48:39,219 --> 00:48:40,954
しかしVSYNCは30fpsです

701
00:48:41,054 --> 00:48:43,957
「フォートナイト」の
マップ内にいる間

702
00:48:44,057 --> 00:48:46,994
iPhoneがリソースを使う量は
半分に抑えられます

703
00:48:47,094 --> 00:48:50,297
バッテリーへの負担を
減らせます

704
00:48:52,666 --> 00:48:57,204
毎日パフォーマンスの
動きを見て軌道修正します

705
00:48:57,304 --> 00:49:00,774
追跡用のシステムで
動きが見られます

706
00:48:57,304 --> 00:49:00,774
追跡用のシステムで
動きが見られます

707
00:49:00,874 --> 00:49:05,879
マップの中でカギとなる
場所の動きを見ます

708
00:49:05,979 --> 00:49:10,417
ティルテッド･タワーなどの
特定のポイントです

709
00:49:10,517 --> 00:49:13,120
「バトルロイヤル」で
おなじみですね

710
00:49:13,220 --> 00:49:14,688
バジェットを超えると―

711
00:49:14,788 --> 00:49:18,759
パフォーマンスを見て
最適化する場所を探します

712
00:49:18,859 --> 00:49:21,395
１日に100人の
プレイヤーに試遊させ

713
00:49:21,495 --> 00:49:24,998
プレイ中のパフォーマンスの
変化も調べます

714
00:49:25,098 --> 00:49:28,802
対戦時の動きも
しっかりと追跡します

715
00:49:28,902 --> 00:49:33,173
後から記録を見て
パフォーマンスを確認し

716
00:49:33,507 --> 00:49:36,110
障害などがないか探します

717
00:49:36,210 --> 00:49:40,614
何か見つかれば
端末から機器を外し

718
00:49:40,714 --> 00:49:44,485
最適化できる箇所を探します

719
00:49:44,952 --> 00:49:46,020
Unrealの特徴である―

720
00:49:46,120 --> 00:49:48,555
リプレイ機能のサポートも
行っています

721
00:49:48,755 --> 00:49:51,759
クライアントの視点に合わせ
リプレイする機能です

722
00:49:51,859 --> 00:49:54,828
何度も繰り返しプレイを行い
分析をします

723
00:49:54,928 --> 00:50:00,534
更に 既に行われた最適化の
影響も調べます

724
00:49:54,928 --> 00:50:00,534
更に 既に行われた最適化の
影響も調べます

725
00:50:02,636 --> 00:50:05,572
Metalの特性について
お話しします

726
00:50:06,140 --> 00:50:10,210
ほとんどの端末には
２つのコアが入っています

727
00:50:10,544 --> 00:50:14,014
そのコアを活用するのが

728
00:50:14,114 --> 00:50:16,350
ゲームスレッドと
レンダリングスレッドです

729
00:50:16,450 --> 00:50:17,451
ゲームスレッドでは―

730
00:50:17,551 --> 00:50:21,054
通信 シミュレーションや
物理的な動きを扱います

731
00:50:21,221 --> 00:50:24,057
レンダリングスレッドで
扱うのは

732
00:50:24,157 --> 00:50:26,427
場面の計算に関わる
カリングやMetalなど

733
00:50:26,527 --> 00:50:31,598
Asyncスレッドでは主に
ストリーミングを扱います

734
00:50:31,698 --> 00:50:34,701
テクスチャストリーミングや
レベルストリーミングです

735
00:50:35,903 --> 00:50:37,971
最新機種は
２つの高性能コアと―

736
00:50:38,072 --> 00:50:39,640
４つの高効率コアを
搭載しています

737
00:50:39,740 --> 00:50:41,975
３つのタスクスレッドを
追加し

738
00:50:42,075 --> 00:50:44,511
並列アルゴリズムも
可能にしました

739
00:50:44,611 --> 00:50:49,083
アニメーションを
マルチフレームで表示します

740
00:50:49,183 --> 00:50:52,119
CPUを使った粒子法や
物理演算も行います

741
00:50:52,920 --> 00:50:55,355
シーンのカリングやその他の
タスクもです

742
00:50:57,558 --> 00:50:59,059
ドローコールの話に戻ります

743
00:50:59,159 --> 00:51:02,029
ドローコールは動作の
障害になる主な要因です

744
00:50:59,159 --> 00:51:02,029
ドローコールは動作の
障害になる主な要因です

745
00:51:02,129 --> 00:51:04,798
これに対抗できるのが
Metalなのです

746
00:51:05,399 --> 00:51:08,936
MetalはOpenGLよりも
３倍ほど早く―

747
00:51:09,036 --> 00:51:11,471
パフォーマンスを行います

748
00:51:12,105 --> 00:51:15,976
無理にドローコールを減らす
必要がなくなりました

749
00:51:16,076 --> 00:51:21,281
装飾オブジェクトに対し
距離のカリングをしたり

750
00:51:21,515 --> 00:51:25,552
詳細システムの階層レベルを
活用しなくていいのです

751
00:51:27,888 --> 00:51:31,959
これは時間をかけて追跡した
POIの１つです

752
00:51:32,059 --> 00:51:33,994
ゲームをご存知の方には
お分かりの通り

753
00:51:34,094 --> 00:51:36,230
ティルテッド･タワーからの
眺めです

754
00:51:36,563 --> 00:51:41,168
マップの中でもドロー
コールが集中する場所です

755
00:51:41,268 --> 00:51:44,972
ドローコールの数は1300にも
及びます

756
00:51:45,105 --> 00:51:50,978
メインパスのみでシャドウや
UIは含まれていません

757
00:51:51,078 --> 00:51:53,313
Metalであれば
iPhone 8 Plusでも―

758
00:51:53,414 --> 00:51:56,683
５ミリセカンド未満で
表示できます

759
00:51:58,652 --> 00:52:01,722
HLODはUnrealの持つ
機能です

760
00:51:58,652 --> 00:52:01,722
HLODはUnrealの持つ
機能です

761
00:52:01,822 --> 00:52:04,291
複数のドローコールをまとめ

762
00:52:04,391 --> 00:52:07,194
簡略化されたメッシュを
生成します

763
00:52:07,294 --> 00:52:11,865
同時にマテリアルを生成し
描写をレンダリングします

764
00:52:11,999 --> 00:52:15,269
１つのドローコールで
このエリアをまかないます

765
00:52:15,369 --> 00:52:17,838
この機能はPOIにも使われ

766
00:52:17,938 --> 00:52:21,909
遠くの描写を簡略化し
生成することができます

767
00:52:22,009 --> 00:52:24,912
スカイダイビングの際には
マップ全体が見えます

768
00:52:25,012 --> 00:52:29,950
マップ上の崖の上からや
自分の建てた塔の上から

769
00:52:30,050 --> 00:52:33,954
２キロメートル先が
見えるのです

770
00:52:36,123 --> 00:52:39,093
Metalについて
更に説明するため

771
00:52:39,193 --> 00:52:42,429
パイプラインステート
オブジェクトの話をします

772
00:52:42,529 --> 00:52:45,265
「フォートナイト」にPSOを
実装するには―

773
00:52:45,365 --> 00:52:46,467
時間がかかりました

774
00:52:46,667 --> 00:52:52,406
ゲーム中に作られるPSOの
数は少なくしたいところです

775
00:52:52,506 --> 00:52:57,010
多すぎればゲームの進行に
支障が出ることになります

776
00:52:57,111 --> 00:52:59,646
解決法があります

777
00:52:59,747 --> 00:53:02,883
オフラインで関数を
コンパイルし

778
00:52:59,747 --> 00:53:02,883
オフラインで関数を
コンパイルし

779
00:53:02,983 --> 00:53:05,686
すべての関数を１つの
ライブラリに収めるのです

780
00:53:05,786 --> 00:53:09,490
ロード時間中にすべての
PSOを作成したいところです

781
00:53:09,990 --> 00:53:11,558
できない場合はどうすれば
いいのでしょう？

782
00:53:11,658 --> 00:53:14,027
置換行列などは行いません

783
00:53:14,127 --> 00:53:17,397
現実的な方法は
たくさんあります

784
00:53:17,931 --> 00:53:22,603
アーティストが作成した
数千のシェーダ

785
00:53:22,703 --> 00:53:25,772
シャドウのカスケードの
数に基づく―

786
00:53:25,873 --> 00:53:28,408
複数のライティングシナリオ

787
00:53:28,509 --> 00:53:31,812
違うレンダーターゲット
フォーマットやMSAAなどです

788
00:53:32,646 --> 00:53:35,549
配列を最小化するのも
効果があります

789
00:53:35,649 --> 00:53:40,354
静的配列を作成するより
動的配列が効果的です

790
00:53:41,321 --> 00:53:42,656
しかし うまくいかない
こともあります

791
00:53:42,856 --> 00:53:46,360
必要と思われる
サブセットの中から

792
00:53:46,460 --> 00:53:49,329
共通の変数をロード中に
特定することにしました

793
00:53:49,429 --> 00:53:51,098
すべてではありません

794
00:53:51,198 --> 00:53:56,336
そのため カメラを飛ばす
自動化パスを作成しました

795
00:53:56,437 --> 00:54:00,073
環境を生成するために必要な
PSOを記録するためです

796
00:53:56,437 --> 00:54:00,073
環境を生成するために必要な
PSOを記録するためです

797
00:54:00,174 --> 00:54:04,111
毎日のプレイテストで
PSOのデータが集まりました

798
00:54:04,211 --> 00:54:07,781
自動化パスでは集められない
データでした

799
00:54:07,881 --> 00:54:11,852
自動化パスでは装飾などの
データも集められました

800
00:54:12,786 --> 00:54:15,389
武器の使用効果などもです

801
00:54:16,423 --> 00:54:20,627
自動化パスとプレイテストの
データは集計され

802
00:54:20,728 --> 00:54:24,765
それを参考にロード時間を
ゲームに組み込みました

803
00:54:24,865 --> 00:54:28,135
その結果 ランタイム時に
作成したPSOの数字は

804
00:54:28,235 --> 00:54:31,305
どんなプレイの時でも
平均して１桁以内です

805
00:54:31,405 --> 00:54:35,175
PSOで作成しても
プレイに障害は出ません

806
00:54:37,511 --> 00:54:40,013
リソース割り当ての
話をします

807
00:54:40,280 --> 00:54:44,952
通常 リソースを作成したり
消去したりすると―

808
00:54:45,185 --> 00:54:47,688
コストがかかります

809
00:54:47,788 --> 00:54:49,923
そこで考えるのが
フレームごとに作成した―

810
00:54:50,023 --> 00:54:53,227
MallocとFreeの関数を
減らすことです

811
00:54:53,327 --> 00:54:56,697
何度もリソースを作成したり
手放すのは面倒です

812
00:54:56,797 --> 00:54:59,833
コンテンツに
動的にアクセスする時に

813
00:54:59,933 --> 00:55:03,570
移動できるオブジェクトが
多くある場合もあります

814
00:54:59,933 --> 00:55:03,570
移動できるオブジェクトが
多くある場合もあります

815
00:55:03,670 --> 00:55:05,339
その時は仕方がありません

816
00:55:05,506 --> 00:55:11,078
そこでバッファの
細分割り当てをします

817
00:55:11,178 --> 00:55:13,146
割り当て戦略の変更です

818
00:55:13,247 --> 00:55:16,183
前もって バッファの領域を
多く割り当てておき

819
00:55:16,283 --> 00:55:18,919
それを細分化してエンジンに
割り当てます

820
00:55:19,019 --> 00:55:22,256
毎回 Metalにバッファの
リクエストをしないためです

821
00:55:22,923 --> 00:55:24,758
効率的です

822
00:55:26,160 --> 00:55:29,129
プログラマブル
ブレンディングを利用し

823
00:55:29,229 --> 00:55:34,167
リゾルブ リストア コストを
減らすことができます

824
00:55:34,435 --> 00:55:39,973
特に深度にアクセスする際に
有用です

825
00:55:40,073 --> 00:55:43,610
ソフトパーティクルの
ブレンディングなどです

826
00:55:43,844 --> 00:55:46,080
前方パスで
アルファチャンネルに対し

827
00:55:46,180 --> 00:55:47,781
リニア深度を書き込みます

828
00:55:47,881 --> 00:55:50,951
転写と透過パスでするのが
アルファチャンネルを

829
00:55:51,051 --> 00:55:54,087
再び読み込むプログラマブル
ブレンディングです

830
00:55:54,188 --> 00:55:57,157
メインメモリに対する
深度バッファを

831
00:55:57,257 --> 00:56:00,460
分割したことがなくても
深度を利用できます

832
00:55:57,257 --> 00:56:00,460
分割したことがなくても
深度を利用できます

833
00:56:01,795 --> 00:56:04,598
MSAAのクオリティ向上にも
利用できます

834
00:56:04,698 --> 00:56:09,803
HDRレンダリングを行い
MSAAの処理もすることで

835
00:56:09,903 --> 00:56:12,306
線がギザギザになります

836
00:56:12,406 --> 00:56:16,910
明るい空や暗い前景に
影響します

837
00:56:17,010 --> 00:56:21,615
ボックスフィルター処理を
することで

838
00:56:21,715 --> 00:56:26,820
明るかったり暗かったりする
サブサンプルに対し

839
00:56:26,920 --> 00:56:31,291
白に近い非常に明るい
ピクセルを返します

840
00:56:31,391 --> 00:56:34,094
大きく変わってしまいます

841
00:56:34,695 --> 00:56:40,500
そこでMSAAサンプルに対し
プレトーンマップをします

842
00:56:41,001 --> 00:56:43,237
それから通常のMSAA処理をし

843
00:56:43,337 --> 00:56:47,007
ポストプロセス処理をして
プレトーンマップをします

844
00:56:47,374 --> 00:56:50,477
ここでプログラマブル
ブレンディングを使います

845
00:56:50,677 --> 00:56:55,048
記録したMSAAカラー
バッファも読み込めます

846
00:56:55,249 --> 00:56:57,117
負担に応じて選べます

847
00:56:58,886 --> 00:57:04,324
今後 Metalで行いたいのが
並列レンダリングです

848
00:56:58,886 --> 00:57:04,324
今後 Metalで行いたいのが
並列レンダリングです

849
00:57:04,425 --> 00:57:07,194
macOSでは並列でも

850
00:57:07,294 --> 00:57:09,530
コマンドバッファを
サポートしています

851
00:57:09,630 --> 00:57:15,002
並列コマンドのエンコーダを
iOSで扱うのが目標です

852
00:57:15,102 --> 00:57:17,938
メインフォワードパスで
描画されることが多いです

853
00:57:18,038 --> 00:57:21,842
並列化することは重要です

854
00:57:22,075 --> 00:57:27,247
並列レンダリングを
ソートできてもいいですね

855
00:57:27,881 --> 00:57:30,651
強くて速いコアに対し―

856
00:57:30,751 --> 00:57:35,722
最新機種の高効率なコアで
どんな命令を出せるか

857
00:57:35,823 --> 00:57:39,193
バッテリー使用量にも
違いがありそうです

858
00:57:40,861 --> 00:57:42,129
Metalのヒープです

859
00:57:42,229 --> 00:57:45,032
バッファの細分割り当ては
Metalが行うでしょう

860
00:57:45,499 --> 00:57:47,167
理由はコードと―

861
00:57:47,267 --> 00:57:50,137
Metalはテクスチャにも
使えるからです

862
00:57:50,237 --> 00:57:54,174
テクスチャストリーミングが
原因で

863
00:57:54,274 --> 00:57:57,911
プレイ中に
問題が起こるのを避けます

864
00:57:58,045 --> 00:58:01,782
ヒープはゲームの障害を
なくしてくれます

865
00:57:58,045 --> 00:58:01,782
ヒープはゲームの障害を
なくしてくれます

866
00:58:01,882 --> 00:58:06,987
我々の会社でも
実現したいのは

867
00:58:07,087 --> 00:58:10,724
パスの間に適切な
フェンスを設定することです

868
00:58:10,824 --> 00:58:13,627
知らなければならないのは
リソースが頂点シェーダや

869
00:58:13,727 --> 00:58:18,065
ピクセルシェーダによって
読み書きされるかどうか

870
00:58:18,165 --> 00:58:22,736
そのためにはいくつもの
修正が必要です

871
00:58:23,837 --> 00:58:27,241
iOSの高品質グラフィックも
追求します

872
00:58:27,341 --> 00:58:30,510
去年 コンピュータ向けの
レンダラーが

873
00:58:30,611 --> 00:58:34,781
ハイエンドのiOS端末で
できることを披露しました

874
00:58:34,882 --> 00:58:37,818
方向性は変えず

875
00:58:37,918 --> 00:58:42,256
コンピュータ向け機能を
iOSで実現していきます

876
00:58:45,592 --> 00:58:47,628
コンピュータ向け
レンダラーを

877
00:58:47,728 --> 00:58:51,832
iOSレンダラーと統一する
ことを目指します

878
00:58:53,634 --> 00:58:56,170
ここからは
マイケルに代わります

879
00:58:56,270 --> 00:58:59,940
(拍手)

880
00:59:00,073 --> 00:59:02,643
Metalは
ローオーバーヘッドです

881
00:59:02,876 --> 00:59:04,378
しかし オブジェクトを
効率的に生成するには

882
00:59:04,478 --> 00:59:06,046
マルチスレッドが必要です

883
00:59:06,146 --> 00:59:10,718
MetalはGPUとCPUを最大限に
活用するため生まれました

884
00:59:11,652 --> 00:59:14,555
しかし
高機能のレンダリングには

885
00:59:14,655 --> 00:59:16,423
しっかりとした
制御が必要です

886
00:59:16,757 --> 00:59:21,595
Metaはメモリの扱いやGPUの
並列処理を制御します

887
00:59:22,529 --> 00:59:26,000
新しい機能である
間接コマンドバッファでは

888
00:59:26,100 --> 00:59:28,602
GPUで全てのコマンドを
作成できます

889
00:59:28,702 --> 00:59:30,671
CPUでは他のタスクを
実行します

890
00:59:31,205 --> 00:59:36,510
GPU主導のパイプラインを
構成できるのです

891
00:59:37,511 --> 00:59:41,949
MetalはA11 GPUの
先進アーキテクチャです

892
00:59:42,049 --> 00:59:44,151
レンダリング技術を最適化し

893
00:59:44,251 --> 00:59:47,154
最大のパフォーマンスと
長いプレイ時間を実現します

894
00:59:49,690 --> 00:59:54,528
詳細については
ホームページをご覧ください

895
00:59:55,095 --> 00:59:55,796
ありがとう

896
00:59:56,497 --> 00:59:58,699
(拍手)