
1
00:00:07,074 --> 00:00:16,517
(音楽)

2
00:00:27,127 --> 00:00:34,468
(拍手)

3
00:00:34,601 --> 00:00:35,469
こんにちは

4
00:00:36,403 --> 00:00:38,605
標準ライブラリ担当のベンです

5
00:00:38,805 --> 00:00:41,074
後ほど ダグも紹介します

6
00:00:41,175 --> 00:00:43,477
ではSwiftのジェネリクスについて

7
00:00:45,078 --> 00:00:48,415
最近のリリースで
追加した新機能は―

8
00:00:48,715 --> 00:00:52,853
条件付き準拠や再帰的な
プロトコル制約などです

9
00:00:53,854 --> 00:00:59,660
Swiftで力を入れてきたのは
ジェネリクスの表現力向上です

10
00:01:00,427 --> 00:01:03,530
4.2のリリースは大転換です

11
00:01:04,164 --> 00:01:10,838
描いてきた標準ライブラリを
やっと完全に実装できました

12
00:01:11,004 --> 00:01:15,442
これはAPIの安定性の実現に
必須でした

13
00:01:17,110 --> 00:01:23,116
では 改めて客観的視点から
ジェネリクスを見てみましょう

14
00:01:23,417 --> 00:01:25,485
本日のトピックです

15
00:01:25,586 --> 00:01:31,425
新旧のジェネリクス機能を含め
全体像を理解してください

16
00:01:32,693 --> 00:01:35,762
まずジェネリクスの動機に触れます

17
00:01:36,964 --> 00:01:43,237
次に標準ライブラリの型を例に
プロトコル設計について話します

18
00:01:44,505 --> 00:01:51,411
そしてプロトコル継承を振り返り
条件付き準拠との対話を見ます

19
00:01:51,912 --> 00:01:56,416
最後は クラスとジェネリクスで
締めくくります

20
00:01:58,452 --> 00:02:01,021
まず ジェネリクスの重要性です

21
00:01:58,452 --> 00:02:01,021
まず ジェネリクスの重要性です

22
00:02:01,722 --> 00:02:06,960
インパクトを見る方法の１つは
型といったコレクション設計です

23
00:02:08,161 --> 00:02:12,132
バッファと呼びますが
配列型に似ています

24
00:02:12,733 --> 00:02:16,503
バッファ読み込みのAPIには―

25
00:02:16,603 --> 00:02:21,808
要素のカウントや
ポジションへのフェッチがあります

26
00:02:22,009 --> 00:02:24,444
では その返り値の型は？

27
00:02:25,112 --> 00:02:31,818
もしジェネリクスがなければ
何らかの型の作成が必要になります

28
00:02:32,019 --> 00:02:35,322
id型やVoid Starです

29
00:02:35,422 --> 00:02:41,595
Swiftでは Anyが
あらゆる型の代わりとなります

30
00:02:43,897 --> 00:02:47,901
バッファの処理も返り値はAnyです

31
00:02:48,001 --> 00:02:51,972
しかし
不愉快なユーザ体験となります

32
00:02:52,072 --> 00:02:58,245
使うためにはボックスから
その型を取り出さねばなりません

33
00:03:00,814 --> 00:03:04,651
エラーも起こりやすくなります

34
00:03:04,751 --> 00:03:10,724
文字列バッファのコードに
整数を入れてしまったら？

35
00:03:12,259 --> 00:03:19,233
使いやすさだけでなく メモリ内の
値の表し方も解決したいですね

36
00:03:21,201 --> 00:03:24,671
文字列バッファの理想的な表現は

37
00:03:24,771 --> 00:03:29,977
要素が１列に並ぶ
連続したメモリブロックです

38
00:03:31,311 --> 00:03:34,615
でも 型なしではうまくいきません

39
00:03:34,715 --> 00:03:38,752
対応する型が バッファに
分からないからです

40
00:03:38,852 --> 00:03:43,090
それで Anyのような
万能な型を使いますが―

41
00:03:43,423 --> 00:03:48,195
型のボックス化などで
オーバーヘッドが生じます

42
00:03:50,531 --> 00:03:56,637
整数バッファが欲しいだけでも
コンパイラに示せません

43
00:03:56,737 --> 00:04:00,240
やむを得ず柔軟性を代償にします

44
00:03:56,737 --> 00:04:00,240
やむを得ず柔軟性を代償にします

45
00:04:01,542 --> 00:04:05,279
更に Anyは
あらゆる型になるので

46
00:04:05,379 --> 00:04:12,152
内部メモリにとって大きい場合は
インダイレクションも必要です

47
00:04:12,252 --> 00:04:16,990
メモリ中にある値に
ポインタ保持も必要です

48
00:04:17,824 --> 00:04:23,797
この問題の解決は
パフォーマンスにも関わります

49
00:04:24,698 --> 00:04:26,500
そこで使う技術が―

50
00:04:26,733 --> 00:04:29,169
パラメータ多相です

51
00:04:29,269 --> 00:04:33,373
これが Swiftのジェネリクスです

52
00:04:35,142 --> 00:04:40,848
バッファにより多くの情報を与え
対応する型を表せます

53
00:04:41,648 --> 00:04:43,250
これを要素型と呼びます

54
00:04:44,117 --> 00:04:49,223
要素型は汎用パラメータで
故に パラメータ多相です

55
00:04:49,690 --> 00:04:54,728
バッファに型を教える
コンパイル時引数のようなものです

56
00:04:55,629 --> 00:05:00,767
これでバッファはAnyを使い
要素型に参照できます

57
00:04:55,629 --> 00:05:00,767
これでバッファはAnyを使い
要素型に参照できます

58
00:05:03,203 --> 00:05:07,074
しかも 型を取り出す際
変換不要で―

59
00:05:07,341 --> 00:05:13,947
誤った型を代入してしまっても
コンパイラが教えてくれます

60
00:05:15,115 --> 00:05:20,454
これで すべてのバッファ型に
要素型が付きました

61
00:05:20,821 --> 00:05:24,691
付いてない型の宣言は
コンパイルエラーになります

62
00:05:26,059 --> 00:05:32,799
要素型なしのバッファも
宣言できると思うかもしれません

63
00:05:33,133 --> 00:05:38,338
その場合はコンパイラが
型推測しているだけです

64
00:05:38,438 --> 00:05:41,108
ここでは右のリテラルからです

65
00:05:41,909 --> 00:05:44,912
要素は暗黙で存在しています

66
00:05:46,246 --> 00:05:51,251
バッファのような型が
対応する型の情報は

67
00:05:51,351 --> 00:05:55,255
コンパイルとランタイムに
伝えられます

68
00:05:56,456 --> 00:06:00,294
つまり 全要素を
オーバーヘッドなしで

69
00:05:56,456 --> 00:06:00,294
つまり 全要素を
オーバーヘッドなしで

70
00:06:00,394 --> 00:06:03,263
連続したメモリブロックに
保持できるのです

71
00:06:03,864 --> 00:06:06,934
型が任意に大きくてもです

72
00:06:08,168 --> 00:06:10,204
コンパイラは常に―

73
00:06:10,771 --> 00:06:15,742
バッファが対応する要素型を
直接知っています

74
00:06:15,843 --> 00:06:20,047
それで最適化の機会を持てるのです

75
00:06:20,480 --> 00:06:23,684
ここでは 整数バッファを
宣言していて―

76
00:06:24,284 --> 00:06:29,623
ループの高効率なCPU命令への
コンパイルが必要です

77
00:06:31,825 --> 00:06:33,660
このようなループを―

78
00:06:35,028 --> 00:06:41,268
定期的に書くならメソッドに
抽出するのもいいでしょう

79
00:06:41,368 --> 00:06:47,140
バッファの拡張でユニットテストや
読み込みも楽になります

80
00:06:48,242 --> 00:06:52,012
しかしコンパイルの問題が起きます

81
00:06:52,412 --> 00:06:56,550
すべての要素型が
要約されないからです

82
00:06:57,518 --> 00:07:03,190
要素に必要なケイパビリティを
コンパイラに伝えないと―

83
00:06:57,518 --> 00:07:03,190
要素に必要なケイパビリティを
コンパイラに伝えないと―

84
00:07:03,290 --> 00:07:06,326
このメソッドが使えません

85
00:07:07,361 --> 00:07:14,201
簡単な方法は 要素型を
Intのような型に制約することです

86
00:07:16,803 --> 00:07:21,975
そのように拡張すれば
あとで汎用化するのも簡単です

87
00:07:22,075 --> 00:07:26,079
DoubleやFloatのバッファが
必要になれば―

88
00:07:26,847 --> 00:07:29,550
制約した型を見てください

89
00:07:29,983 --> 00:07:32,519
プロトコル準拠を見て―

90
00:07:32,619 --> 00:07:37,024
最も汎用的なプロトコルを
探してください

91
00:07:37,558 --> 00:07:43,430
ここでは Numericプロトコルで
ゼロ値の要素を作成し

92
00:07:44,064 --> 00:07:51,038
それに要素を追加するという
２つの機能が果たせます

93
00:07:53,574 --> 00:07:58,478
では プロトコル抽出の
プロセスについて話します

94
00:08:00,214 --> 00:08:04,952
バッファ型の汎用化について
お話ししましたが

95
00:08:05,052 --> 00:08:08,922
他の汎用的な
コードを書く場合は？

96
00:08:09,122 --> 00:08:12,059
あらゆるコレクションで
使えるコードは？

97
00:08:13,060 --> 00:08:16,463
例えば バッファに似た配列型や

98
00:08:16,830 --> 00:08:21,935
対のキー値からなる
ディクショナリ型です

99
00:08:23,136 --> 00:08:30,043
また 汎用的でない
データ型や文字列型などもあります

100
00:08:31,812 --> 00:08:36,416
これらに共通のケイパビリティを
キャプチャする―

101
00:08:37,049 --> 00:08:42,489
コレクションプロトコルの
簡易版を作成しましょう

102
00:08:45,025 --> 00:08:50,130
まず これらの具体的な型を
見てきました

103
00:08:50,230 --> 00:08:54,268
今から これらを１つにする
プロトコルを考えます

104
00:08:54,701 --> 00:08:57,204
この考え方は重要です

105
00:08:57,304 --> 00:09:02,142
具体的な型を考えてから
プロトコルで統一します

106
00:08:57,304 --> 00:09:02,142
具体的な型を考えてから
プロトコルで統一します

107
00:09:03,243 --> 00:09:06,847
これらの型に共通することは？

108
00:09:07,681 --> 00:09:12,152
プロトコル設計は
いわば契約交渉です

109
00:09:13,253 --> 00:09:17,457
準拠型と
柔軟性を重視する型との間で

110
00:09:17,691 --> 00:09:21,728
自然と駆け引きが
生まれるからです

111
00:09:22,563 --> 00:09:24,398
プロトコルのユーザは

112
00:09:24,498 --> 00:09:29,670
拡張のために
シンプルなプロトコルを望みます

113
00:09:30,737 --> 00:09:35,676
ですから プロトコル設計で
重要なのは―

114
00:09:35,809 --> 00:09:40,013
あらゆる準拠型と
様々なユースケースです

115
00:09:40,180 --> 00:09:41,815
要はバランスです

116
00:09:44,218 --> 00:09:48,822
では コレクションプロトコルの
要素型からです

117
00:09:48,922 --> 00:09:52,025
これには関連型を使っています

118
00:09:52,860 --> 00:09:56,864
準拠型で必要な
正しい要素の設定は

119
00:09:57,297 --> 00:10:03,003
バッファや配列の場合
Swift 4.2では自動で行われます

120
00:09:57,297 --> 00:10:03,003
バッファや配列の場合
Swift 4.2では自動で行われます

121
00:10:03,170 --> 00:10:06,740
汎用パラメータも
要素としたからです

122
00:10:07,674 --> 00:10:14,615
汎用的な引数に 共通の規則に従う
意味ある命名をする利点です

123
00:10:15,649 --> 00:10:20,487
“T”などと適当に命名すると
別の提示が必要です

124
00:10:22,022 --> 00:10:24,758
他のデータ型には具体性が要り

125
00:10:24,858 --> 00:10:29,663
ディクショナリなら 要素型を
キーと値のペアにします

126
00:10:32,032 --> 00:10:35,002
次はサブスクリプトの
追加についてです

127
00:10:35,769 --> 00:10:39,173
もし配列型のような型の
プロトコルなら―

128
00:10:39,273 --> 00:10:43,544
サブスクリプトの引数に
Intを望むかもしれません

129
00:10:45,212 --> 00:10:50,017
しかし Intを取れば
強い関係が生じます

130
00:10:50,851 --> 00:10:57,791
準拠型は 整数の表すポジションを
フェッチしなければなりません

131
00:10:58,392 --> 00:11:01,094
配列型などにはうまくいき―

132
00:10:58,392 --> 00:11:01,094
配列型などにはうまくいき―

133
00:11:01,495 --> 00:11:05,499
プロトコルユーザにも
理解が簡単です

134
00:11:06,066 --> 00:11:09,903
でも やや複雑な
ディクショナリについては？

135
00:11:11,705 --> 00:11:18,479
ディクショナリは 大抵
次の要素を見るロジックを含む―

136
00:11:18,579 --> 00:11:22,216
複雑な内部データ構造を含みます

137
00:11:22,783 --> 00:11:26,520
例えば 何らかの内部バッファです

138
00:11:26,620 --> 00:11:31,792
オフセットを格納した
インデックス型を使用したり

139
00:11:31,892 --> 00:11:37,731
サブスクリプト引数を取り
要素をフェッチしたりするものです

140
00:11:38,398 --> 00:11:42,236
しかし ディクショナリの
インデックス型は―

141
00:11:42,336 --> 00:11:44,638
不透明型でないといけません

142
00:11:45,105 --> 00:11:50,878
オフセットに１を足すと
すぐ次の要素にではなく

143
00:11:50,978 --> 00:11:56,049
非初期化部分へ
移動してしまっては困ります

144
00:11:56,984 --> 00:11:59,419
インデックスどおりに―

145
00:12:00,020 --> 00:12:03,657
コントロールされるべきです

146
00:12:04,158 --> 00:12:06,326
それには メソッドを追加し

147
00:12:06,860 --> 00:12:11,198
次のポジションを示す
インデックスを与えます

148
00:12:12,366 --> 00:12:14,168
次のステップは―

149
00:12:14,268 --> 00:12:18,038
開始及び終了インデックスの
プロパティです

150
00:12:18,138 --> 00:12:22,276
カウントだけでは
終了が分からないからです

151
00:12:22,576 --> 00:12:25,212
Intは使わないので―

152
00:12:26,547 --> 00:12:28,849
コレクションプロトコルに
戻しましょう

153
00:12:30,083 --> 00:12:35,389
これは インデックス型をとる
サブスクリプトと―

154
00:12:35,489 --> 00:12:38,325
ポジションを進める方法です

155
00:12:38,959 --> 00:12:43,597
インデックス用の型を
提供する型も必要ですが

156
00:12:43,697 --> 00:12:46,266
別の関連型を使います

157
00:12:47,768 --> 00:12:49,837
準拠型は適切なので

158
00:12:49,937 --> 00:12:54,875
配列やデータは
インデックス型にIntを与えます

159
00:12:55,108 --> 00:13:00,147
一方 ディクショナリは
カスタム実装を与えます

160
00:12:55,108 --> 00:13:00,147
一方 ディクショナリは
カスタム実装を与えます

161
00:13:04,251 --> 00:13:09,356
では インデックスの汎用化のため
カウントに戻りましょう

162
00:13:09,456 --> 00:13:16,230
この便利なプロパティを
コレクションの拡張として戻します

163
00:13:16,630 --> 00:13:21,034
コレクションをまたいで
インデックスを進め―

164
00:13:21,134 --> 00:13:24,104
カウンタをインクリメントさせます

165
00:13:26,440 --> 00:13:29,776
でもこの実装に
足りない要件があります

166
00:13:30,577 --> 00:13:33,213
Intを移動させたので―

167
00:13:33,313 --> 00:13:36,950
インデックス型はもう
Equatableではありません

168
00:13:37,417 --> 00:13:44,324
しかし終了に達したことを知るには
Equatableが必要です

169
00:13:45,492 --> 00:13:49,129
これを解決するには
前と同じく―

170
00:13:49,229 --> 00:13:53,834
Equatableの時だけ適用するよう
拡張を制約します

171
00:13:54,635 --> 00:13:56,336
でもしっくりきません

172
00:13:57,538 --> 00:14:00,440
使いやすいプロトコルが欲しいのに

173
00:13:57,538 --> 00:14:00,440
使いやすいプロトコルが欲しいのに

174
00:14:00,541 --> 00:14:04,945
拡張を書く度に
制約を入れるのは面倒です

175
00:14:05,712 --> 00:14:09,716
インデックス比較が
常に必要になるからです

176
00:14:10,184 --> 00:14:14,555
プロトコル要件として表す方が
いいでしょう

177
00:14:16,023 --> 00:14:19,426
インデックス関連型の
制約としてです

178
00:14:20,294 --> 00:14:21,995
プロトコル制約を行い

179
00:14:22,095 --> 00:14:27,334
プロトコル準拠の型すべてに
Equatable型を提供させます

180
00:14:28,502 --> 00:14:32,406
これで拡張の度に
特定しなくて済みます

181
00:14:34,575 --> 00:14:37,778
これもプロトコルとの
取り決めの例です

182
00:14:38,712 --> 00:14:44,284
プロトコルユーザには
インデックス比較の必要があり

183
00:14:44,718 --> 00:14:49,957
準拠型は 柔軟性を多く失わず
対応できるかでした

184
00:14:50,991 --> 00:14:52,893
どちらもかないます

185
00:14:53,427 --> 00:14:56,497
Intやデータ 配列は
既にEquatableです

186
00:14:56,597 --> 00:15:00,501
Swift 4.2の新しい
Equatable準拠自動合成で―

187
00:14:56,597 --> 00:15:00,501
Swift 4.2の新しい
Equatable準拠自動合成で―

188
00:15:01,235 --> 00:15:04,271
インデックス型を
Equatableにできます

189
00:15:07,241 --> 00:15:12,646
次はカスタムポイントを含む
カウントの最適化です

190
00:15:14,381 --> 00:15:17,251
今書いたカウントのバージョンは

191
00:15:17,351 --> 00:15:22,189
全コレクションをまたいで
要素数を計算します

192
00:15:22,289 --> 00:15:26,126
しかし 多くのコレクションは
もっと速くできます

193
00:15:26,593 --> 00:15:32,866
例えば ディクショナリが
要素数のカウントを保持していれば

194
00:15:33,400 --> 00:15:37,838
自身のカウント実装に
使うことができます

195
00:15:38,572 --> 00:15:44,011
ディクショナリのカウントを
呼び出すと得られるのは

196
00:15:44,111 --> 00:15:48,549
元の線形時間ではなく
速い定数時間です

197
00:15:49,817 --> 00:15:53,921
ただ 最適化の追加に
留意点があります

198
00:15:54,021 --> 00:16:00,427
プロトコル要件の実行と
オーバーロード追加の違いです

199
00:15:54,021 --> 00:16:00,427
プロトコル要件の実行と
オーバーロード追加の違いです

200
00:16:01,028 --> 00:16:06,099
今のところ この新バージョンは
単にオーバーロードです

201
00:16:06,567 --> 00:16:12,873
つまり ディクショナリには
改良されたカウントがあります

202
00:16:13,440 --> 00:16:16,276
では 汎用アルゴリズム内の
呼び出しは？

203
00:16:18,512 --> 00:16:22,883
例えば 標準ライブラリの
マップを書くとします

204
00:16:23,016 --> 00:16:26,487
ご存じない場合
これはとても便利です

205
00:16:26,587 --> 00:16:31,892
要素を変形して
新しい配列に戻してくれるのです

206
00:16:33,160 --> 00:16:34,828
実装はシンプルです

207
00:16:34,928 --> 00:16:38,799
新しい配列を作成して
コレクションに動かし

208
00:16:38,932 --> 00:16:41,935
要素を変形して配列に加えます

209
00:16:42,970 --> 00:16:48,175
要素を配列に加える際
配列は自動的に大きくなります

210
00:16:48,542 --> 00:16:49,810
それに伴い―

211
00:16:49,910 --> 00:16:55,883
内部メモリの再割り当てが
必要になる場合もあります

212
00:16:56,450 --> 00:17:00,954
大きくなる度合いによっては
数回必要になり―

213
00:16:56,450 --> 00:17:00,954
大きくなる度合いによっては
数回必要になり―

214
00:17:01,421 --> 00:17:02,890
時間もかかります

215
00:17:02,990 --> 00:17:05,659
メモリの割り当ては負担ですが―

216
00:17:06,693 --> 00:17:10,130
ここで最適化のコツがあります

217
00:17:10,531 --> 00:17:14,334
最終的な配列の大きさは―

218
00:17:14,434 --> 00:17:17,804
元のコレクションと
まったく同じサイズです

219
00:17:18,605 --> 00:17:23,443
配列に加える前に
その分を取っておけば―

220
00:17:23,544 --> 00:17:27,181
スピードアップを図れます

221
00:17:27,513 --> 00:17:29,950
これには カウントを
呼び出します

222
00:17:30,951 --> 00:17:35,689
ここでは 汎用的な
コンテキストとしてです

223
00:17:35,789 --> 00:17:40,661
つまり コレクション型は
完全に汎用的なので―

224
00:17:40,761 --> 00:17:44,064
配列やディクショナリ
何でもあり得ます

225
00:17:44,631 --> 00:17:48,869
コードをコンパイルする際の
カウントが―

226
00:17:48,969 --> 00:17:52,372
より良いものかは分かりません

227
00:17:52,906 --> 00:17:59,112
この場合 呼び出されるのは
汎用バージョンで

228
00:17:59,213 --> 00:18:03,116
全コレクションに働き 反復します

229
00:17:59,213 --> 00:18:03,116
全コレクションに働き 反復します

230
00:18:03,584 --> 00:18:05,619
ディクショナリで
マップを呼び出しても

231
00:18:05,719 --> 00:18:08,989
良いバージョンではありません

232
00:18:11,058 --> 00:18:13,994
カスタマイズされた
メソッドやプロパティを

233
00:18:14,094 --> 00:18:18,398
汎用的なコンテキストで
呼び出すには―

234
00:18:18,565 --> 00:18:22,269
プロトコル要件として
宣言すればいいのです

235
00:18:23,470 --> 00:18:24,538
コレクションは―

236
00:18:24,638 --> 00:18:29,409
最適なカウントを
提供できるわけです

237
00:18:29,510 --> 00:18:33,447
プロトコル要件として
追加することも納得です

238
00:18:34,348 --> 00:18:38,385
ただ たとえそれを要件にしても

239
00:18:39,753 --> 00:18:42,756
各コレクションでは不要です

240
00:18:42,856 --> 00:18:47,127
拡張を通して
既に１つ提供したからです

241
00:18:48,629 --> 00:18:55,035
プロトコルに要件を加え
拡張を通しデフォルト実装すること

242
00:18:55,135 --> 00:18:58,372
これがカスタマイズポイントです

243
00:19:00,140 --> 00:19:05,412
メソッドやプロパティの
実装が良くなる可能性を

244
00:19:05,512 --> 00:19:07,214
コンパイラに知らせます

245
00:19:07,314 --> 00:19:09,650
それで汎用コンテキストで

246
00:19:09,750 --> 00:19:14,288
プロトコルを通して
動的に実装を行うのです

247
00:19:15,422 --> 00:19:18,192
今 ディクショナリで
マップを呼び出せば

248
00:19:18,292 --> 00:19:22,829
汎用的な機能でも
カウント実装が良くなります

249
00:19:24,498 --> 00:19:29,570
このようなカスタマイズポイントの
追加で―

250
00:19:30,270 --> 00:19:33,240
パワフルに恩恵が得られます

251
00:19:33,340 --> 00:19:37,945
クラスや実装継承
メソッドの上書きと同様です

252
00:19:38,278 --> 00:19:42,649
また 構造体や列挙型にも使えます

253
00:19:45,285 --> 00:19:48,655
ただ 最適化できない
メソッドもあります

254
00:19:49,122 --> 00:19:52,960
カスタマイズポイントは
バイナリサイズや―

255
00:19:53,060 --> 00:19:56,196
ランタイム動作に
少しは影響します

256
00:19:56,296 --> 00:19:59,032
ですから
カスタマイズポイントの追加は

257
00:19:59,132 --> 00:20:01,635
最適化が適する時に限ります

258
00:19:59,132 --> 00:20:01,635
最適化が適する時に限ります

259
00:20:02,503 --> 00:20:05,272
例えば 先程のマップ操作です

260
00:20:05,372 --> 00:20:11,778
あらゆるコレクションに
実装を良くできる方法がないので

261
00:20:11,945 --> 00:20:15,048
追加の意味はありません

262
00:20:15,149 --> 00:20:17,317
拡張のままで結構です

263
00:20:18,752 --> 00:20:23,357
さて 作成したコレクション型は
十分な機能を備え―

264
00:20:23,624 --> 00:20:28,095
多くの準拠型と
便利なアルゴリズムがあります

265
00:20:28,529 --> 00:20:33,901
しかし型の分類には
時に複数のプロトコルが必要です

266
00:20:34,535 --> 00:20:36,570
プロトコル継承です

267
00:20:36,904 --> 00:20:39,373
では ダグに代わります

268
00:20:40,340 --> 00:20:45,879
(拍手)

269
00:20:45,979 --> 00:20:47,114
ありがとう ベン

270
00:20:48,515 --> 00:20:51,685
プロトコル継承は
初期のSwiftからあります

271
00:20:52,252 --> 00:20:54,822
どこでプロトコル継承が必要か

272
00:20:54,922 --> 00:20:57,958
このコレクションプロトコルで
考えましょう

273
00:20:58,192 --> 00:21:02,863
良い設計のプロトコルで
一連の準拠型を記述し

274
00:20:58,192 --> 00:21:02,863
良い設計のプロトコルで
一連の準拠型を記述し

275
00:21:02,963 --> 00:21:06,567
興味深い汎用アルゴリズムが
書けます

276
00:21:06,667 --> 00:21:12,105
しかし コレクションプロトコル
として実装できない―

277
00:21:12,206 --> 00:21:14,908
アルゴリズムならあります

278
00:21:15,242 --> 00:21:20,614
例えば プレディケートに合致する
最後の要素を探すには

279
00:21:20,714 --> 00:21:24,785
後ろから前へ進むのが
最良の方法です

280
00:21:25,052 --> 00:21:26,987
コレクションプロトコルは
それを許しません

281
00:21:27,821 --> 00:21:32,693
また コレクション内の要素を
シャッフルしたくても

282
00:21:32,793 --> 00:21:35,562
変化が必要で
コレクションはそれをしません

283
00:21:35,662 --> 00:21:38,766
コレクションプロトコルが
悪いのでなく―

284
00:21:39,766 --> 00:21:44,471
汎用アルゴリズムの追加に
もっと何か必要なのです

285
00:21:44,571 --> 00:21:47,174
それがプロトコル継承です

286
00:21:47,274 --> 00:21:53,313
これは BidirectionalCollection
プロトコルです

287
00:21:53,614 --> 00:21:58,318
このプロトコルに
準拠する型はすべて

288
00:21:58,418 --> 00:22:01,755
コレクションにも準拠し
アルゴリズムを使えます

289
00:21:58,418 --> 00:22:01,755
コレクションにも準拠し
アルゴリズムを使えます

290
00:22:02,022 --> 00:22:08,195
しかしBidirectionalCollectionは
後退する要件を追加します

291
00:22:08,695 --> 00:22:13,801
ただ この要件を実装できる
コレクションは限られます

292
00:22:13,901 --> 00:22:20,007
例えばSinglyLinkedListは
次に飛ぶだけですよね

293
00:22:20,107 --> 00:22:22,776
後退は効率的ではないので

294
00:22:22,876 --> 00:22:25,679
BidirectionalCollectionは
あり得ません

295
00:22:25,779 --> 00:22:29,650
つまり継承の導入は
準拠型を制限します

296
00:22:30,117 --> 00:22:34,054
しかし より興味深い
アルゴリズムを実装できます

297
00:22:34,154 --> 00:22:39,092
最後のインデックス後の
コードはこうです

298
00:22:39,193 --> 00:22:44,965
BidirectionalCollectionの
新要件を使って後退させるだけです

299
00:22:46,500 --> 00:22:50,404
次は 更に興味深い
シャッフルアルゴリズムです

300
00:22:50,504 --> 00:22:55,008
Swift 4.2のコレクションに
導入されています

301
00:22:55,109 --> 00:22:59,079
このアルゴリズムを見て
導入された要件を確認し

302
00:22:59,179 --> 00:23:02,883
プロトコルを
意味のあるよう分類します

303
00:22:59,179 --> 00:23:02,883
プロトコルを
意味のあるよう分類します

304
00:23:03,317 --> 00:23:07,354
Fisher-Yatesは古くて
シンプルです

305
00:23:07,454 --> 00:23:11,024
最初の要素から
インデックスを開始し

306
00:23:11,492 --> 00:23:17,531
次に 別の要素をランダムに選び
この２つを入れ替えます

307
00:23:18,432 --> 00:23:22,970
次の反復で
左のインデックスを１つ進め

308
00:23:23,370 --> 00:23:26,740
また１つ選んで入れ替えます

309
00:23:26,840 --> 00:23:28,776
とてもシンプルです

310
00:23:28,876 --> 00:23:34,515
ランダムに選んだ別の要素を
入れ替えて進むだけです

311
00:23:34,615 --> 00:23:38,752
最終的に うまく
シャッフルされます

312
00:23:39,620 --> 00:23:43,457
コードは 少し複雑ですが
大丈夫です

313
00:23:43,557 --> 00:23:46,693
何かのコレクションに
実装してみましょう

314
00:23:46,793 --> 00:23:48,662
このコア演算が例です

315
00:23:48,762 --> 00:23:51,198
最初に コレクションの―

316
00:23:51,298 --> 00:23:56,270
今の位置から最後までで
ランダムな数を選びます

317
00:23:56,370 --> 00:24:00,340
でもこれは整数で
必要なのはインデックスです

318
00:23:56,370 --> 00:24:00,340
でもこれは整数で
必要なのはインデックスです

319
00:24:00,440 --> 00:24:04,311
そこでoffsetByインデックスを使い

320
00:24:04,411 --> 00:24:09,149
開始インデックスから
選んだ位置までジャンプします

321
00:24:09,983 --> 00:24:14,154
次に必要な操作は
２つの要素の入れ替えです

322
00:24:14,822 --> 00:24:20,494
シャッフル実装に必要な
２つの操作があるので―

323
00:24:20,594 --> 00:24:24,031
新しいShuffleCollection
プロトコルです

324
00:24:26,600 --> 00:24:27,868
でもやめてください

325
00:24:27,968 --> 00:24:30,237
アンチパターンです

326
00:24:30,571 --> 00:24:33,073
あるのはアルゴリズム１つです

327
00:24:33,173 --> 00:24:36,844
要件を見つけ
プロトコルに包括しましたが

328
00:24:36,944 --> 00:24:40,914
記述したのはアルゴリズム１つです

329
00:24:41,014 --> 00:24:44,885
これを行えば
プロトコルが山ほどでき

330
00:24:44,985 --> 00:24:48,789
そこには大した意味もなく
何も学べません

331
00:24:49,022 --> 00:24:54,228
ここで気付くべきは
明瞭なケイパビリティです

332
00:24:54,328 --> 00:24:57,765
ランダムアクセスと変化は―

333
00:24:57,865 --> 00:25:01,735
別々のプロトコルに分類できます

334
00:24:57,865 --> 00:25:01,735
別々のプロトコルに分類できます

335
00:25:01,935 --> 00:25:04,805
RandomAccessCollection
プロトコルは―

336
00:25:04,905 --> 00:25:10,077
素早くインデックスを動かし
ジャンプを可能にします

337
00:25:10,377 --> 00:25:14,147
またUnsafeBufferPointerは
ランダムアクセスを可能にしても

338
00:25:14,248 --> 00:25:16,583
変化はさせません

339
00:25:16,683 --> 00:25:18,418
それは別のケイパビリティです

340
00:25:18,919 --> 00:25:21,855
ここにMutableCollection
プロトコルもあります

341
00:25:22,289 --> 00:25:28,161
変化は可能ですが
ランダムアクセスは不可能な型です

342
00:25:28,495 --> 00:25:32,299
さて 継承階層が分割されますね

343
00:25:33,133 --> 00:25:36,403
RandomAccessなどのアクセス側と

344
00:25:36,503 --> 00:25:38,539
変化の側です

345
00:25:38,639 --> 00:25:45,279
クライアントは複数のプロトコルを
実装できるので問題ありません

346
00:25:45,579 --> 00:25:48,982
シャッフルアルゴリズムに戻ると
これは―

347
00:25:49,249 --> 00:25:52,586
自分型でRandomAccessCollectionの
拡張として書けます

348
00:25:52,686 --> 00:25:58,525
この型はRandomAccessCollectionと
MutableCollectionにも準拠します

349
00:25:58,625 --> 00:26:01,195
この両方のケイパビリティを
合わせました

350
00:25:58,625 --> 00:26:01,195
この両方のケイパビリティを
合わせました

351
00:26:02,396 --> 00:26:07,201
準拠型と汎用アルゴリズムが
複数ずつある場合―

352
00:26:07,301 --> 00:26:10,537
プロトコル階層を成形しがちです

353
00:26:10,637 --> 00:26:15,309
これらの階層は大きすぎず
細かすぎないことです

354
00:26:15,876 --> 00:26:21,782
要るのはドメイン内の型を記述する
少数のプロトコルです

355
00:26:22,616 --> 00:26:26,420
プロトコル階層のビルドでは―

356
00:26:26,520 --> 00:26:32,125
上に行くにつれプロトコルの要件が
少なくなります

357
00:26:32,226 --> 00:26:36,930
それで 要件を実装できる
準拠型が増えます

358
00:26:37,464 --> 00:26:43,403
一方で 階層を下りながら
様々なプロトコルを結合すると

359
00:26:43,537 --> 00:26:46,607
より複雑なアルゴリズムが
実装できます

360
00:26:46,707 --> 00:26:51,178
高いケイパビリティが要り
対応する準拠型は減りますがね

361
00:26:55,549 --> 00:27:00,020
では Swiftの新機能
条件付き準拠に進みます

362
00:26:55,549 --> 00:27:00,020
では Swiftの新機能
条件付き準拠に進みます

363
00:27:00,554 --> 00:27:03,290
Sliceから始めます

364
00:27:03,423 --> 00:27:07,995
一連のインデックスに
サブスクリプトを定義すれば

365
00:27:08,095 --> 00:27:13,133
コレクションに
Sliceを形成できます

366
00:27:13,233 --> 00:27:17,171
Sliceは本質的に
コレクションの部分表示です

367
00:27:17,905 --> 00:27:22,042
これらはコレクションを
スライスしたデフォルト型で

368
00:27:22,142 --> 00:27:24,077
Sliceと呼ばれます

369
00:27:24,411 --> 00:27:26,713
Sliceは
ジェネリックアダプタ型です

370
00:27:27,281 --> 00:27:31,118
基本コレクション型で
パラメータ化でき―

371
00:27:31,485 --> 00:27:33,587
それ自体がコレクションです

372
00:27:33,887 --> 00:27:39,993
土台のコレクションにできることが
Sliceにもできると―

373
00:27:40,094 --> 00:27:41,628
予想しますよね

374
00:27:41,895 --> 00:27:48,335
“(where:”などで順方向検索し
プレディケートやコレクションに

375
00:27:48,435 --> 00:27:51,038
対応するものを見つけます

376
00:27:51,472 --> 00:27:55,709
しかし 逆方向検索では
問題に遭遇します

377
00:27:55,809 --> 00:27:58,846
バッファが
BidirectionalCollectionでも

378
00:27:59,379 --> 00:28:02,416
Sliceもそうだとは限りません

379
00:27:59,379 --> 00:28:02,416
Sliceもそうだとは限りません

380
00:28:04,651 --> 00:28:05,752
問題ありません

381
00:28:05,853 --> 00:28:09,957
Sliceを拡張し
それに準拠させましょう

382
00:28:10,457 --> 00:28:16,530
演算の前に 土台となる
基本コレクションに実装できますが

383
00:28:17,097 --> 00:28:19,066
コンパイラが承知しません

384
00:28:19,633 --> 00:28:23,537
基本コレクションは
コレクションというだけで

385
00:28:23,637 --> 00:28:26,640
演算の前のインデックスは
ありません

386
00:28:27,775 --> 00:28:29,309
修正できます

387
00:28:29,409 --> 00:28:31,645
要件を拡張に導入し

388
00:28:31,745 --> 00:28:35,382
BidirectionalCollectionが
基本型でなければと伝えます

389
00:28:35,749 --> 00:28:37,451
これが 条件付き準拠です

390
00:28:38,051 --> 00:28:42,589
プロトコルへの準拠を
宣言する拡張と―

391
00:28:42,689 --> 00:28:46,393
その準拠が妥当である制約です

392
00:28:47,027 --> 00:28:51,665
条件付き準拠はプロトコル階層に
うまく重ねられます

393
00:28:51,765 --> 00:28:55,903
土台の基本型が
RandomAccessCollectionなら

394
00:28:56,003 --> 00:28:59,640
SliceもRandomAccessCollectionと
表現できるのです

395
00:29:00,407 --> 00:29:03,177
今書いた２つの拡張は―

396
00:29:03,710 --> 00:29:05,879
良いSwiftのスタイルです

397
00:29:05,979 --> 00:29:11,251
拡張してプロトコル準拠させれば
その意味が分かります

398
00:29:11,351 --> 00:29:16,123
これは条件付き準拠にとって
特に重要です

399
00:29:16,223 --> 00:29:19,960
拡張に様々な要件があるからです

400
00:29:21,261 --> 00:29:22,729
構成の幅も広がり

401
00:29:22,830 --> 00:29:27,668
Slice型は土台の基本コレクション
と同じことができます

402
00:29:30,470 --> 00:29:35,342
次は 条件付き準拠の
別のアプリケーションについて

403
00:29:35,442 --> 00:29:37,478
RangeはSwiftの常連で

404
00:29:37,578 --> 00:29:41,181
例えば“..<”演算で
範囲を形成します

405
00:29:41,348 --> 00:29:45,752
ダブルや整数の範囲も
形成できます

406
00:29:45,853 --> 00:29:48,222
もっとパワフルなRangeは

407
00:29:48,322 --> 00:29:52,593
整数の範囲内の
要素に反復できます

408
00:29:52,960 --> 00:29:57,130
intRangeはコレクションに
準拠するからです

409
00:29:58,198 --> 00:30:02,135
“..<”演算子で作られた型は

410
00:29:58,198 --> 00:30:02,135
“..<”演算子で作られた型は

411
00:30:02,236 --> 00:30:05,005
Range型と命名されています

412
00:30:05,239 --> 00:30:07,941
土台のバウンド型に汎用的で

413
00:30:08,041 --> 00:30:12,513
ダブルのRangeに
上限と下限だけ格納しています

414
00:30:12,613 --> 00:30:13,847
シンプルです

415
00:30:14,214 --> 00:30:16,150
Swift 4.2より前は―

416
00:30:16,583 --> 00:30:20,254
IntegerRangeという
違う型から得ていました

417
00:30:20,354 --> 00:30:22,523
CountableRange型です

418
00:30:23,056 --> 00:30:25,959
構造的にはRange型と同じで

419
00:30:26,059 --> 00:30:29,096
型パラメータ１つと
上限下限のバウンドがあります

420
00:30:29,296 --> 00:30:33,066
しかしこれは バウンド型に
要件を追加します

421
00:30:33,167 --> 00:30:37,671
バウンドがStrideableで
全要素を列挙する要件です

422
00:30:37,771 --> 00:30:42,810
RandomAccessCollectionに
CountableRangeを準拠させ―

423
00:30:43,744 --> 00:30:47,114
反復ループを可能にさせるのです

424
00:30:47,981 --> 00:30:51,084
条件付き準拠なら
もっとうまくいきます

425
00:30:51,418 --> 00:30:56,457
では 基本的なRange型を
コレクションに変えます

426
00:30:56,823 --> 00:31:01,195
バウンド型には
Strideableの要件があります

427
00:30:56,823 --> 00:31:01,195
バウンド型には
Strideableの要件があります

428
00:31:01,662 --> 00:31:03,964
シンプルな準拠の適用ですが

429
00:31:04,064 --> 00:31:09,603
良い型パラメータと合わせると
パワフルになります

430
00:31:10,737 --> 00:31:15,209
今 RandomAccessCollectionに
準拠しようとしていますが

431
00:31:15,375 --> 00:31:19,646
BidirectionalCollectionにも
コレクションにも触れていません

432
00:31:20,247 --> 00:31:22,616
無条件準拠ならこれでOKです

433
00:31:22,950 --> 00:31:25,619
RandomAccessCollectionへの
準拠の宣言は―

434
00:31:25,719 --> 00:31:29,423
それが継承する
全プロトコルへの準拠を暗示します

435
00:31:29,523 --> 00:31:32,292
この場合 コレクションと
BidirectionalCollectionです

436
00:31:32,659 --> 00:31:35,929
でも条件付き準拠ならエラーです

437
00:31:36,530 --> 00:31:38,499
Sliceの例を思い出せば

438
00:31:38,599 --> 00:31:44,605
様々な階層に対して
異なる制約が必要でした

439
00:31:44,705 --> 00:31:47,508
各コレクションに対してです

440
00:31:47,674 --> 00:31:49,643
それでコンパイラは―

441
00:31:49,743 --> 00:31:55,115
条件付き準拠に合う制約を
強制しているのです

442
00:31:55,816 --> 00:31:59,453
今回は 全階層にわたり
同じ制約です

443
00:31:59,553 --> 00:32:03,090
明示的に コレクションと
BidirectionalCollectionと書け

444
00:31:59,553 --> 00:32:03,090
明示的に コレクションと
BidirectionalCollectionと書け

445
00:32:03,290 --> 00:32:06,326
ここに全準拠があると
アサートできます

446
00:32:06,427 --> 00:32:10,898
または文体を考慮し
異なる準拠を分けられます

447
00:32:12,399 --> 00:32:17,137
今 Range型はパワフルで
CountableRangeと同等です

448
00:32:17,237 --> 00:32:20,374
CountableRangeは
消せますが―

449
00:32:20,607 --> 00:32:25,846
実際 CountableRangeを
使うコードは多いです

450
00:32:25,946 --> 00:32:29,850
汎用的型エイリアスとして
残しましょう

451
00:32:30,918 --> 00:32:32,319
良い解決です

452
00:32:32,419 --> 00:32:37,858
これで 要件を加え
Rangeを可算可能にできます

453
00:32:37,958 --> 00:32:41,828
コレクションへの変更に
必要な要件ですが

454
00:32:41,929 --> 00:32:45,099
単に土台のRange型の別名です

455
00:32:46,733 --> 00:32:50,904
繰り返しますが
ソース互換性に良い解決です

456
00:32:51,004 --> 00:32:55,475
RandomAccessCollectionとして
追加機能を持つRangeに

457
00:32:55,576 --> 00:32:59,546
命名することも 良いことです

458
00:32:59,813 --> 00:33:02,883
実際 他コードの
クリーンアップに使えます

459
00:32:59,813 --> 00:33:02,883
実際 他コードの
クリーンアップに使えます

460
00:33:02,983 --> 00:33:04,685
CountableRangeは

461
00:33:04,785 --> 00:33:10,691
Stride機能を持つ
Rangeなので拡張できます

462
00:33:10,791 --> 00:33:15,262
RandomAccessCollectionに
準拠の場合です

463
00:33:16,363 --> 00:33:20,968
Swift 4.2に導入したのは
扱う型をシンプルにし―

464
00:33:21,068 --> 00:33:25,672
既存のコア型の構成可能性と
柔軟性を高めるためです

465
00:33:29,409 --> 00:33:30,677
最後のトピックです

466
00:33:31,378 --> 00:33:34,681
Swiftはマルチパラダイム言語で

467
00:33:34,781 --> 00:33:39,419
オブジェクト指向プログラミングも
サポートしています

468
00:33:40,087 --> 00:33:42,823
そこで ２つの機能が―

469
00:33:42,923 --> 00:33:47,361
Swift言語でどう対話するかを
お話しします

470
00:33:47,661 --> 00:33:51,432
まず クラス継承の働きは
ご存じですね

471
00:33:51,532 --> 00:33:52,633
シンプルです

472
00:33:52,733 --> 00:33:54,768
スーパークラスのVehicleや

473
00:33:54,868 --> 00:33:59,606
継承したサブクラスの
TaxiやPoliceCarが宣言できます

474
00:33:59,940 --> 00:34:03,177
オブジェクト指向階層ができたら

475
00:33:59,940 --> 00:34:03,177
オブジェクト指向階層ができたら

476
00:34:03,277 --> 00:34:07,214
サブクラスが
どこで使えるか考えます

477
00:34:07,314 --> 00:34:11,752
Vehicleを動かす
メソッドを使えば

478
00:34:11,851 --> 00:34:16,889
サブクラスのTaxiでも
呼び出せると考えます

479
00:34:17,858 --> 00:34:21,995
オブジェクト指向プログラミングの
基本です

480
00:34:22,094 --> 00:34:26,800
バーバラ･リスコフが
80年代に述べて以来―

481
00:34:27,167 --> 00:34:30,771
“リスコフの置換原則”と
呼ばれています

482
00:34:30,871 --> 00:34:33,005
シンプルな考え方です

483
00:34:33,239 --> 00:34:37,043
プログラム内でスーパー型
つまり―

484
00:34:37,143 --> 00:34:41,614
Vehicleのようなスーパークラスを
参照するとします

485
00:34:42,315 --> 00:34:46,687
するとTaxiやPoliceCarのような
サブ型 つまり―

486
00:34:47,221 --> 00:34:51,158
サブクラスのインスタンスが
取れるはずです

487
00:34:51,257 --> 00:34:54,761
型チェックと動作は
正常に継続します

488
00:34:55,062 --> 00:35:00,968
ここでの置換は サブクラスと
スーパークラス間です

489
00:34:55,062 --> 00:35:00,968
ここでの置換は サブクラスと
スーパークラス間です

490
00:35:01,769 --> 00:35:06,807
シンプルな原理で
取り込み済みですがパワフルです

491
00:35:06,907 --> 00:35:08,275
考えてみてください

492
00:35:08,375 --> 00:35:14,381
考えもしなかった違うサブクラスを
得たらどうなるかをね

493
00:35:15,416 --> 00:35:18,452
では ジェネリクスに戻ります

494
00:35:19,319 --> 00:35:25,225
置換原則を汎用システムに
適用すると 何ができますか？

495
00:35:25,325 --> 00:35:31,765
例えばDrivableプロトコルを追加し
Vehicleを拡張できます

496
00:35:31,865 --> 00:35:34,368
ここで期待するのは―

497
00:35:34,468 --> 00:35:40,407
そのプロトコル準拠を
サブクラスにも使用できることです

498
00:35:40,941 --> 00:35:46,647
汎用アルゴリズムをDrivableに
追加し sundayDriveに行くなら

499
00:35:46,747 --> 00:35:51,185
そのAPIをPoliceCarでも
使えるはずです

500
00:35:51,285 --> 00:35:53,520
良い考えかはともかくね

501
00:35:54,688 --> 00:36:00,527
ここで プロトコル準拠は
サブクラスにも継承され―

502
00:35:54,688 --> 00:36:00,527
ここで プロトコル準拠は
サブクラスにも継承され―

503
00:36:01,228 --> 00:36:03,063
制約が課されます

504
00:36:03,163 --> 00:36:07,534
VehicleをDrivableにする準拠を
１つ書けば―

505
00:36:07,634 --> 00:36:13,607
あとから足すものも含め
Vehicleの全サブクラスに働きます

506
00:36:14,208 --> 00:36:17,010
大抵の場合 うまくいきます

507
00:36:17,644 --> 00:36:22,816
しかし サブクラスに
要件を加える場合もあります

508
00:36:23,083 --> 00:36:27,654
よくあるのは イニシャライザの
要件を扱う場合です

509
00:36:28,555 --> 00:36:34,628
例えば Decodableプロトコルの
要件はイニシャライザで―

510
00:36:34,728 --> 00:36:39,399
デコーダから 準拠型の
インスタンスを作成します

511
00:36:40,701 --> 00:36:44,938
使うには このプロトコルに
便宜メソッドを加えます

512
00:36:45,038 --> 00:36:51,511
これは静的メソッドdecodeで
新しいインスタンスを作成します

513
00:36:52,346 --> 00:36:57,184
このメソッドの興味深い点は２つ
第１に―

514
00:36:57,284 --> 00:36:59,720
大文字SのSelfを返すこと

515
00:36:59,820 --> 00:37:05,325
準拠型で 静的メソッドを
呼び出すのと同じ型です

516
00:36:59,820 --> 00:37:05,325
準拠型で 静的メソッドを
呼び出すのと同じ型です

517
00:37:06,560 --> 00:37:10,063
第２に どのように実装するかです

518
00:37:10,164 --> 00:37:12,866
上のイニシャライザを呼び

519
00:37:12,966 --> 00:37:19,673
適当なDecodable型の 真っ新の
インスタンスを作成して返します

520
00:37:21,175 --> 00:37:22,142
いいでしょう

521
00:37:22,476 --> 00:37:25,245
これでVehicle型を
Decodableにできます

522
00:37:25,913 --> 00:37:29,650
そして置換原則を
適用する際の期待は―

523
00:37:29,750 --> 00:37:36,056
Vehicleのサブクラスでも
新規APIが使用できることです

524
00:37:36,156 --> 00:37:39,593
つまり Taxiで
ｄecodeを呼び出すと

525
00:37:39,827 --> 00:37:45,899
VehicleのでなくTaxiの
インスタンスが返されるのです

526
00:37:47,134 --> 00:37:48,735
その仕組みは？

527
00:37:49,503 --> 00:37:54,174
TaxiのHourlyRateを
見てみましょう

528
00:37:54,274 --> 00:37:56,977
“Taxi.decode(from:”を
呼び出すと

529
00:37:57,511 --> 00:38:01,415
イニシャライザの要件を
確認します

530
00:37:57,511 --> 00:38:01,415
イニシャライザの要件を
確認します

531
00:38:01,515 --> 00:38:04,117
実際に呼び出せるのは

532
00:38:04,218 --> 00:38:10,157
Vehicleクラス内で宣言された
イニシャライザだけです

533
00:38:10,257 --> 00:38:11,759
スーパークラスです

534
00:38:12,893 --> 00:38:17,431
Vehicleのデコード法は
知っていますが

535
00:38:17,531 --> 00:38:20,167
Taxiサブクラスについては無知です

536
00:38:20,734 --> 00:38:27,041
このイニシャライザを直接使うと
HourlyRateは初期化されず―

537
00:38:27,141 --> 00:38:31,145
請求書を受け取る際に
誤解が生じ得ます

538
00:38:32,713 --> 00:38:33,881
対処方法は？

539
00:38:34,014 --> 00:38:37,317
Swiftならこの問題は起こりません

540
00:38:37,751 --> 00:38:43,090
Decodableプロトコルに
準拠させる時点で診断し

541
00:38:43,190 --> 00:38:47,761
Requiredとマークするからです

542
00:38:49,296 --> 00:38:53,767
このイニシャライザは
全サブクラスで実装されます

543
00:38:53,867 --> 00:38:56,703
直下のサブクラスに限らず―

544
00:38:56,803 --> 00:39:01,275
それらのサブクラスや
将来のサブクラスもです

545
00:38:56,803 --> 00:39:01,275
それらのサブクラスや
将来のサブクラスもです

546
00:39:02,209 --> 00:39:07,414
この要件の追加により
TaxiにVehicleを継承した際―

547
00:39:07,514 --> 00:39:12,552
同じ名前のイニシャライザの導入も
必要です

548
00:39:12,953 --> 00:39:16,623
このイニシャライザは
HourlyRateをデコードし―

549
00:39:16,723 --> 00:39:23,063
スーパークラスにつなげ
Vehicle型もデコードします

550
00:39:26,667 --> 00:39:32,773
ところで スライドの
“non-final”に気付きましたか？

551
00:39:33,173 --> 00:39:37,244
定義では ファイナルクラスは
サブクラスを持たず―

552
00:39:37,344 --> 00:39:40,647
あとで置換されることはありません

553
00:39:42,516 --> 00:39:47,321
Requiredイニシャライザも
不要です

554
00:39:47,421 --> 00:39:53,760
Decodableなどの要件の扱いも
少し楽になります

555
00:39:53,861 --> 00:39:57,431
Requiredイニシャライザが
不要ですからね

556
00:39:58,332 --> 00:40:01,568
参照の意味でクラスを使う場合―

557
00:39:58,332 --> 00:40:01,568
参照の意味でクラスを使う場合―

558
00:40:02,402 --> 00:40:08,542
クラスのカスタマイズが不要なら
ファイナルを使いましょう

559
00:40:08,642 --> 00:40:13,847
後ほど 拡張して
カスタマイズは可能です

560
00:40:13,947 --> 00:40:20,454
構造体や列挙型と同じく拡張でき
準拠も追加できます

561
00:40:21,355 --> 00:40:24,024
ただ 汎用システムとの
対話を簡略化し

562
00:40:24,124 --> 00:40:27,594
コンパイラもランタイムで
最適化しやすくなります

563
00:40:30,698 --> 00:40:34,535
Swiftのジェネリクスの
背景にある考えは―

564
00:40:34,635 --> 00:40:39,439
静的な型情報を保持しつつ
コード再利用することです

565
00:40:39,540 --> 00:40:45,712
それで正しいプログラムが書け
実行も効率良くなります

566
00:40:46,080 --> 00:40:49,783
プロトコル設計は駆け引きです

567
00:40:49,883 --> 00:40:54,221
汎用アルゴリズムと
準拠型のバランスで

568
00:40:54,321 --> 00:40:59,193
意味のある抽象化を
行っていきましょう

569
00:40:59,993 --> 00:41:06,467
新しい汎用アルゴリズムの実装に
特別なケイパビリティが必要なら

570
00:40:59,993 --> 00:41:06,467
新しい汎用アルゴリズムの実装に
特別なケイパビリティが必要なら

571
00:41:06,567 --> 00:41:10,470
プロトコル継承を導入してください

572
00:41:11,071 --> 00:41:14,908
汎用型を書く際は
条件付き準拠の導入です

573
00:41:15,008 --> 00:41:20,314
プロトコル階層と動く場合に
特にうまく構成できます

574
00:41:20,781 --> 00:41:26,887
クラス継承と汎用システム間の
複雑な対話を考える際は―

575
00:41:26,987 --> 00:41:31,225
リスコフの置換原則に戻って
考えてください

576
00:41:31,325 --> 00:41:37,131
スーパークラスでなくサブクラスを
導入したらどうなるかと

577
00:41:40,367 --> 00:41:41,101
以上です

578
00:41:41,201 --> 00:41:46,240
アルゴリズムを活用して
コード構築に役立てたり

579
00:41:46,340 --> 00:41:50,911
Swiftのコレクションを
有効に使うセッションもあります

580
00:41:51,378 --> 00:41:52,079
ありがとう

581
00:41:52,212 --> 00:41:54,615
(拍手)