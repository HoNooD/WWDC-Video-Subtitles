
1
00:00:07,107 --> 00:00:16,483
(音楽)

2
00:00:20,721 --> 00:00:28,595
(拍手)

3
00:00:29,429 --> 00:00:31,665
おはようございます

4
00:00:31,932 --> 00:00:38,138
私はGPUソフトウェア
パフォーマンスチームのギエムです

5
00:00:38,839 --> 00:00:43,143
我々の使命は iOSで
ゲームデベロッパを―

6
00:00:43,243 --> 00:00:46,013
手助けすることです

7
00:00:46,380 --> 00:00:51,952
そこで 人気のゲームを調べ
共通する問題を探しました

8
00:00:52,386 --> 00:00:58,525
その膨大なデータの
解析結果をご説明しましょう

9
00:00:59,860 --> 00:01:03,997
本日のテーマは
“すごいゲームの開発”

10
00:00:59,860 --> 00:01:03,997
本日のテーマは
“すごいゲームの開発”

11
00:01:04,998 --> 00:01:09,703
ただし 技術的に
すごいという意味合いです

12
00:01:10,070 --> 00:01:15,242
始める前にCroteam社に
感謝したいと思います

13
00:01:15,342 --> 00:01:19,746
彼らが開発したゲーム
The Talos Principleを使い

14
00:01:19,847 --> 00:01:23,317
スライドやデモを
お見せします

15
00:01:23,417 --> 00:01:27,154
このゲームは
映像が美しいだけでなく

16
00:01:27,254 --> 00:01:31,491
パフォーマンスも
犠牲にしていません

17
00:01:32,159 --> 00:01:34,394
では本日の議題です

18
00:01:35,195 --> 00:01:38,665
まずツールから紹介します

19
00:01:38,866 --> 00:01:44,071
そのあとパフォーマンスの
問題を取り上げます

20
00:01:44,371 --> 00:01:50,410
フレームペーシングや
スレッド優先度など４点です

21
00:01:51,111 --> 00:01:56,450
これらは組み合わさって
悪影響が出るため

22
00:01:56,550 --> 00:01:58,485
まとめて対処しましょう

23
00:01:59,820 --> 00:02:01,421
ではツールから

24
00:01:59,820 --> 00:02:01,421
ではツールから

25
00:02:04,625 --> 00:02:09,696
大切なのは 早い段階で
頻繁にプロファイリングすること

26
00:02:10,597 --> 00:02:13,867
プロファイリングは欠かせません

27
00:02:13,967 --> 00:02:16,870
まずはツールの理解が重要です

28
00:02:17,504 --> 00:02:20,340
今日は２つのツールを
ご紹介します

29
00:02:21,008 --> 00:02:23,010
１つ目はInstruments

30
00:02:23,110 --> 00:02:25,078
メインのプロファイリングツールで

31
00:02:25,312 --> 00:02:30,684
パフォーマンスやレイテンシ
総合的なタイミングを確認できます

32
00:02:31,151 --> 00:02:33,921
２つ目は
Metalフレームデバッガ

33
00:02:34,021 --> 00:02:39,326
GPUの負荷をデバッグするための
非常に強力なツールです

34
00:02:40,661 --> 00:02:44,698
では どこから
始めればよいのでしょうか

35
00:02:45,132 --> 00:02:48,035
今回 我々は皆さんのために

36
00:02:48,135 --> 00:02:52,873
新しいInstrumentsテンプレートを
ご紹介します

37
00:02:53,040 --> 00:02:54,675
Game Performance
テンプレートです

38
00:02:55,275 --> 00:03:00,013
これはSystem Traceや
Time Profilerなどを

39
00:02:55,275 --> 00:03:00,013
これはSystem Traceや
Time Profilerなどを

40
00:03:00,581 --> 00:03:03,717
組み合わせたものです

41
00:03:03,951 --> 00:03:09,556
設定済みなので
CPUやGPUのデータを―

42
00:03:09,656 --> 00:03:10,924
記録できます

43
00:03:12,326 --> 00:03:15,295
では起動する方法です

44
00:03:15,762 --> 00:03:19,032
Instrumentsの中央を見ます

45
00:03:19,967 --> 00:03:23,937
他のテンプレートと同様に
設定が可能です

46
00:03:24,805 --> 00:03:30,844
Windowed Modeで実行すれば
好きなだけゲームをプレイでき

47
00:03:30,944 --> 00:03:33,881
最後の数秒だけ記録されます

48
00:03:34,114 --> 00:03:37,651
これが そのデータの例です

49
00:03:38,785 --> 00:03:42,823
簡単に全体を見ていきましょう

50
00:03:45,158 --> 00:03:47,928
System Traceと
Time Profilerは

51
00:03:48,028 --> 00:03:52,633
システムの負荷や
CPUの使用量を表示します

52
00:03:53,333 --> 00:03:58,972
例えば User Interactive Loadは
アクティブスレッドを全て記録

53
00:03:59,306 --> 00:04:02,543
この場合 オレンジ色の部分は

54
00:03:59,306 --> 00:04:02,543
この場合 オレンジ色の部分は

55
00:04:02,643 --> 00:04:08,348
動作可能なスレッドが
他にも存在することを示しています

56
00:04:08,982 --> 00:04:11,685
とても見やすいですね

57
00:04:12,719 --> 00:04:18,425
Instrumentsについて
さらに詳しくは別途ご確認ください

58
00:04:20,394 --> 00:04:24,798
次はMetal System Traceです

59
00:04:24,932 --> 00:04:27,734
Metalフレームワークから
ディスプレイまでの

60
00:04:28,135 --> 00:04:31,605
グラフィックスタックを
確認できます

61
00:04:32,573 --> 00:04:37,244
特にGPUの使用時間を
確認する場合は

62
00:04:37,344 --> 00:04:41,915
VertexやFragmentなどに
分かれます

63
00:04:42,749 --> 00:04:47,221
ディスプレイトラックも
最初に調べるべきです

64
00:04:47,554 --> 00:04:52,059
長いフレームや
スタッタリングを見つけ

65
00:04:52,159 --> 00:04:53,861
そこから始めましょう

66
00:04:56,563 --> 00:05:02,503
これは強力なツールで
多くの情報がありますから―

67
00:04:56,563 --> 00:05:02,503
これは強力なツールで
多くの情報がありますから―

68
00:05:03,303 --> 00:05:06,707
他にもセッションが
用意されています

69
00:05:08,141 --> 00:05:13,514
今年 新たにご紹介する
Thread Statesビューには

70
00:05:14,248 --> 00:05:21,121
ゲーム内の全スレッドの状態が
色別に示されています

71
00:05:21,321 --> 00:05:24,358
オレンジ色はスレッドの
プリエンプション

72
00:05:24,458 --> 00:05:26,660
赤色はブロックです

73
00:05:27,528 --> 00:05:31,598
我々が このビューを作ったのは

74
00:05:31,732 --> 00:05:36,203
現在のスレッドシステムが
複雑だからです

75
00:05:36,303 --> 00:05:38,572
ぜひ ご利用ください

76
00:05:40,240 --> 00:05:43,810
CPUコアごとの
トラックもあります

77
00:05:44,244 --> 00:05:46,547
コアで処理中のスレッドや

78
00:05:46,647 --> 00:05:50,551
スレッドの優先度が
カラーで表示されます

79
00:05:51,518 --> 00:05:55,923
これでシステムの状態が
よく分かりますね

80
00:05:56,924 --> 00:06:02,196
ツールの概要を
簡単に ご説明しました

81
00:05:56,924 --> 00:06:02,196
ツールの概要を
簡単に ご説明しました

82
00:06:02,296 --> 00:06:05,666
次はパフォーマンスの
問題についてです

83
00:06:06,033 --> 00:06:09,069
最初はフレームペーシング

84
00:06:10,170 --> 00:06:12,339
まずは映像をご覧ください

85
00:06:12,706 --> 00:06:18,846
これはSceneKitを使った
Fox 2のデモです

86
00:06:20,614 --> 00:06:24,418
レンダリングが速いのは
どちらでしょう？

87
00:06:27,287 --> 00:06:30,991
分からない人も
いるかもしれませんね

88
00:06:31,458 --> 00:06:35,762
左側は毎秒60フレームを
目指しましたが

89
00:06:35,963 --> 00:06:38,131
実際は毎秒40フレームです

90
00:06:38,232 --> 00:06:40,801
動きがカクついていますね

91
00:06:40,901 --> 00:06:45,239
一方 右側は毎秒30フレームです

92
00:06:45,339 --> 00:06:49,476
動きに一貫性があり
スムーズですね

93
00:06:50,878 --> 00:06:54,047
これは感覚の問題では
ありません

94
00:06:54,147 --> 00:06:59,653
レンダリングの速度が速く
映像がスムーズでないのは

95
00:07:00,387 --> 00:07:05,192
マイクロスタッタリングと
呼ばれる現象です

96
00:07:06,059 --> 00:07:10,931
ディスプレイのリフレッシュ間隔と
フレーム時間の差で発生します

97
00:07:11,298 --> 00:07:17,871
例えばゲームのレンダリングに
毎秒40フレームかかり

98
00:07:17,971 --> 00:07:23,477
ディスプレイが毎秒60フレームで
リフレッシュされるとします

99
00:07:23,577 --> 00:07:28,148
この場合 見た目の一貫性が
失われてしまいます

100
00:07:29,650 --> 00:07:35,355
これを解決するには
何をすればよいでしょう？

101
00:07:35,756 --> 00:07:40,828
実際には ほとんど
行うことはありません

102
00:07:41,728 --> 00:07:46,099
レンダリングのあと
ディスプレイリンクから

103
00:07:46,200 --> 00:07:51,305
次のdrawableを受け取り
すぐに表示します

104
00:07:51,405 --> 00:07:53,907
そして次のリフレッシュまで―

105
00:07:54,007 --> 00:07:58,345
drawableを表示して
おくよう命令します

106
00:07:58,445 --> 00:08:01,782
目標は毎秒60フレームです

107
00:07:58,445 --> 00:08:01,782
目標は毎秒60フレームです

108
00:08:03,350 --> 00:08:07,554
マイクロスタッタリングの
原因は他にもあります

109
00:08:08,689 --> 00:08:11,925
フレームレートを
低くはしていても

110
00:08:12,359 --> 00:08:18,799
usleepを使っているゲームが
数多くありました

111
00:08:19,333 --> 00:08:23,637
これはiOSでは
非常によくない習慣なので

112
00:08:23,804 --> 00:08:28,575
後ほど修正する方法を
お話ししましょう

113
00:08:29,376 --> 00:08:34,414
マイクロスタッタリングが
発生する時―

114
00:08:34,515 --> 00:08:38,519
システム内で
何が起きているのでしょう

115
00:08:39,052 --> 00:08:43,289
全てのコンポーネントの
タイムラインを見ます

116
00:08:43,957 --> 00:08:47,461
通常どおり
レンダリングを開始すると

117
00:08:47,728 --> 00:08:51,398
３つのバッファが
確認できます

118
00:08:51,498 --> 00:08:56,069
全てのdrawableは
文字と色で表されています

119
00:08:56,670 --> 00:08:58,805
前提を説明します

120
00:08:59,006 --> 00:09:01,074
Ｂのレンダリング時間は

121
00:08:59,006 --> 00:09:01,074
Ｂのレンダリング時間は

122
00:09:01,174 --> 00:09:04,144
ディスプレイの
リフレッシュ間隔より

123
00:09:04,244 --> 00:09:06,013
長くなっています

124
00:09:07,247 --> 00:09:10,751
Ｂのレンダリング時間は
25ミリ秒で

125
00:09:10,851 --> 00:09:14,488
ディスプレイのリフレッシュ間隔は
16.6ミリ秒

126
00:09:16,223 --> 00:09:22,062
こうなるとディスプレイは
レンダリングが終わるまで

127
00:09:22,162 --> 00:09:25,799
Ａを表示し続けなければ
なりません

128
00:09:26,733 --> 00:09:32,973
そうして待っている間に
Ｂのレンダリングが完了します

129
00:09:33,540 --> 00:09:35,809
表示する準備はできましたが

130
00:09:36,310 --> 00:09:39,346
ここで別の問題が起きます

131
00:09:39,613 --> 00:09:43,350
待っている間に
Ｃのレンダリングも終わり―

132
00:09:43,617 --> 00:09:45,719
表示の準備が完了したのです

133
00:09:46,687 --> 00:09:51,325
すると一貫性のない
フレームペーシングが発生

134
00:09:51,592 --> 00:09:55,863
これ以降のフレームは
一貫性がなくなり

135
00:09:56,263 --> 00:09:58,765
マイクロスタッタリングが
発生します

136
00:10:00,601 --> 00:10:05,806
これは いろいろな形で
実際に起こる現象です

137
00:10:06,006 --> 00:10:12,312
The Talos Principleを使い
デモをお見せします

138
00:10:12,446 --> 00:10:16,316
マイクロスタッタリングを
確認できるでしょうか

139
00:10:25,259 --> 00:10:30,297
今からお見せするのは
先ほどお話しした―

140
00:10:30,397 --> 00:10:33,767
Game Performance
テンプレートです

141
00:10:34,234 --> 00:10:37,805
左側にInstrumentsがあり

142
00:10:39,473 --> 00:10:42,209
中央にスレッドがあります

143
00:10:42,676 --> 00:10:46,780
ではマイクロスタッタリングを
探します

144
00:10:47,281 --> 00:10:50,417
ディスプレイトラックに注目し

145
00:10:50,517 --> 00:10:54,755
一貫性のないフレームを
見つけます

146
00:10:55,122 --> 00:10:57,524
ディスプレイトラックはここです

147
00:10:58,458 --> 00:11:05,532
このディスプレイトラックに
いくつかのヒントが隠されています

148
00:10:58,458 --> 00:11:05,532
このディスプレイトラックに
いくつかのヒントが隠されています

149
00:11:05,933 --> 00:11:09,303
このアイコンは
通常の時間よりも

150
00:11:09,403 --> 00:11:12,773
表示が長くなった時に現れます

151
00:11:13,106 --> 00:11:18,512
いい例を見つけたので
そこを拡大してみましょう

152
00:11:19,079 --> 00:11:24,484
optionキーを押したまま
ポインタをドラッグします

153
00:11:25,652 --> 00:11:28,856
ディスプレイトラックを見ると

154
00:11:29,223 --> 00:11:31,825
マイクロスタッタリングが
確認できますね

155
00:11:31,925 --> 00:11:35,929
表示のタイミングが
全て違います

156
00:11:36,396 --> 00:11:41,068
この場合は
50ミリ秒と33ミリ秒と16ミリ秒

157
00:11:41,401 --> 00:11:44,371
50ミリ秒のあと 33ミリ秒

158
00:11:44,471 --> 00:11:48,542
この繰り返しが
見られるということは

159
00:11:48,642 --> 00:11:51,311
マイクロスタッタリングです

160
00:11:51,778 --> 00:11:54,381
これを修正しましょう

161
00:11:58,051 --> 00:12:02,122
実際に起こり得る問題を
ご覧いただきました

162
00:11:58,051 --> 00:12:02,122
実際に起こり得る問題を
ご覧いただきました

163
00:12:02,389 --> 00:12:06,693
では どのように
修正すればよいのでしょう

164
00:12:07,861 --> 00:12:11,765
フレームレートを
調整するのが一番です

165
00:12:12,166 --> 00:12:17,004
フレーム持続時間の最小値を
APIを使って―

166
00:12:17,938 --> 00:12:20,841
レンダリング時間より
長く設定します

167
00:12:21,241 --> 00:12:24,444
例えばMTLDrawable
addPresentedHandlerは

168
00:12:24,545 --> 00:12:27,648
drawableが現れると
コールバックし

169
00:12:27,748 --> 00:12:31,185
マイクロスタッタリングを
認識できます

170
00:12:31,852 --> 00:12:35,722
他の２つのAPIは
実際に問題を解決し

171
00:12:35,823 --> 00:12:40,194
フレームペーシングを
コントロールします

172
00:12:40,394 --> 00:12:44,531
今回は下の２つのAPIを
利用します

173
00:12:45,132 --> 00:12:51,171
フレーム持続時間の最小値を
レンダリング時間より―

174
00:12:51,839 --> 00:12:54,508
長く設定すると
どうなるでしょう

175
00:12:55,976 --> 00:13:01,014
レンダリングを始めた時から
フレーム持続時間は

176
00:12:55,976 --> 00:13:01,014
レンダリングを始めた時から
フレーム持続時間は

177
00:13:01,114 --> 00:13:05,385
レンダリング時間より
一貫して長くなりました

178
00:13:05,719 --> 00:13:07,688
全てのフレームが―

179
00:13:08,655 --> 00:13:11,792
一貫性を保っています

180
00:13:12,192 --> 00:13:15,729
思わぬ副次的効果もあります

181
00:13:15,829 --> 00:13:18,966
フレームレートが
毎秒40フレームから

182
00:13:19,066 --> 00:13:24,004
毎秒30フレームになり
フレーム時間が伸びたのです

183
00:13:25,172 --> 00:13:31,645
どうすればフレームペーシングを
このように修正できるでしょうか

184
00:13:31,745 --> 00:13:35,682
必要なのは
わずか数行のコードです

185
00:13:36,049 --> 00:13:39,486
先ほどと同じパターンで
レンダリングを行い

186
00:13:39,586 --> 00:13:42,556
drawableを受け取りました

187
00:13:43,056 --> 00:13:48,161
先ほどと異なるのは
フレーム持続時間の最小値が

188
00:13:48,395 --> 00:13:51,331
設定されている点です

189
00:13:51,598 --> 00:13:52,799
それだけです

190
00:13:53,400 --> 00:13:58,272
これでフレームの
一貫性が保たれます

191
00:13:59,306 --> 00:14:02,376
しかし こんな疑問もあるでしょう

192
00:13:59,306 --> 00:14:02,376
しかし こんな疑問もあるでしょう

193
00:14:02,876 --> 00:14:05,112
“最大値はどうなるのか？”

194
00:14:05,612 --> 00:14:10,617
“作業の優先度については
どうするのか？”

195
00:14:11,185 --> 00:14:15,155
それが次の問題
スレッド優先度です

196
00:14:16,290 --> 00:14:19,226
まずは映像をご覧ください

197
00:14:19,526 --> 00:14:22,329
再びFox 2のデモです

198
00:14:23,530 --> 00:14:27,634
スタッタリングが起こる原因は

199
00:14:27,734 --> 00:14:31,705
数多く存在すると考えられます

200
00:14:32,072 --> 00:14:37,778
その中でも極めて基本的で
かつ一般的な原因は

201
00:14:38,946 --> 00:14:40,747
スレッドの遅延です

202
00:14:42,316 --> 00:14:46,954
作業の優先度が
うまく調整されていなければ

203
00:14:47,054 --> 00:14:49,356
予期せぬ遅延が発生します

204
00:14:50,090 --> 00:14:53,927
iOSは他にも
処理を行っているのです

205
00:14:54,928 --> 00:15:00,033
スレッド優先度はシステム全体の
安定性の保証に使われるため

206
00:14:54,928 --> 00:15:00,033
スレッド優先度はシステム全体の
安定性の保証に使われるため

207
00:15:00,667 --> 00:15:05,706
多くの作業を行うスレッドは
優先度が下がり

208
00:15:05,806 --> 00:15:07,808
他が実行されます

209
00:15:08,242 --> 00:15:10,811
これが優先度の低下です

210
00:15:11,912 --> 00:15:16,016
また 優先度の逆転も起こります

211
00:15:16,116 --> 00:15:20,387
これは非常に似た状況で
現れる別の問題です

212
00:15:20,521 --> 00:15:24,725
優先度の逆転は
レンダリングスレッドが

213
00:15:24,825 --> 00:15:30,964
優先度の低いスレッドに
依存している時に起こります

214
00:15:31,465 --> 00:15:34,768
先ほどのタイムラインで
確認しましょう

215
00:15:35,836 --> 00:15:40,407
まず毎秒30フレームで
レンダリングを開始

216
00:15:41,041 --> 00:15:44,044
ここでバックグラウンドの
処理が発生

217
00:15:44,678 --> 00:15:47,781
iOSは たくさんの
処理をします

218
00:15:48,715 --> 00:15:52,653
スレッドが正しく
設定されていない場合

219
00:15:53,453 --> 00:15:55,856
バックグラウンド作業と入れ替わり

220
00:15:55,956 --> 00:16:00,027
スケジューリングされていた
処理が終わりません

221
00:15:55,956 --> 00:16:00,027
スケジューリングされていた
処理が終わりません

222
00:16:01,061 --> 00:16:05,065
フレーム持続時間の最大値は
設定していないので

223
00:16:05,165 --> 00:16:08,268
何百ミリ秒も
表示される可能性も

224
00:16:08,735 --> 00:16:10,938
ユーザは
スタッタリングを認識します

225
00:16:12,673 --> 00:16:16,109
これは理論上の話ですが
現実でも―

226
00:16:16,276 --> 00:16:19,479
同様の問題が
さまざまな形で起きます

227
00:16:19,813 --> 00:16:25,085
The Talos Principleを使って
デモをお見せしましょう

228
00:16:25,252 --> 00:16:27,521
この問題を確認できます

229
00:16:38,065 --> 00:16:43,937
Game Performanceテンプレートを
再び表示しました

230
00:16:44,271 --> 00:16:48,408
注目したいフレームを
すでに拡大しています

231
00:16:48,509 --> 00:16:50,410
非常に長いフレームで

232
00:16:51,311 --> 00:16:54,014
233ミリ秒あります

233
00:16:54,114 --> 00:16:57,117
ここを見ていきましょう

234
00:16:58,652 --> 00:17:04,525
GPUが正常に動作していないのが
一目で分かります

235
00:16:58,652 --> 00:17:04,525
GPUが正常に動作していないのが
一目で分かります

236
00:17:04,992 --> 00:17:10,897
アイドル状態があって
あまりよくありませんね

237
00:17:12,232 --> 00:17:17,538
CPUを見ると このように
かなりのビジー状態で

238
00:17:17,704 --> 00:17:21,141
絶え間なく動いています

239
00:17:22,443 --> 00:17:28,214
しかし
Time Profilerビューを見ると

240
00:17:28,315 --> 00:17:30,651
動いていません

241
00:17:31,318 --> 00:17:36,323
なぜスタッタリングが
発生したのでしょう？

242
00:17:36,957 --> 00:17:42,829
Thread Statesビューに
切り替えます

243
00:17:43,397 --> 00:17:47,334
そのためにはアイコンをクリックし

244
00:17:47,768 --> 00:17:52,739
Track Displayを開きます

245
00:17:53,640 --> 00:17:56,043
Thread Statesを選択

246
00:17:57,678 --> 00:18:01,815
何か問題が起きていることが
分かります

247
00:17:57,678 --> 00:18:01,815
何か問題が起きていることが
分かります

248
00:18:02,349 --> 00:18:04,718
オレンジ色の箇所です

249
00:18:04,818 --> 00:18:09,957
スレッドは192ミリ秒間
プリエンプトされているので

250
00:18:10,524 --> 00:18:15,429
レンダリングスレッドが
その間 動作していません

251
00:18:16,230 --> 00:18:22,503
より詳細な情報が知りたいなら
下部を見れば分かります

252
00:18:23,837 --> 00:18:27,407
プリエンプトされた
スレッドをクリックすると

253
00:18:27,708 --> 00:18:31,478
何が起きているのか
ここに表示されます

254
00:18:31,578 --> 00:18:35,849
スレッド優先度26として
プリエンプトされたようです

255
00:18:35,949 --> 00:18:39,019
バックグラウンド処理より
順位が低く

256
00:18:39,486 --> 00:18:41,555
App Storeの更新が優先されました

257
00:18:42,089 --> 00:18:43,891
これでは困るので

258
00:18:43,991 --> 00:18:51,365
今はゲームのほうが重要なのだと
システムに伝える必要があります

259
00:18:51,765 --> 00:18:54,468
その方法をご説明しましょう

260
00:19:02,242 --> 00:19:05,779
一番いいのは
レンダリングスレッドを設定し

261
00:19:06,213 --> 00:19:10,384
スレッドの優先度を
45に固定することです

262
00:19:11,151 --> 00:19:16,190
iOSやmacOSの優先度は
値が大きいほうが上で

263
00:19:16,957 --> 00:19:21,728
優先度31は
４よりも高くなります

264
00:19:22,329 --> 00:19:26,200
また 優先度の低下を
避けるため

265
00:19:26,300 --> 00:19:30,671
スケジューラの
Quality of Serviceを止めます

266
00:19:31,738 --> 00:19:34,408
では見ていきましょう

267
00:19:36,043 --> 00:19:39,379
すでに設定は完了しています

268
00:19:39,880 --> 00:19:41,482
レンダリングを開始

269
00:19:42,616 --> 00:19:46,386
バックグラウンドの作業も
実行します

270
00:19:46,787 --> 00:19:51,191
内容はApp Storeの更新です

271
00:19:51,692 --> 00:19:56,864
それでもレンダリングは
正しく処理されています

272
00:19:57,130 --> 00:20:01,668
バックグラウンドの作業を
プリエンプトしているので

273
00:19:57,130 --> 00:20:01,668
バックグラウンドの作業を
プリエンプトしているので

274
00:20:02,536 --> 00:20:05,139
スタッタリングはありません

275
00:20:05,305 --> 00:20:09,076
ゲームは毎秒30フレームで
動いており

276
00:20:09,176 --> 00:20:11,578
負荷は膨大ですが大丈夫です

277
00:20:12,012 --> 00:20:14,982
まさに“技術的にすごい”ですね

278
00:20:15,182 --> 00:20:18,719
ではコードを
見ていきましょう

279
00:20:19,953 --> 00:20:24,124
必要なのは わずか数行だけです

280
00:20:24,725 --> 00:20:29,129
この場合は
pthread属性を設定したあとに

281
00:20:29,229 --> 00:20:31,532
pthreadを作成しています

282
00:20:32,166 --> 00:20:37,104
Quality of Serviceを止め
優先度を45にしています

283
00:20:38,005 --> 00:20:42,409
これで必要な
pthreadが作成できました

284
00:20:43,110 --> 00:20:45,479
シンプルで
技術的にすごいですね

285
00:20:47,181 --> 00:20:51,785
次の問題は
もう少し複雑ですよ

286
00:20:52,586 --> 00:20:55,055
温度の状態です

287
00:20:56,256 --> 00:21:01,395
持続可能なパフォーマンスの
ためのデザインには

288
00:20:56,256 --> 00:21:01,395
持続可能なパフォーマンスの
ためのデザインには

289
00:21:02,963 --> 00:21:05,165
温度管理が大切です

290
00:21:05,632 --> 00:21:07,468
これを考えましょう

291
00:21:08,836 --> 00:21:12,706
iOSデバイスは
非常にパワフルですが

292
00:21:12,806 --> 00:21:15,309
とても小さいです

293
00:21:15,642 --> 00:21:18,812
アプリケーションが
多くのリソースを使えば

294
00:21:19,012 --> 00:21:24,551
低温を維持するために
システムは対策を講じます

295
00:21:25,152 --> 00:21:29,690
また ユーザが
省電力モードを設定すれば

296
00:21:29,790 --> 00:21:32,526
同じような影響を与えます

297
00:21:34,561 --> 00:21:38,098
最善の方法は
システムの状態によって

298
00:21:38,198 --> 00:21:41,301
作業負荷を変えることです

299
00:21:42,202 --> 00:21:45,706
システムへの
負荷を調整するための―

300
00:21:45,873 --> 00:21:48,809
APIが多数あります

301
00:21:48,909 --> 00:21:52,646
NSProcessInfo
thermalStateは

302
00:21:52,746 --> 00:21:57,484
デバイスの温度状態が
変わった時に通知します

303
00:21:57,818 --> 00:22:02,523
同様に 省電力モードの状況も
チェックしましょう

304
00:21:57,818 --> 00:22:02,523
同様に 省電力モードの状況も
チェックしましょう

305
00:22:02,923 --> 00:22:08,161
一番下のAPIを使用すると
システムの負荷が

306
00:22:08,395 --> 00:22:12,733
GPU時間に
どう影響しているか分かります

307
00:22:14,468 --> 00:22:17,504
ではコードを見てみましょう

308
00:22:18,372 --> 00:22:20,707
これが最善の方法です

309
00:22:21,175 --> 00:22:24,745
switchステートメントがあり

310
00:22:24,845 --> 00:22:27,514
caseは温度状態に
対応しています

311
00:22:27,714 --> 00:22:31,018
内容は“nominal”“fair”

312
00:22:32,186 --> 00:22:34,788
“serious”“critical”です

313
00:22:37,458 --> 00:22:40,561
これで温度状態が分かり

314
00:22:40,661 --> 00:22:45,465
どう対処すればよいかも
コマンドが教えてくれます

315
00:22:45,999 --> 00:22:50,137
では 低温を保つには
どうすれば？

316
00:22:51,004 --> 00:22:54,508
いくつか方法を
提案できますが

317
00:22:54,608 --> 00:23:00,881
システムのために何を選ぶかは
ゲームデベロッパ次第です

318
00:22:54,608 --> 00:23:00,881
システムのために何を選ぶかは
ゲームデベロッパ次第です

319
00:23:01,215 --> 00:23:05,519
最高の状態を保つために
何が必要でしょうか

320
00:23:06,587 --> 00:23:10,657
ゲームを完遂できるような
フレームレートを

321
00:23:10,757 --> 00:23:13,160
目標にするとよいでしょう

322
00:23:13,694 --> 00:23:16,797
例えば
毎秒60フレームが無理なら

323
00:23:16,897 --> 00:23:20,534
毎秒30フレームを維持すること

324
00:23:21,435 --> 00:23:25,172
GPUの作業の調整も
非常に重要です

325
00:23:25,973 --> 00:23:30,177
中間レンダリングターゲットの
解像度を下げたり

326
00:23:30,811 --> 00:23:34,915
シャドウマップを
単純化したりします

327
00:23:35,015 --> 00:23:38,352
後処理を削除してもよいでしょう

328
00:23:38,585 --> 00:23:43,357
あなたのゲームにとって
最適な方法を選びましょう

329
00:23:44,925 --> 00:23:48,328
これは次の問題に関係します

330
00:23:49,096 --> 00:23:51,765
不要なGPUの処理です

331
00:23:51,932 --> 00:23:56,837
ここからは私の同僚
オハッドにお願いします

332
00:23:57,104 --> 00:24:00,507
(拍手)

333
00:23:57,104 --> 00:24:00,507
(拍手)

334
00:24:00,607 --> 00:24:01,642
ありがとう

335
00:24:04,878 --> 00:24:06,046
こんにちは

336
00:24:06,146 --> 00:24:10,150
私はゲーム技術チームの
オハッドです

337
00:24:10,751 --> 00:24:16,323
システムへの適合が大事だと
お分かりいただけましたね

338
00:24:17,191 --> 00:24:21,929
温度状態の変化や
省電力モードに対応するためには

339
00:24:22,262 --> 00:24:28,435
GPUの作業負荷を
調整する必要があります

340
00:24:29,303 --> 00:24:31,205
しかし多くのデベロッパは

341
00:24:31,305 --> 00:24:35,909
GPUは複雑な
ブラックボックスだと考えています

342
00:24:36,376 --> 00:24:38,779
今日は その中を解明します

343
00:24:40,447 --> 00:24:45,819
気付かずにGPU時間を
無駄にすることは よくあります

344
00:24:46,120 --> 00:24:51,458
技術的にすごいゲームは
GPUを有効に利用し

345
00:24:52,292 --> 00:24:57,564
適切な温度管理を行い
電力をセーブします

346
00:24:57,898 --> 00:25:02,002
その方法は
著名なゲームからも学べますが

347
00:24:57,898 --> 00:25:02,002
その方法は
著名なゲームからも学べますが

348
00:25:02,102 --> 00:25:07,274
今日はレンダリングについて
お話しします

349
00:25:08,075 --> 00:25:11,378
CPUの話でもお伝えしたように

350
00:25:11,745 --> 00:25:15,682
最良の方法は
GPUのプロファイリングです

351
00:25:17,284 --> 00:25:22,389
GPUには多くの性能が
隠されています

352
00:25:22,689 --> 00:25:28,662
作業時間を測定し
レンダリング技術を理解して

353
00:25:29,129 --> 00:25:33,500
ゲームを視覚的に
向上させましょう

354
00:25:34,268 --> 00:25:36,537
しかし どこが非効率で

355
00:25:37,070 --> 00:25:40,607
パイプラインのどこが
過剰なのでしょうか

356
00:25:40,707 --> 00:25:43,577
ここでツールに戻ります

357
00:25:44,878 --> 00:25:50,117
Instrumentsを開き
Metal System Traceを見ます

358
00:25:50,551 --> 00:25:56,290
VertexやFragmentなどの
処理完了のタイミングが分かります

359
00:25:57,324 --> 00:26:00,694
しかし これだけでは不十分です

360
00:25:57,324 --> 00:26:00,694
しかし これだけでは不十分です

361
00:26:00,961 --> 00:26:05,833
各パスが何をしているか
理解しましょう

362
00:26:06,967 --> 00:26:11,271
Metalフレームデバッガに
追加された新機能は

363
00:26:11,371 --> 00:26:13,006
依存関係グラフです

364
00:26:15,209 --> 00:26:19,079
１つのフレームに
関してのグラフで

365
00:26:20,114 --> 00:26:24,852
ノードとエッジで
構成されています

366
00:26:25,752 --> 00:26:29,756
エッジはパス間の依存関係を
表しています

367
00:26:29,857 --> 00:26:34,628
全体を見ると どのパスと
パイプラインが―

368
00:26:34,728 --> 00:26:37,998
フレームを形成しているか
分かります

369
00:26:38,966 --> 00:26:42,936
一方でノードは
１つのパスの情報です

370
00:26:44,304 --> 00:26:46,273
主な要素は３つ

371
00:26:46,573 --> 00:26:50,577
まずタイトルで
パスの名前が示されます

372
00:26:50,677 --> 00:26:53,947
名前は必ず付けましょう

373
00:26:54,047 --> 00:26:58,585
ツール全般において
名前は重要です

374
00:26:59,686 --> 00:27:04,224
今見ているパスの種類も
ここで分かります

375
00:26:59,686 --> 00:27:04,224
今見ているパスの種類も
ここで分かります

376
00:27:04,992 --> 00:27:10,264
転送パスや計算パスもありますが
これはレンダリングパスです

377
00:27:11,498 --> 00:27:16,103
次は このパスで処理された
作業状況の一覧

378
00:27:16,837 --> 00:27:22,843
最後は下部に表示される
パスのリソースのリストです

379
00:27:22,943 --> 00:27:27,581
ラベルや
作業内容を示すサムネールや

380
00:27:27,681 --> 00:27:32,119
それぞれのリソース情報を
示したリストです

381
00:27:33,086 --> 00:27:37,424
これらのおかげで
パスを理解できます

382
00:27:37,891 --> 00:27:43,764
グラフの説明をしたので
デモをお見せしましょう

383
00:27:52,973 --> 00:27:56,844
Fox 2のデモを見てみましょう

384
00:27:57,110 --> 00:28:01,248
このゲームに さまざまな
効果を追加します

385
00:27:57,110 --> 00:28:01,248
このゲームに さまざまな
効果を追加します

386
00:28:02,416 --> 00:28:05,519
シャドウマップや
ブルーム効果―

387
00:28:05,853 --> 00:28:11,959
被写界深度などを駆使し
美しい映像を描きます

388
00:28:12,559 --> 00:28:15,529
では依存関係ビューアです

389
00:28:15,963 --> 00:28:21,201
Xcodeを開き
Capture GPU frameボタンを押し

390
00:28:21,468 --> 00:28:23,570
MainPassを選択します

391
00:28:25,139 --> 00:28:25,806
(拍手)

392
00:28:25,906 --> 00:28:30,210
自動モードに変更すると
右側にアシスタントが現れます

393
00:28:30,310 --> 00:28:34,214
デバッグナビゲータで
選んだパスが

394
00:28:34,314 --> 00:28:38,418
メインビューで
表示されています

395
00:28:38,519 --> 00:28:43,724
これは双方向的で
グラフは相互に作用するので

396
00:28:43,824 --> 00:28:49,129
別のパスやテキスチャや
バッファを選ぶと

397
00:28:49,763 --> 00:28:54,835
左のナビゲータも
右のアシスタントも更新されます

398
00:28:55,335 --> 00:28:58,472
フレームの
すばらしい操作方法ですね

399
00:29:01,108 --> 00:29:05,045
ズームアウトすると
統計データが隠れ

400
00:29:05,145 --> 00:29:09,850
フォーカスが個別のパスから
フレーム全体へと移ります

401
00:29:10,217 --> 00:29:15,789
さらに縮小すると
フレーム全体が確認できます

402
00:29:17,324 --> 00:29:23,030
グラフの結びつきは
依存関係を示しているので

403
00:29:24,298 --> 00:29:27,801
それぞれの処理が
グループ化されています

404
00:29:28,435 --> 00:29:30,337
説明しましょう

405
00:29:30,437 --> 00:29:33,907
ここにシャドウマップ作成用の
ノードがあります

406
00:29:35,609 --> 00:29:40,647
影をレンダリングする３つのパスが
左側に見えます

407
00:29:41,148 --> 00:29:46,086
フレーム全体の様子が
分かるだけでなく

408
00:29:46,253 --> 00:29:49,523
２つのレイヤの間にある
階層も見えます

409
00:29:49,756 --> 00:29:53,093
レンダリング技術の
大切な要素の１つですが

410
00:29:53,327 --> 00:29:58,365
ゲームエンジンを使う際に
常に目立つものではありません

411
00:29:58,465 --> 00:30:02,102
例えば カスケードに
個別のパスが必要なことに―

412
00:29:58,465 --> 00:30:02,102
例えば カスケードに
個別のパスが必要なことに―

413
00:30:02,202 --> 00:30:05,072
気付かない場合もあります

414
00:30:05,572 --> 00:30:12,479
これら一つ一つについては考えず
グループとしてとらえます

415
00:30:13,447 --> 00:30:17,484
これにより
GPUの作業負荷を調整する時

416
00:30:17,584 --> 00:30:21,455
確かな情報を基に判断できます

417
00:30:22,923 --> 00:30:24,591
以上が依存関係ビューアです

418
00:30:24,858 --> 00:30:29,563
スライドに戻って
ギエムを呼びましょう

419
00:30:29,663 --> 00:30:30,564
ありがとう

420
00:30:30,664 --> 00:30:35,435
(拍手)

421
00:30:36,336 --> 00:30:39,406
ありがとう
すばらしいデモでした

422
00:30:44,077 --> 00:30:49,149
今 オハッドがご説明した
依存関係ビューアは

423
00:30:50,117 --> 00:30:54,288
GPUの作業負荷の調査に
適しています

424
00:30:54,721 --> 00:31:00,894
例えば このように小さく
シンプルなパイプラインから

425
00:30:54,721 --> 00:31:00,894
例えば このように小さく
シンプルなパイプラインから

426
00:31:01,695 --> 00:31:08,535
後処理などが必要な複雑なものに
変える場合がよくあります

427
00:31:09,736 --> 00:31:12,372
これらはオブジェクトに

428
00:31:12,473 --> 00:31:16,243
プロパティを追加することが
必要です

429
00:31:17,211 --> 00:31:20,948
コードの変更は
最小限で済みますが

430
00:31:21,248 --> 00:31:25,786
レンダリングの複雑さは
10倍単位で増えます

431
00:31:26,820 --> 00:31:31,859
そこで最初に
お話しした内容に戻ります

432
00:31:32,826 --> 00:31:33,994
プロファイリングです

433
00:31:34,394 --> 00:31:38,432
ゲームを理解することが大切です

434
00:31:39,366 --> 00:31:43,337
開発に時間をかけるだけでなく

435
00:31:43,437 --> 00:31:46,874
プロファイリングの時間も必要です

436
00:31:47,608 --> 00:31:52,146
今日お話しした問題は
数分で見つけられます

437
00:31:52,613 --> 00:31:55,949
探し回る必要はありません

438
00:31:56,083 --> 00:31:59,019
スタッタリングや
長いフレームを記録し

439
00:31:59,119 --> 00:32:01,488
そこから調整を始めるのです

440
00:31:59,119 --> 00:32:01,488
そこから調整を始めるのです

441
00:32:01,588 --> 00:32:02,923
簡単なことです

442
00:32:03,090 --> 00:32:07,094
問題を認識するための
情報を得るために

443
00:32:07,628 --> 00:32:09,429
ツールを使いましょう

444
00:32:10,597 --> 00:32:14,201
このことを忘れないでください

445
00:32:14,568 --> 00:32:19,206
さまざまな解決法と共に
見てきた問題は―

446
00:32:19,840 --> 00:32:23,143
プロファイリングで
発見できます

447
00:32:23,243 --> 00:32:29,083
我々も多くのゲームを解析して
問題を見つけたのです

448
00:32:29,917 --> 00:32:33,253
ソースコードに
アクセスしたら

449
00:32:33,654 --> 00:32:37,658
フレームペーシングと
スレッド優先度を設定しましょう

450
00:32:37,858 --> 00:32:39,927
コードは ほんの数行です

451
00:32:40,694 --> 00:32:44,665
そのうえで
温度を適切に管理し

452
00:32:44,765 --> 00:32:47,734
不要なGPUの処理を避けましょう

453
00:32:48,435 --> 00:32:51,572
これらを確実に実行すれば

454
00:32:52,039 --> 00:32:56,376
技術的にすごいゲームを
開発できます

455
00:32:57,344 --> 00:33:01,582
より詳細な情報は
ラボでご確認ください

456
00:32:57,344 --> 00:33:01,582
より詳細な情報は
ラボでご確認ください

457
00:33:01,682 --> 00:33:07,621
皆様からのご質問も
お待ちしております

458
00:33:07,955 --> 00:33:12,125
あなたのゲームの
プロファイリングも行いますよ

459
00:33:12,693 --> 00:33:19,299
Metalでのゲーム開発については
他にもセッションがあります

460
00:33:20,868 --> 00:33:25,072
ありがとうございました
よい一日を

461
00:33:25,272 --> 00:33:33,013
(拍手)