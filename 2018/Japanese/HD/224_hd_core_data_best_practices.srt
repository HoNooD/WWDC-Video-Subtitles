
1
00:00:07,074 --> 00:00:16,717
(音楽)

2
00:00:21,522 --> 00:00:22,756
こんにちは

3
00:00:22,856 --> 00:00:27,694
(拍手)

4
00:00:27,794 --> 00:00:29,730
Core Data Best
Practicesへようこそ

5
00:00:29,830 --> 00:00:35,202
Core Dataのスコット･ペリーと
ニック･ジレットがお届けします

6
00:00:36,436 --> 00:00:37,604
まず初めに

7
00:00:38,739 --> 00:00:43,510
進化し続けるCore Dataについて
簡単にご紹介します

8
00:00:43,911 --> 00:00:47,548
次に 永続コンテナにおける
拡張ポイントを活用し

9
00:00:47,648 --> 00:00:51,185
アプリケーションを
より簡単に進化させる方法

10
00:00:52,519 --> 00:00:55,889
アプリケーションの要求や
データ量に応じて

11
00:00:55,989 --> 00:00:57,524
モデルを進化させる方法

12
00:00:58,992 --> 00:01:02,829
規模に関わらず
パフォーマンスを維持する方法

13
00:00:58,992 --> 00:01:02,829
規模に関わらず
パフォーマンスを維持する方法

14
00:01:02,930 --> 00:01:05,465
こちらはニックがお話しします

15
00:01:06,700 --> 00:01:11,271
トランスフォーマやデバッグ
テストにも触れます

16
00:01:12,906 --> 00:01:15,108
アプリケーションを
作ってみましょう

17
00:01:15,843 --> 00:01:20,314
投稿した写真にコメントが付くのは
うれしいものです

18
00:01:20,414 --> 00:01:24,451
たとえニックからの
仕事関係のコメントでもね

19
00:01:27,254 --> 00:01:30,624
データの保存先は
オンライン上でもいいですが

20
00:01:30,724 --> 00:01:34,962
旅行先だと
通信が不安定なこともあります

21
00:01:35,262 --> 00:01:38,065
ローカルへの保存が賢明でしょう

22
00:01:40,934 --> 00:01:42,369
オブジェクトグラフが

23
00:01:42,469 --> 00:01:46,840
インスタンスや
その間の関係により形成されます

24
00:01:46,940 --> 00:01:50,978
これらをディスク上に
保存するわけですが

25
00:01:51,578 --> 00:01:53,447
そこでCore Dataの出番です

26
00:01:55,883 --> 00:01:59,953
これを使って まずモックを
ストアが読み込める―

27
00:02:00,053 --> 00:02:02,923
管理オブジェクトモデルに
変換します

28
00:02:03,524 --> 00:02:04,791
フィールドが必要です

29
00:02:04,892 --> 00:02:08,895
属性は画像データや
投稿時間などです

30
00:02:08,996 --> 00:02:12,499
関係も必要になります

31
00:02:13,000 --> 00:02:18,472
ディスク上でのデータの長期保存は
簡単ではありません

32
00:02:18,939 --> 00:02:22,910
Core Dataによる
永続ストアコーディネータは

33
00:02:23,010 --> 00:02:27,514
アプリケーションのモデルを
ストアのバージョンと比較して

34
00:02:27,614 --> 00:02:30,584
移行を自動で行ってくれます

35
00:02:30,951 --> 00:02:34,087
管理オブジェクトコンテキストは
安全かつ高速で

36
00:02:34,188 --> 00:02:36,290
予測可能なアクセスを可能にします

37
00:02:36,523 --> 00:02:40,527
クエリジェネレーションや
コネクションプーリングなどの―

38
00:02:40,627 --> 00:02:42,663
処理中でも対応できます

39
00:02:44,865 --> 00:02:47,935
ここでモデルを見つけ
それを読み込み

40
00:02:48,035 --> 00:02:50,003
ストアの場所を決めますが

41
00:02:50,337 --> 00:02:54,474
App配信後のエラーパスは
ほぼエラーにならないので

42
00:02:54,575 --> 00:02:56,410
Core Dataによるコンテナタイプで

43
00:02:56,510 --> 00:03:00,214
ボイラープレートは
大幅に省略できます

44
00:02:56,510 --> 00:03:00,214
ボイラープレートは
大幅に省略できます

45
00:03:00,314 --> 00:03:04,651
永続コンテナがメインバンドルから
モデルを読み込み

46
00:03:04,751 --> 00:03:07,054
一定の場所に保存するのです

47
00:03:09,089 --> 00:03:12,926
スタック全体がカプセル化され
共有されたメインキューの―

48
00:03:13,026 --> 00:03:15,596
ビューコンテキストにも有用です

49
00:03:15,696 --> 00:03:19,466
バックグラウンドの
パフォーマンスを上げるための

50
00:03:19,566 --> 00:03:22,002
ファクトリメソッドにも役立ちます

51
00:03:22,336 --> 00:03:25,739
アプリケーションが大きくなっても
対応できます

52
00:03:25,839 --> 00:03:26,773
モデルレイヤーを

53
00:03:26,874 --> 00:03:30,310
独自のフレームワークに
組み入れたい時でも

54
00:03:30,777 --> 00:03:35,649
新しいフレームワークターゲットを
Xcodeで作り コードを移すだけです

55
00:03:35,749 --> 00:03:37,951
しかしモデルを
新しいターゲットへ移す時

56
00:03:38,051 --> 00:03:41,889
ターゲットは
新しいフレームワークへ移動します

57
00:03:42,155 --> 00:03:43,524
正しい動きですが

58
00:03:43,624 --> 00:03:47,261
NSPersistentContainerが
モデルを捜せなくなります

59
00:03:47,361 --> 00:03:51,398
デフォルトでは チェックの対象は
メインバンドルだけです

60
00:03:51,698 --> 00:03:56,103
スタックを回転させるたびに
全てのバンドルを調べていては

61
00:03:56,203 --> 00:03:59,173
動作が遅くなるからです

62
00:04:00,607 --> 00:04:01,808
対処法は？

63
00:04:02,576 --> 00:04:06,146
フレームワークバンドルから
モデルを再び取り出し

64
00:04:06,246 --> 00:04:11,218
コンテナの他のイニシャライザを
使う手もありますが

65
00:04:11,652 --> 00:04:16,322
NSPersistentContainerなら
検索対象のバンドルを変更できます

66
00:04:17,757 --> 00:04:21,128
NSPersistentContainerは
モデルを捜す際に

67
00:04:21,228 --> 00:04:24,965
サブクラスの型を
ヒントとして使います

68
00:04:25,299 --> 00:04:28,502
サブクラスを作成すれば
これを利用できます

69
00:04:28,669 --> 00:04:30,871
中に何か書く必要はありません

70
00:04:31,839 --> 00:04:36,543
モデルを使うコンテナの
コード設定にサブクラスが採用され

71
00:04:36,643 --> 00:04:40,914
永続コンテナが バンドルから
モデルを見つけ出します

72
00:04:43,183 --> 00:04:47,321
ディスク上のデータの編成も
改善されていたら

73
00:04:47,421 --> 00:04:50,791
一層すばらしいと思いませんか？

74
00:04:51,992 --> 00:04:55,929
新しい永続コンテナは
自動移行するSQLiteストアの―

75
00:04:56,029 --> 00:05:00,267
ストアディスクリプションが
デフォルトで備わっています

76
00:04:56,029 --> 00:05:00,267
ストアディスクリプションが
デフォルトで備わっています

77
00:05:01,034 --> 00:05:03,804
それは結構ですが
新しいフレームワークと―

78
00:05:03,904 --> 00:05:07,508
アプリケーションの融合し過ぎは
避けたいですね

79
00:05:08,275 --> 00:05:12,346
モデルを見つけるのが
容易になったところで

80
00:05:12,446 --> 00:05:14,414
この点も改善してみましょう

81
00:05:17,050 --> 00:05:19,686
ストアの場所を強制的に変えるには

82
00:05:19,786 --> 00:05:21,788
persistentStoreDescriptionsの
中のURLを

83
00:05:21,889 --> 00:05:24,925
直接 書き換えればいいでしょう

84
00:05:25,459 --> 00:05:29,596
ただし今回は
NSPersistentContainerが

85
00:05:29,696 --> 00:05:32,966
永続ストアのディスクリプションを
作成する際に

86
00:05:33,066 --> 00:05:37,337
defaultDirectoryURLメソッドを
呼び出します

87
00:05:37,437 --> 00:05:38,972
オーバーライドもされます

88
00:05:39,373 --> 00:05:41,575
appendingPathComponentも
有効です

89
00:05:41,675 --> 00:05:45,345
ストアを別々の場所に
とどめておくための

90
00:05:45,445 --> 00:05:50,050
キャッシュやスタック用に
コンテナを構成する手もあります

91
00:05:51,985 --> 00:05:55,322
ここで アプリケーションや
View Controllerについて

92
00:05:55,422 --> 00:05:58,025
実際に見ていきましょう

93
00:05:59,059 --> 00:06:01,929
あることに特化した
View Controllerです

94
00:05:59,059 --> 00:06:01,929
あることに特化した
View Controllerです

95
00:06:02,196 --> 00:06:07,034
左は私のポスト
右は全ての作成者のポストです

96
00:06:07,134 --> 00:06:12,005
重複しているので
半分のコードで済みそうです

97
00:06:13,974 --> 00:06:17,544
片方では複数のポストを表示させ

98
00:06:17,644 --> 00:06:20,180
片方では１つだけ表示させます

99
00:06:20,547 --> 00:06:25,185
モデルオブジェクトを取る
２つのView Controllerの境界を

100
00:06:25,285 --> 00:06:28,088
うまく設定すれば可能です

101
00:06:29,156 --> 00:06:31,992
各View Controllerは
モデルパラメータにより構成され

102
00:06:32,459 --> 00:06:37,698
表示するポストによって ビューを
細かくカスタマイズできます

103
00:06:39,766 --> 00:06:41,768
リストビューには
フェッチ要求を取得させ

104
00:06:41,869 --> 00:06:46,373
ディテールビューには
管理オブジェクトを取得させます

105
00:06:47,407 --> 00:06:49,943
管理オブジェクトコンテキストも
必要です

106
00:06:50,043 --> 00:06:54,248
ビューコンテキストか 他の
メインキューコンテキストです

107
00:06:54,615 --> 00:06:57,417
View Controllerを汎化する
この方法は

108
00:06:57,518 --> 00:07:01,155
ユーティリティのデータ型にも
非常に有効です

109
00:06:57,518 --> 00:07:01,155
ユーティリティのデータ型にも
非常に有効です

110
00:07:01,722 --> 00:07:04,391
URLやシリアル化されたデータを

111
00:07:04,491 --> 00:07:09,229
バックグラウンドワークの
コントローラに渡します

112
00:07:09,329 --> 00:07:12,366
バックグラウンドの
コンテキストを使って

113
00:07:12,466 --> 00:07:16,770
更新済みの
管理オブジェクトに変換するのです

114
00:07:17,905 --> 00:07:21,808
私たちは独自のイニシャライザを
持っているため

115
00:07:21,909 --> 00:07:25,078
コントローラの生成を
パラメータに要求するだけですが

116
00:07:25,212 --> 00:07:28,348
View Controllerへの
境界変数の組み入れ方は？

117
00:07:30,350 --> 00:07:33,587
prepareメソッドは
セグエでオーバーライドできます

118
00:07:34,521 --> 00:07:38,559
destinationViewControllerへの
参照も取得できます

119
00:07:39,326 --> 00:07:41,061
ストーリーボードかNIBがあるなら

120
00:07:41,161 --> 00:07:45,065
destinationViewController用の
コードはできているので

121
00:07:45,165 --> 00:07:49,236
表示する前に プロパティを
設定すればいいだけです

122
00:07:49,403 --> 00:07:53,607
手動で行うなら
境界条件を明確に定義する―

123
00:07:53,707 --> 00:07:56,009
イニシャライザを
書いてもいいでしょう

124
00:07:57,344 --> 00:08:02,015
これで フェッチ要求と
コンテキストが準備できました

125
00:07:57,344 --> 00:08:02,015
これで フェッチ要求と
コンテキストが準備できました

126
00:08:02,149 --> 00:08:06,553
しかし フェッチ要求に
もう少し手を加えて

127
00:08:06,653 --> 00:08:09,456
より優れたパフォーマンスを
発揮させましょう

128
00:08:10,724 --> 00:08:13,026
今回は全データを見せたいので

129
00:08:13,126 --> 00:08:17,331
フェッチリミットの設定より
バッチ処理のほうが有効です

130
00:08:17,931 --> 00:08:22,035
私たちはView Controllerの
キャパシティを知っています

131
00:08:23,237 --> 00:08:24,872
フェッチ要求には

132
00:08:24,972 --> 00:08:29,576
こうした選択肢を
１つは用意しておくべきです

133
00:08:30,944 --> 00:08:36,015
これでフェッチ要求を
リストビューに変換できます

134
00:08:36,517 --> 00:08:40,654
では UIを常に
最新の状態に保つ方法は？

135
00:08:41,554 --> 00:08:44,525
役立つのが
フェッチ結果コントローラです

136
00:08:44,625 --> 00:08:46,994
あらゆるプラットフォームで
利用でき

137
00:08:47,094 --> 00:08:50,063
デリゲートプロトコルと
ビューの間にアダプタを書けば

138
00:08:50,164 --> 00:08:52,833
導入することができます

139
00:08:53,100 --> 00:08:56,103
必要なのはフェッチ要求と
コンテキストだけです

140
00:08:57,070 --> 00:09:02,276
より進化したリストビューの
コンセプトにも有用です

141
00:08:57,070 --> 00:09:02,276
より進化したリストビューの
コンセプトにも有用です

142
00:09:03,577 --> 00:09:06,747
ポストは 日を基準に
グループ分けできます

143
00:09:06,847 --> 00:09:10,350
計算済みプロパティでXcodeが
生成したポストタイプを拡張し

144
00:09:10,450 --> 00:09:13,053
フェッチ結果コントローラの
イニシャライザに

145
00:09:13,153 --> 00:09:15,355
名前を渡すのです

146
00:09:16,256 --> 00:09:17,591
有効な手段ですが

147
00:09:17,958 --> 00:09:21,595
View Controllerが
もっと複雑だったら？

148
00:09:21,695 --> 00:09:26,300
日ごとのポストを
グラフ化して表示したい場合は？

149
00:09:27,467 --> 00:09:31,471
フェッチ要求の実力を
侮ってはいけません

150
00:09:31,705 --> 00:09:37,244
私は先月 １日に40枚の写真を
ポストしましたが

151
00:09:37,611 --> 00:09:42,850
ストアから瞬時に取り出すには
十分すぎる量でした

152
00:09:44,218 --> 00:09:48,422
定義しておいたdayプロパティが
エンティティの一部であれば

153
00:09:48,522 --> 00:09:53,193
フェッチ要求で 日を基準に
ポストをカウントできるでしょう

154
00:09:53,694 --> 00:09:55,429
段階は３つあります

155
00:09:55,529 --> 00:09:59,600
まず 範囲を30日間に設定します

156
00:10:01,034 --> 00:10:06,039
次に 同じ値のday属性を持つ
全ての結果をグループ化します

157
00:10:06,173 --> 00:10:09,042
フェッチしているのは
オブジェクトの集合体なので

158
00:10:09,143 --> 00:10:13,380
結果の型を
ディクショナリに変えます

159
00:10:14,648 --> 00:10:17,751
最後に 各グループの
オブジェクトの数を表す―

160
00:10:17,851 --> 00:10:20,287
計算式を定義して

161
00:10:20,387 --> 00:10:23,757
フェッチ要求にその数を返させます

162
00:10:24,825 --> 00:10:30,063
返される30の結果が
グラフ上で点で表されます

163
00:10:33,267 --> 00:10:37,404
これはCore Dataが生成する
SQLiteクエリです

164
00:10:37,504 --> 00:10:40,307
皆さんがクエリを書く時と
同じですね

165
00:10:40,774 --> 00:10:42,342
Core Dataは多くの関数式を

166
00:10:42,442 --> 00:10:45,579
最適なデータベースクエリに
変換できます

167
00:10:45,679 --> 00:10:49,416
クエリによるグループは
集計関数を使うことができ

168
00:10:49,516 --> 00:10:53,987
スカラークエリは
通常のフェッチ要求のように

169
00:10:54,087 --> 00:10:57,257
ABS関数などの
日付関数が使えます

170
00:10:58,725 --> 00:11:03,163
NSExpressionでできることを
もっと知りたい方は

171
00:10:58,725 --> 00:11:03,163
NSExpressionでできることを
もっと知りたい方は

172
00:11:03,263 --> 00:11:06,033
使える関数のリストを
ご確認ください

173
00:11:08,268 --> 00:11:13,474
フェッチ要求は
関数式を使うことで活躍しますが

174
00:11:13,574 --> 00:11:18,879
依然 SQLiteはメモリを通して
全てのポストを読み込みます

175
00:11:19,713 --> 00:11:24,885
もし 対象となるポストが
１か月分だけならいいですが

176
00:11:24,985 --> 00:11:26,987
範囲がもっと広い場合は？

177
00:11:27,554 --> 00:11:29,656
１年分ならどうでしょう？

178
00:11:29,756 --> 00:11:33,760
データ量が
ケタ違いだったとしたら？

179
00:11:34,595 --> 00:11:39,700
この例では フェッチ要求は
５万件のポストを１件ずつ数えます

180
00:11:40,200 --> 00:11:42,302
それでは間に合いません

181
00:11:42,669 --> 00:11:47,875
ビューとモデル間のミスマッチには
非正規化が必要です

182
00:11:50,410 --> 00:11:54,047
冗長データを追加する
非正規化により

183
00:11:54,148 --> 00:11:57,818
読み込みパフォーマンスを
改善できます

184
00:11:58,352 --> 00:12:00,787
データベースインデックスが
いい例です

185
00:11:58,352 --> 00:12:00,787
データベースインデックスが
いい例です

186
00:12:01,421 --> 00:12:03,457
カウントメタデータを
ストアに加えれば

187
00:12:03,557 --> 00:12:08,228
グラフのパフォーマンスを
再び向上させることができます

188
00:12:09,129 --> 00:12:13,066
今回のモデルについて
見ていきましょう

189
00:12:14,034 --> 00:12:18,672
２つの属性を持つエンティティと
メンテナンスが必要です

190
00:12:19,106 --> 00:12:25,546
フェッチ要求を改善し
何年分ものデータをカバーできます

191
00:12:25,646 --> 00:12:28,482
この程度の非正規化で十分なのです

192
00:12:29,183 --> 00:12:31,852
View Controllerに渡した
フェッチ要求？

193
00:12:32,619 --> 00:12:33,754
すごくシンプルです

194
00:12:34,321 --> 00:12:38,725
他のリストビューに渡した
フェッチ要求とそう変わらず

195
00:12:38,826 --> 00:12:42,462
グラフのビューと
ほぼ同じに見えます

196
00:12:44,031 --> 00:12:45,666
メンテナンスとは？

197
00:12:46,533 --> 00:12:51,205
ポスト時のインクリメントと
削除時のデクリメントです

198
00:12:51,471 --> 00:12:55,108
確実な解決法は
コンテキストの退避に応じて

199
00:12:55,209 --> 00:12:59,146
計算をアップデートすることです

200
00:13:02,583 --> 00:13:07,955
管理オブジェクトの
contextWillSave通知と

201
00:13:08,055 --> 00:13:11,492
全てのポストに影響する関数を
登録して

202
00:13:11,592 --> 00:13:14,828
カウントをインクリメントしても
いいでしょう

203
00:13:14,995 --> 00:13:19,299
別のループには 投稿日に応じて
カウントをデクリメントさせます

204
00:13:19,633 --> 00:13:24,838
コンテキストは データベースに
作用する前に影響を受け

205
00:13:24,938 --> 00:13:26,840
機能が向上していきます

206
00:13:26,974 --> 00:13:29,877
Core Dataがあれば
小さなアプリケーションでも

207
00:13:29,977 --> 00:13:34,314
夢のような物に
進化させることができるのです

208
00:13:34,715 --> 00:13:35,349
ニック

209
00:13:35,449 --> 00:13:37,384
(拍手)

210
00:13:37,484 --> 00:13:38,352
ありがとう

211
00:13:38,452 --> 00:13:40,621
(拍手)

212
00:13:40,721 --> 00:13:41,755
アプリケーションは

213
00:13:41,855 --> 00:13:46,059
規模が大きくなるにつれ
複雑になっていきます

214
00:13:46,159 --> 00:13:50,063
しかし 規模を大きくするのは
重要なことです

215
00:13:50,264 --> 00:13:55,202
規模を大きくしていく中で
いかに機能性を上げ

216
00:13:55,302 --> 00:13:59,973
付加価値を高められるかが
私たちの存在意義だからです

217
00:14:01,675 --> 00:14:05,078
しかしアプリケーションによって
その過程は異なり

218
00:14:05,312 --> 00:14:11,151
顧客体験や作り手の意図とも
密接に関わってきます

219
00:14:11,952 --> 00:14:15,088
アプリケーションの構造が
複雑になるほど

220
00:14:15,189 --> 00:14:18,826
カオスを招く危険性が高くなります

221
00:14:19,259 --> 00:14:25,199
Core Dataで このカオスを
うまくコントロールしましょう

222
00:14:25,432 --> 00:14:28,101
予測可能な動作を設定し

223
00:14:28,469 --> 00:14:33,507
顧客体験に応じた
柔軟なコンテナを作るのです

224
00:14:36,443 --> 00:14:37,644
具体的には？

225
00:14:38,145 --> 00:14:43,183
メトリクスに関しては
いくつかの切り口が考えられます

226
00:14:43,283 --> 00:14:46,019
１つ目は
顧客に応じたものであること

227
00:14:46,253 --> 00:14:49,389
通常は顧客が体験することを
指します

228
00:14:49,490 --> 00:14:54,128
一貫したインターフェイスや
レスポンシブなスクロールビュー

229
00:14:56,029 --> 00:14:58,265
楽しさとも関係します

230
00:14:59,833 --> 00:15:02,803
これらはエンジニアには
捉えにくいため―

231
00:14:59,833 --> 00:15:02,803
これらはエンジニアには
捉えにくいため―

232
00:15:03,136 --> 00:15:05,405
エンジニアリングメトリクスに
落とし込みます

233
00:15:05,506 --> 00:15:10,577
ピーク時のメモリ消費量や
タスク実行時のバッテリーの消耗

234
00:15:10,677 --> 00:15:14,047
CPU時間は どれぐらいかかっていて

235
00:15:14,248 --> 00:15:18,285
I/Oは どのくらい行われているか

236
00:15:18,719 --> 00:15:21,955
より具体的に ご説明しましょう

237
00:15:22,189 --> 00:15:27,094
昨年ご紹介した
デモ用のアプリケーションですが

238
00:15:27,194 --> 00:15:29,997
今回用に修正を加えてあります

239
00:15:30,430 --> 00:15:34,802
顧客が取る行動は
いくつか考えられます

240
00:15:34,935 --> 00:15:40,073
まず＋ボタンで ポストを１件
データベースに加えること

241
00:15:40,707 --> 00:15:45,712
待機中のデータを サーバから
ダウンロードすることもできます

242
00:15:50,951 --> 00:15:55,956
新規で全てアップロード
する場合はPost Allです

243
00:15:56,490 --> 00:16:01,895
インタラクションの組み合わせは
かなり小規模なものですが

244
00:15:56,490 --> 00:16:01,895
インタラクションの組み合わせは
かなり小規模なものですが

245
00:16:02,062 --> 00:16:05,232
これが一斉に起こると―

246
00:16:06,066 --> 00:16:07,835
カオスになります

247
00:16:10,204 --> 00:16:13,373
たとえ小さな動作でも
一斉に起こると

248
00:16:13,474 --> 00:16:17,778
アプリケーションの状態に
様々な影響を及ぼします

249
00:16:17,878 --> 00:16:22,149
最悪の場合 ユーザ体験は
このようになります

250
00:16:22,583 --> 00:16:28,455
エンジニアにすら理解できないほど
不完全な状態です

251
00:16:29,723 --> 00:16:32,926
そこで有用なのが
クエリジェネレーションです

252
00:16:33,026 --> 00:16:37,931
これは2016年のセッションでも
ご紹介しました

253
00:16:38,031 --> 00:16:43,704
詳しく知りたい方は
ぜひ そちらもご覧ください

254
00:16:43,904 --> 00:16:49,176
これにはWALジャーナルモードと
SQLiteが欠かせません

255
00:16:49,810 --> 00:16:55,148
管理オブジェクトコンテキストを
競合する動作から切り離します

256
00:16:55,249 --> 00:16:57,284
ユーザが行うであろうものの―

257
00:16:57,384 --> 00:17:03,290
まだ準備できていないアクションに
役立つものです

258
00:16:57,384 --> 00:17:03,290
まだ準備できていないアクションに
役立つものです

259
00:17:03,924 --> 00:17:07,961
クエリジェネレーションが提供する
データベースのビューは

260
00:17:08,060 --> 00:17:10,230
フェッチする際に

261
00:17:10,329 --> 00:17:14,434
他のコンテキストに関わらず
同じ結果を返します

262
00:17:18,438 --> 00:17:21,175
必要なコードは１行だけです

263
00:17:21,608 --> 00:17:24,444
テーブルビューのリロード時は
このように

264
00:17:24,545 --> 00:17:26,180
クエリジェネレーションと共に

265
00:17:26,280 --> 00:17:30,150
NSManagedObjectContext
setQueryGenerationFromトークンの

266
00:17:30,250 --> 00:17:32,252
呼び出しを挿入します

267
00:17:33,353 --> 00:17:35,255
アップデートする際は

268
00:17:36,290 --> 00:17:40,994
通常どおりNSManagedObjectContext
DidSave通知を使います

269
00:17:42,729 --> 00:17:48,502
これにより 然るべきタイミングで
変更を加えることができます

270
00:17:52,306 --> 00:17:55,475
データがUIと関連していない時は？

271
00:17:55,576 --> 00:17:58,846
コメントを
ダウンロードするような場合です

272
00:17:59,513 --> 00:18:00,547
そうしたデータには

273
00:17:59,513 --> 00:18:00,547
そうしたデータには

274
00:18:01,181 --> 00:18:04,351
インターフェイスに
現れてほしくありません

275
00:18:04,451 --> 00:18:08,088
ユーザに分からないような変更も
困ります

276
00:18:08,422 --> 00:18:12,326
そこでヒストリートラッキングで
アップデートをフィルタします

277
00:18:12,859 --> 00:18:15,796
永続ヒストリートラッキングは
iOS 11とmacOS 10.13で

278
00:18:15,896 --> 00:18:17,798
新しく導入されました

279
00:18:18,065 --> 00:18:22,703
昨年のセッションでも
ご紹介していますので

280
00:18:22,903 --> 00:18:26,006
基本的な特徴を知りたい方は

281
00:18:26,106 --> 00:18:29,977
そちらをご覧になってみてください

282
00:18:31,879 --> 00:18:34,214
永続ヒストリートラッキングは

283
00:18:34,314 --> 00:18:38,552
各トランザクションの
永続レコードを得る上で有効です

284
00:18:38,652 --> 00:18:41,588
理由は いくつかあります

285
00:18:41,688 --> 00:18:44,124
ただ このセッションで
考えたいのは

286
00:18:44,591 --> 00:18:47,494
NSPersistentHistoryChangeです

287
00:18:47,661 --> 00:18:52,833
これはchangedObjectIDと
updatedPropertiesを与えます

288
00:18:52,933 --> 00:18:55,369
また NSPersistentHistory
Transactionもです

289
00:18:55,569 --> 00:18:59,439
これはchangesと
objectIDNotificationを与えます

290
00:19:03,710 --> 00:19:06,380
changesを見ていきましょう

291
00:19:06,680 --> 00:19:10,384
これらはデータベースに
挿入されているポストです

292
00:19:10,918 --> 00:19:12,619
このテーブルビューを見ると

293
00:19:12,719 --> 00:19:16,023
UIをリフレッシュ
したくなるでしょう

294
00:19:16,690 --> 00:19:20,094
objectIDNotificationで
それができます

295
00:19:20,194 --> 00:19:23,964
これらはNSManagedObjectContext
DidSave通知に類似し

296
00:19:24,064 --> 00:19:27,267
同じAPIを使ってマージされます

297
00:19:29,970 --> 00:19:33,207
ユーザアップデートに
現れてほしくないコメントを

298
00:19:33,307 --> 00:19:35,742
ダウンロードしてしまった場合は

299
00:19:36,910 --> 00:19:38,245
フィルタできます

300
00:19:40,047 --> 00:19:43,750
与えられたトランザクションから
changesをフィルタし

301
00:19:43,851 --> 00:19:46,753
ポストエンティティとの関連を
判断します

302
00:19:49,089 --> 00:19:51,725
これでUIの
リフレッシュを避け

303
00:19:51,859 --> 00:19:55,562
ユーザへの不要な負担を
回避できます

304
00:19:56,130 --> 00:20:00,767
ここではポストコンテンツを
少し使っているだけです

305
00:19:56,130 --> 00:20:00,767
ここではポストコンテンツを
少し使っているだけです

306
00:20:01,135 --> 00:20:04,238
具体的には
たった２つのプロパティです

307
00:20:04,338 --> 00:20:06,206
imageとtitleです

308
00:20:07,307 --> 00:20:10,244
エンティティによる
フィルタにとどまらず

309
00:20:10,344 --> 00:20:14,815
ヒストリーの変更を使い
updatedPropertiesでもフィルタ

310
00:20:14,915 --> 00:20:19,286
ユーザからも視認できて
ユーザ体験に的を絞った―

311
00:20:19,386 --> 00:20:22,256
アップデートを実現できるのです

312
00:20:25,759 --> 00:20:30,797
新たなインタラクションにも
Core Dataは役立ちます

313
00:20:31,231 --> 00:20:34,735
編集作業の中には
データ量が増えるほどに

314
00:20:34,835 --> 00:20:37,738
より多くのコストが
かかるものもあります

315
00:20:38,071 --> 00:20:40,807
シンプルなフォトブラウザを
例に取ります

316
00:20:41,108 --> 00:20:43,710
アプリケーションの規模が
大きくなるにつれ

317
00:20:43,811 --> 00:20:48,382
繰り返しのタスクを
より簡単に行いたくなるものです

318
00:20:48,482 --> 00:20:50,417
例えば複数選択などです

319
00:20:51,685 --> 00:20:55,189
Core Dataはバッチ処理で
これをサポートできます

320
00:20:55,889 --> 00:21:02,463
ほんの数行のコードで
写真を選別できるようになります

321
00:20:55,889 --> 00:21:02,463
ほんの数行のコードで
写真を選別できるようになります

322
00:21:03,831 --> 00:21:05,866
また コードを１行書けば

323
00:21:05,966 --> 00:21:09,937
データベースのレコードを
パージもしくは削除できます

324
00:21:10,571 --> 00:21:13,340
オブジェクトをメモリ上で
フォールトするよりも

325
00:21:13,440 --> 00:21:15,442
はるかにうまくいく処理です

326
00:21:15,809 --> 00:21:17,844
例えば削除する際

327
00:21:17,945 --> 00:21:21,315
NSManagedObject.deleteを呼び出す
従来の方法は

328
00:21:21,415 --> 00:21:24,718
データベースのレコードの
サイズに合わせて用いられます

329
00:21:24,818 --> 00:21:28,288
オブジェクトを削除し
メモリがフォールトされると

330
00:21:28,388 --> 00:21:32,392
コストは増え データベースも
大きくなっていきます

331
00:21:32,626 --> 00:21:35,929
しかし バッチ処理なら
わずかなメモリの中で

332
00:21:36,029 --> 00:21:38,065
同じ変化をもたらせます

333
00:21:38,265 --> 00:21:42,402
そしてデータが増加する時
望む曲線が得られます

334
00:21:42,503 --> 00:21:46,240
データが大きくなるほど
メモリは少なく済むのです

335
00:21:46,340 --> 00:21:51,378
1000万行で 従来の
削除時のメモリの７％程度です

336
00:21:52,446 --> 00:21:56,717
これはリソースの節約に
非常に役立つ手段です

337
00:21:58,185 --> 00:22:01,321
しかし バッチ処理の問題点は

338
00:21:58,185 --> 00:22:01,321
しかし バッチ処理の問題点は

339
00:22:01,488 --> 00:22:05,926
保存通知を作らないため
扱うのが難しいということです

340
00:22:06,293 --> 00:22:08,529
再びヒストリートラッキングの
出番です

341
00:22:08,929 --> 00:22:13,100
永続ヒストリートラッキングでは
バッチ処理を行う際に

342
00:22:13,200 --> 00:22:16,803
トランザクションを
データベースからフェッチできます

343
00:22:16,904 --> 00:22:19,239
objectIDNotificationを使い

344
00:22:19,339 --> 00:22:23,177
保存通知と同機能の
Notificationを生成できます

345
00:22:23,277 --> 00:22:27,915
こうして アプリケーション内の
フェッチ結果コントローラなどは

346
00:22:28,115 --> 00:22:30,984
それらの通知を
徐々にアップデートできます

347
00:22:33,620 --> 00:22:37,925
以上がCore Dataによる
増加するデータの管理方法です

348
00:22:38,759 --> 00:22:40,761
では実際のワークフローは？

349
00:22:40,861 --> 00:22:44,932
アプリケーションをビルドしたり
テストしたりする上で

350
00:22:45,032 --> 00:22:48,001
Core Dataは
どう役立つのでしょう？

351
00:22:49,136 --> 00:22:52,639
必ず今日から
あなたの助けになります

352
00:22:53,740 --> 00:22:56,643
NSKeyedArchiverは変化しています

353
00:22:56,944 --> 00:23:00,914
セキュアコーディングは
プラットフォーム全体に導入され

354
00:22:56,944 --> 00:23:00,914
セキュアコーディングは
プラットフォーム全体に導入され

355
00:23:01,014 --> 00:23:03,183
それをサポートする
NSKeyedArchiver APIも

356
00:23:03,283 --> 00:23:05,752
今年 劇的な変化を遂げています

357
00:23:06,386 --> 00:23:09,356
これは値変換の変化を意味します

358
00:23:09,456 --> 00:23:13,827
もし管理オブジェクトモデルの中に
変換可能なプロパティを持ち

359
00:23:13,927 --> 00:23:16,530
まだ値変換を送っていないなら

360
00:23:16,630 --> 00:23:20,033
値変換はNSKeyedUnarchive
FromDataTransformerが

361
00:23:20,134 --> 00:23:22,569
デフォルトになっています

362
00:23:22,803 --> 00:23:27,307
今後はNSSecureUnarchive
FromDataTransformerになります

363
00:23:27,474 --> 00:23:31,945
実装されるセキュアコーディングは
ぜひ導入すべきです

364
00:23:32,146 --> 00:23:36,583
これに関する講演が
今朝 実施されました

365
00:23:36,884 --> 00:23:38,452
“Data You Can Trust”です

366
00:23:38,552 --> 00:23:42,756
アプリケーションを
より障害に強くするために

367
00:23:42,856 --> 00:23:45,526
視聴することをお勧めします

368
00:23:48,161 --> 00:23:51,899
モデルエディタの中で
これを指定することもできます

369
00:23:52,733 --> 00:23:55,102
使うのはValue Transformer
Nameのフィールドです

370
00:23:55,602 --> 00:23:59,973
今は皆さん自身で
これを実装してほしいと思います

371
00:24:00,073 --> 00:24:02,609
これは将来
デフォルトになるでしょう

372
00:24:02,709 --> 00:24:05,579
また デフォルトのValue
Transformer Nameを使っていれば

373
00:24:05,679 --> 00:24:08,982
Xcodeで
警告が出るようにもなります

374
00:24:09,917 --> 00:24:11,852
コードでモデルをビルドするなら

375
00:24:11,952 --> 00:24:14,721
valueTransformerNameプロパティを

376
00:24:14,822 --> 00:24:16,723
NSAttributeDescription上で
使ってください

377
00:24:17,691 --> 00:24:20,160
カスタムクラスを
エンコードしていなければ

378
00:24:20,260 --> 00:24:22,062
これは透過的になるはずです

379
00:24:22,162 --> 00:24:24,565
plistタイプにとってはNOP命令です

380
00:24:24,665 --> 00:24:26,567
単純にValue Transformer Nameを
変えれば

381
00:24:26,667 --> 00:24:29,069
新しいセキュアコーディングの
動作を得られるでしょう

382
00:24:29,169 --> 00:24:31,672
しかし もしカスタムクラスを
実装しているなら

383
00:24:31,772 --> 00:24:34,174
それらのクラスには
セキュアコーディングが必要です

384
00:24:34,274 --> 00:24:37,277
ラボに来ていただければ
力になります

385
00:24:38,245 --> 00:24:40,848
さらに有用なことがあります

386
00:24:41,181 --> 00:24:42,916
私たちが注力してきたのは

387
00:24:43,016 --> 00:24:46,620
スタック下で何が起きているのかを
理解するのに役立つ―

388
00:24:46,720 --> 00:24:48,589
デバッグツールの開発です

389
00:24:48,922 --> 00:24:52,659
こちらはスキーム設定の画像です

390
00:24:52,759 --> 00:24:55,529
SQLiteのデバッグ情報が
増えるよう

391
00:24:55,629 --> 00:24:59,066
プロセスについて
議論を重ねています

392
00:24:59,166 --> 00:25:01,001
ここで非常に大事なのが

393
00:24:59,166 --> 00:25:01,001
ここで非常に大事なのが

394
00:25:01,101 --> 00:25:04,404
com.apple.CoreData.
ConcurrencyDebugです

395
00:25:04,505 --> 00:25:07,641
これはアプリケーションにおける
キューの例外を捉えます

396
00:25:07,741 --> 00:25:10,611
メインとバックグラウンドの
キューコンテキスト間で

397
00:25:10,711 --> 00:25:12,880
オブジェクトを移動させるエリア

398
00:25:12,980 --> 00:25:14,982
あるいは管理オブジェクトの
実際のコンテキストに

399
00:25:15,082 --> 00:25:17,618
従わないエリアなどです

400
00:25:18,619 --> 00:25:21,989
またSQLiteは興味深い環境変数を
多く有します

401
00:25:22,089 --> 00:25:24,057
それらのスレッドやアサーションは

402
00:25:24,157 --> 00:25:28,262
API周辺などにおける
アプリケーションの正確性に

403
00:25:28,362 --> 00:25:30,030
非常に役立つものです

404
00:25:30,430 --> 00:25:34,067
自動トレースはバックグラウンドの
動作を把握するための

405
00:25:34,167 --> 00:25:36,336
デバッグログ上の手段です

406
00:25:36,737 --> 00:25:39,139
com.apple.Core Data.
SQLDebugには

407
00:25:39,239 --> 00:25:40,908
４つの段階があります

408
00:25:41,008 --> 00:25:42,743
１つ目は最も興味深く

409
00:25:42,843 --> 00:25:45,712
パフォーマンスヒットは
最も小さくなります

410
00:25:45,812 --> 00:25:49,683
４つ目の段階は
最も詳細な状態ですが

411
00:25:49,783 --> 00:25:51,885
パフォーマンスヒットを
非常に大きくします

412
00:25:53,921 --> 00:25:57,524
SQLデバッグやマルチスレッドの
アサーションを有効にすると

413
00:25:57,624 --> 00:25:59,960
コンソール内に
ログを見ることができます

414
00:26:00,060 --> 00:26:03,630
これはアサーションが正常に
機能していることを示すものです

415
00:26:04,531 --> 00:26:06,934
SQLデバッグを有効にすると

416
00:26:07,034 --> 00:26:09,403
フェッチ要求のためのセレクト文や

417
00:26:09,503 --> 00:26:11,205
所要時間が見られます

418
00:26:11,605 --> 00:26:14,842
４つ目の段階では
“EXPLAIN”が得られます

419
00:26:14,942 --> 00:26:17,244
それは与えられた
セレクト文のための

420
00:26:17,344 --> 00:26:19,379
クエリプランを示します

421
00:26:19,479 --> 00:26:24,384
ここではテーブルスキャンを通して
テーブルビューが選択されています

422
00:26:24,484 --> 00:26:27,054
タイムスタンプ上の
ORDER BY用に

423
00:26:27,154 --> 00:26:29,990
メモリ内の一時的なB-treeを
使っています

424
00:26:30,424 --> 00:26:32,593
これは潜在的な
パフォーマンスの問題です

425
00:26:32,693 --> 00:26:36,430
アプリケーションを動かす際は
こうしたメッセージを利用して

426
00:26:36,530 --> 00:26:39,500
ムダのある箇所を確認できます

427
00:26:40,267 --> 00:26:41,802
修正の方法は？

428
00:26:42,870 --> 00:26:43,604
答えは

429
00:26:44,471 --> 00:26:47,040
SQLite 3にあります

430
00:26:47,407 --> 00:26:51,612
データベースを開き SQLログから
セレクトクエリを渡せば

431
00:26:51,879 --> 00:26:53,914
エキスパートモードを
有効にできます

432
00:26:54,214 --> 00:26:57,718
これはクエリを分析して
カバリングインデックスを作り

433
00:26:57,818 --> 00:27:00,621
最適なソリューションを
与えてくれます

434
00:26:57,818 --> 00:27:00,621
最適なソリューションを
与えてくれます

435
00:27:01,255 --> 00:27:03,323
モデルエディタの中で行うには

436
00:27:03,757 --> 00:27:06,727
ポストエンティティに
フェッチインデックスを加えます

437
00:27:07,094 --> 00:27:10,764
タイムスタンプ上で
実行できるように設定し

438
00:27:11,064 --> 00:27:12,199
降順にフェッチ

439
00:27:12,299 --> 00:27:15,836
一番最近のポストを テーブルの
トップに表示しているからです

440
00:27:17,905 --> 00:27:21,375
アプリケーションを再び実行すると
同じセレクトログが見られます

441
00:27:24,645 --> 00:27:26,079
今回はセレクトクエリが

442
00:27:26,180 --> 00:27:29,917
カバリングインデックスを
クエリの際にヒットしています

443
00:27:30,017 --> 00:27:34,721
クエリはORDER BY用に
カバリングインデックスを使います

444
00:27:38,458 --> 00:27:40,527
R-treeを使う複合インデックスなど

445
00:27:40,627 --> 00:27:43,764
様々な型のインデックスを
サポートしています

446
00:27:43,864 --> 00:27:44,998
様々なクエリを生成したり

447
00:27:45,099 --> 00:27:50,037
セレクト文内で境界ボックスを使う
クエリを最適化したりする上で

448
00:27:50,137 --> 00:27:51,805
これらは非常に有効です

449
00:27:52,072 --> 00:27:54,074
通常 ロケーションに応じて行われ

450
00:27:54,174 --> 00:27:58,111
他のインデックスを
ポストエンティティに加え設定

451
00:27:58,212 --> 00:28:02,883
latitudeやlongitudeの中で
機能するインデックスです

452
00:27:58,212 --> 00:28:02,883
latitudeやlongitudeの中で
機能するインデックスです

453
00:28:04,718 --> 00:28:08,589
R-treeを選択して
ボックス内のクエリタイプを変更

454
00:28:09,823 --> 00:28:12,860
するとフェッチ要求上に
述語を加えることができます

455
00:28:13,126 --> 00:28:16,897
“中国大陸内で起こる
全てのポストを得よ”と

456
00:28:18,332 --> 00:28:22,336
この述語は セレクト文の中で
関数を使っているため

457
00:28:22,436 --> 00:28:25,272
少し高度なものになっています

458
00:28:25,372 --> 00:28:28,976
管理オブジェクトモデル内の
インデックスをヒットするためです

459
00:28:31,778 --> 00:28:36,016
この述語やインデックスなしに
アプリケーションを実行する場合も

460
00:28:36,116 --> 00:28:38,519
同じ結果を見ることができます

461
00:28:38,619 --> 00:28:42,089
そこではタイムスタンプの
インデックスだけがヒットされます

462
00:28:43,423 --> 00:28:46,527
一方 実行に
新しいインデックスと述語を使う時

463
00:28:46,627 --> 00:28:49,730
SQLiteは そのインデックスを使い
間にあるコードに対し

464
00:28:49,830 --> 00:28:53,267
より速い結果を生成します

465
00:28:54,902 --> 00:28:57,604
ただ タイムスタンプの
インデックスは

466
00:28:57,704 --> 00:28:59,773
境界を作る述語を
１つも持たないため

467
00:28:59,873 --> 00:29:02,242
SQLiteはそれを
ソートに使えません

468
00:28:59,873 --> 00:29:02,242
SQLiteはそれを
ソートに使えません

469
00:29:03,510 --> 00:29:06,313
そこで選んだ最適化の方法は
複合インデックスを使い

470
00:29:06,413 --> 00:29:10,884
まず結果セットを
小さなオブジェクトのセットに変え

471
00:29:10,984 --> 00:29:14,121
ORDER BY用にインメモリで
B-treeをソートすることです

472
00:29:16,223 --> 00:29:18,559
ご覧のように このインデックスは

473
00:29:18,659 --> 00:29:22,529
フェッチのパフォーマンスを
約25％向上させます

474
00:29:23,864 --> 00:29:28,635
このケースでは性能テストを
10万行以上にわたり行ったところ

475
00:29:28,735 --> 00:29:33,307
フェッチだけで
約130ミリ秒の改善が見られました

476
00:29:34,608 --> 00:29:37,811
ここでCore Dataの
テストの話に移りましょう

477
00:29:38,545 --> 00:29:42,783
ご存じかもしれませんが
私たちはテストが大好きです

478
00:29:42,883 --> 00:29:44,384
Core Dataでは

479
00:29:44,484 --> 00:29:48,722
正確性と学習性の両方の観点で
テストを行います

480
00:29:48,822 --> 00:29:54,595
Core Dataの機能や
APIの動作を確認する上で重要です

481
00:29:55,229 --> 00:30:00,234
また Core Dataの機能に関し
仮説を検証する上でも有効です

482
00:29:55,229 --> 00:30:00,234
また Core Dataの機能に関し
仮説を検証する上でも有効です

483
00:30:00,334 --> 00:30:03,971
よりよい顧客体験のための
手助けとなるのです

484
00:30:04,271 --> 00:30:08,642
R-treeインデックスは たとえ
インメモリでB-treeをソートしても

485
00:30:08,742 --> 00:30:12,446
パフォーマンスに
恩恵をもたらします

486
00:30:14,481 --> 00:30:18,652
テストは動作環境を
把握する上でも大切です

487
00:30:18,752 --> 00:30:22,589
皆さんが何を求めているかが
分かるからです

488
00:30:22,689 --> 00:30:26,460
皆さんが顧客のために
どんな動作を望んでいるのかは

489
00:30:26,560 --> 00:30:28,862
テストで明らかにできます

490
00:30:29,596 --> 00:30:33,233
これを自力で簡単に行うために
重要なものがあります

491
00:30:33,700 --> 00:30:37,571
例えば永続コンテナを生成する
ベースクラスなどです

492
00:30:38,338 --> 00:30:39,706
こちらのベースクラスは

493
00:30:39,807 --> 00:30:44,044
たまたま永続ストア用の
/dev/nullのURLを使っています

494
00:30:44,144 --> 00:30:48,015
これによりテストは 小さな
管理オブジェクトのセット上で

495
00:30:48,115 --> 00:30:50,017
非常に素早く行われます

496
00:30:50,117 --> 00:30:52,386
全てメモリの中で
行われるからです

497
00:30:52,653 --> 00:30:57,057
この時 SQLiteは
インメモリストアを実現させます

498
00:30:57,157 --> 00:30:59,927
非常に効率的ですが
インメモリなので

499
00:31:00,027 --> 00:31:03,831
データ量次第ではテストスイートの
メモリを増大させてしまいます

500
00:31:07,835 --> 00:31:10,938
ストアファイルをディスク上に
具現化するテストは

501
00:31:11,038 --> 00:31:13,841
少なくとも１回は実行すべきです

502
00:31:14,274 --> 00:31:17,344
皆さんがテストスイート用の
ストアを開けない場合

503
00:31:17,444 --> 00:31:19,746
顧客もそれを開けない可能性が
高いからです

504
00:31:20,948 --> 00:31:23,851
アプリケーションデリゲート内に
永続コンテナがあるのなら

505
00:31:23,951 --> 00:31:26,553
コンテナを取り上げ ストアに
直接書き込める―

506
00:31:26,653 --> 00:31:28,789
テストベースクラスを持てます

507
00:31:29,189 --> 00:31:32,559
しかしその場合 皆さんが
書き込んでいるストアファイルは

508
00:31:32,659 --> 00:31:36,797
アプリケーションによって
使用されているため注意が必要です

509
00:31:36,897 --> 00:31:39,466
もし 個人のデバイスで
テストを実行するなら

510
00:31:39,566 --> 00:31:43,437
次にアプリケーションを開いた時
その効果が分かるでしょう

511
00:31:47,441 --> 00:31:51,545
10万件のレコードを７行のコードで
挿入できるとしたら？

512
00:31:53,747 --> 00:31:57,684
これは練習問題として
あとに取っておくつもりでしたが

513
00:31:57,785 --> 00:32:00,854
こうしたスキャフォールディングが
可能にするのは

514
00:31:57,785 --> 00:32:00,854
こうしたスキャフォールディングが
可能にするのは

515
00:32:00,954 --> 00:32:04,358
データ回りの不変性を評価する
テストスイートの構築です

516
00:32:04,958 --> 00:32:08,095
これらのメソッドを
前もってビルドしておくことで

517
00:32:08,195 --> 00:32:12,966
例えばデータが変化した際も
繰り返し使うことができます

518
00:32:13,066 --> 00:32:16,470
オブジェクトグラフ用の仕組みや
新しいエッジクラスをビルドしたり

519
00:32:16,570 --> 00:32:20,174
パフォーマンスなど
バックグラウンドの特定の動作を

520
00:32:20,607 --> 00:32:22,142
評価したりするためです

521
00:32:23,710 --> 00:32:28,749
R-treeクエリの性能テストで使った
単体テストのスキャフォールドです

522
00:32:29,083 --> 00:32:30,651
フェッチのパフォーマンスは

523
00:32:30,751 --> 00:32:34,188
数行のコードで
確実なものにできます

524
00:32:34,721 --> 00:32:38,759
Core Dataの特徴や機能間の
トレードオフを評価する上で

525
00:32:38,859 --> 00:32:41,795
こうしたテストは非常に役立ちます

526
00:32:45,232 --> 00:32:48,302
この３行のコードが生成するのは
テストで使うための

527
00:32:48,402 --> 00:32:51,205
新しい管理オブジェクト
コンテキストと コンテナです

528
00:32:51,638 --> 00:32:54,041
これは極めて重要です

529
00:32:54,141 --> 00:32:56,910
テストにおけるセットアップと
テアダウンのロジックは

530
00:32:57,010 --> 00:32:59,413
時にそのパフォーマンスに
影響を及ぼすからです

531
00:32:59,580 --> 00:33:02,449
自分が今 テストしているのは

532
00:32:59,580 --> 00:33:02,449
自分が今 テストしているのは

533
00:33:02,549 --> 00:33:06,019
テアダウンのパフォーマンスか
セットアップのパフォーマンスか

534
00:33:06,120 --> 00:33:09,423
クエリのランタイムかなど
分析しましょう

535
00:33:10,424 --> 00:33:14,361
テストが終わると
バグを報告できます

536
00:33:15,429 --> 00:33:16,630
バグは大歓迎です

537
00:33:16,730 --> 00:33:20,934
よりよいアプリケーションのために
必要なものですからね

538
00:33:21,101 --> 00:33:23,504
しかし バグの報告にあたり

539
00:33:23,604 --> 00:33:27,274
テストやサンプルAppがないと
対処が非常に困難です

540
00:33:27,374 --> 00:33:31,879
先ほど話したように
皆さんの動作環境や要望は

541
00:33:31,979 --> 00:33:34,748
緻密なテストによってこそ
正確に把握できます

542
00:33:35,249 --> 00:33:39,119
実際 テストスイートを有する
アプリケーションや

543
00:33:39,219 --> 00:33:43,657
皆さんの懸念事項が明確な
サンプルがあるだけで

544
00:33:43,991 --> 00:33:47,861
私たちは
いち早くレスポンスできます

545
00:33:47,961 --> 00:33:52,933
そして対処法を
お伝えすることができるのです

546
00:33:53,500 --> 00:33:56,837
またテストは 修復の正確性の
検証にも役立ちます

547
00:33:56,937 --> 00:34:01,942
バグ報告の際は まずはテストを
書くようにしてください

548
00:33:56,937 --> 00:34:01,942
バグ報告の際は まずはテストを
書くようにしてください

549
00:34:04,545 --> 00:34:05,846
本日は以上です

550
00:34:06,880 --> 00:34:12,319
明日はTechnology Lab 7にて
１時半からお待ちしています

551
00:34:12,418 --> 00:34:17,891
明日のTesting Tips & Tricksも
ぜひご覧ください

552
00:34:19,226 --> 00:34:19,960
ありがとう

553
00:34:20,060 --> 00:34:22,562
(拍手)