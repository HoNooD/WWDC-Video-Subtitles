
1
00:00:07,040 --> 00:00:16,550
(音楽)

2
00:00:16,683 --> 00:00:23,423
(拍手)

3
00:00:23,524 --> 00:00:26,827
ご来場ありがとうございます

4
00:00:27,194 --> 00:00:30,597
これから40分間 私デイブが

5
00:00:30,697 --> 00:00:36,136
私たちのプログラムが動く
仕組みをお話しします

6
00:00:36,670 --> 00:00:42,342
ただし 技術的なヒントや
特定のアルゴリズムが

7
00:00:42,442 --> 00:00:46,180
この話の主題ではありません

8
00:00:47,047 --> 00:00:51,451
目的は コードに内在する
根幹的なものを

9
00:00:51,552 --> 00:00:53,654
明らかにすることです

10
00:00:55,222 --> 00:00:59,693
プログラミングとの
新たな関係性を―

11
00:00:59,793 --> 00:01:01,428
提供できれば幸いです

12
00:00:59,793 --> 00:01:01,428
提供できれば幸いです

13
00:01:02,095 --> 00:01:04,798
このアプローチの発見で

14
00:01:04,897 --> 00:01:07,868
私のキャリアに転機が訪れました

15
00:01:08,335 --> 00:01:13,307
私がソフトウェアライブラリを
重視する理由であり

16
00:01:13,407 --> 00:01:19,780
コードの信頼性 保守性
パフォーマンスにもつながります

17
00:01:20,747 --> 00:01:24,785
本題の前に
友人を１人ご紹介しましょう

18
00:01:26,854 --> 00:01:29,423
“クラスティ”です

19
00:01:29,523 --> 00:01:31,925
(拍手)

20
00:01:32,025 --> 00:01:34,795
彼は古いタイプの人間で

21
00:01:34,895 --> 00:01:40,501
デバッガを信用せず
統合開発環境には目も向けません

22
00:01:40,701 --> 00:01:46,773
彼が好むのは80文字24行の
ターミナルウィンドウです

23
00:01:47,541 --> 00:01:51,378
現代の流れに逆らう
彼のような人物を

24
00:01:51,478 --> 00:01:55,482
21世紀に引きずり込むのは大変です

25
00:01:56,049 --> 00:01:57,985
考え方が違います

26
00:01:58,552 --> 00:02:02,389
ただ 学べる点もいくつかあります

27
00:01:58,552 --> 00:02:02,389
ただ 学べる点もいくつかあります

28
00:02:03,490 --> 00:02:06,660
例えば 彼はこう言います

29
00:02:06,894 --> 00:02:11,031
“プログラミングは
真実を解き明かす”

30
00:02:11,398 --> 00:02:15,736
これを理解するため
コードを書いてみました

31
00:02:17,404 --> 00:02:20,507
“Shapes”というプログラムです

32
00:02:21,575 --> 00:02:24,878
今は形状の配置機能だけですが

33
00:02:24,978 --> 00:02:29,249
将来的に描画機能の追加も
目指しています

34
00:02:30,317 --> 00:02:33,887
まず注目するのは
“選択を削除”コマンド

35
00:02:33,987 --> 00:02:38,659
この実装を通じて
私は多くを学びました

36
00:02:39,326 --> 00:02:42,095
配列からの削除を学ぶ際

37
00:02:42,196 --> 00:02:47,267
恐らく皆さんも
似た経験をしたことでしょう

38
00:02:47,701 --> 00:02:50,804
大抵は こんな風に始めます

39
00:02:53,807 --> 00:02:55,709
これが削除です

40
00:02:58,946 --> 00:03:00,914
ループで０から数え

41
00:02:58,946 --> 00:03:00,914
ループで０から数え

42
00:03:02,316 --> 00:03:05,752
目的の位置で
“削除”を呼び出します

43
00:03:06,086 --> 00:03:08,856
そしてループが続いて…

44
00:03:09,122 --> 00:03:10,157
おっと

45
00:03:10,791 --> 00:03:12,159
問題発生です

46
00:03:13,260 --> 00:03:17,431
反復回数より
配列が短くなってしまいました

47
00:03:17,798 --> 00:03:23,570
幸い Swiftのテストで
このバグは発見できます

48
00:03:23,837 --> 00:03:29,376
しかしＣ言語だと
そう簡単にはいかないでしょう

49
00:03:29,843 --> 00:03:35,549
これを修正する場合
forループをwhileループにし

50
00:03:35,649 --> 00:03:38,418
各反復でカウントを調べます

51
00:03:39,720 --> 00:03:43,090
しかし これにもバグはあります

52
00:03:43,857 --> 00:03:49,363
隣り合う２つの要素を選択し
１つ目を削除すると―

53
00:03:50,664 --> 00:03:53,033
続く要素が移動します

54
00:03:54,334 --> 00:03:57,371
このバグは少し厄介です

55
00:03:57,471 --> 00:04:01,308
テストを実行しない限り
見つかりません

56
00:03:57,471 --> 00:04:01,308
テストを実行しない限り
見つかりません

57
00:04:02,843 --> 00:04:05,279
運良く気付けた場合

58
00:04:05,412 --> 00:04:10,984
インクリメントを
elseブロックで囲み修正します

59
00:04:12,586 --> 00:04:16,857
これで本当に
うまくいったでしょうか？

60
00:04:17,591 --> 00:04:21,261
恐らく問題なく動くはずです

61
00:04:21,762 --> 00:04:25,532
これで試練を１つ乗り越えました

62
00:04:25,632 --> 00:04:29,269
この９行を頭にたたき込めば

63
00:04:29,369 --> 00:04:32,773
将来 削除をする時に使えます

64
00:04:33,974 --> 00:04:38,045
ただ 異論のある人もいるでしょう

65
00:04:38,145 --> 00:04:41,315
もっといい方法がありますからね

66
00:04:41,715 --> 00:04:44,885
いったん この方法を見つければ

67
00:04:44,985 --> 00:04:48,789
前の９行は もう必要ありません

68
00:04:49,556 --> 00:04:53,727
反復制限と次のアイテムの
インデックスは

69
00:04:53,827 --> 00:04:57,531
“remove(at: i)”により
常に変わります

70
00:04:57,631 --> 00:05:01,468
ｉのあとの配列の一部が
変わるからです

71
00:04:57,631 --> 00:05:01,468
ｉのあとの配列の一部が
変わるからです

72
00:05:03,904 --> 00:05:09,243
でも後ろ向きなら
未変更の配列の反復で済みます

73
00:05:09,943 --> 00:05:14,314
この方法なら
不具合も起こらないので

74
00:05:14,448 --> 00:05:17,251
私は愛用してきました

75
00:05:18,352 --> 00:05:19,887
でも数ヵ月前―

76
00:05:21,255 --> 00:05:25,626
アプリケーションを
いじっていた時のことです

77
00:05:25,726 --> 00:05:32,065
複雑なキャンバスから
図形の半分を削除しようとしたら

78
00:05:33,000 --> 00:05:36,703
iPadが３秒ほどフリーズしました

79
00:05:37,938 --> 00:05:42,910
私はサーマルカップに入れた
ラテを飲みながら

80
00:05:43,010 --> 00:05:46,346
取り得る選択肢を考えました

81
00:05:47,548 --> 00:05:51,485
コードはクリーンで
処理も単純なのに

82
00:05:51,585 --> 00:05:54,688
何が悪かったのでしょうか？

83
00:05:56,390 --> 00:05:59,760
調べると
ホットスポットはここです

84
00:06:00,494 --> 00:06:02,429
私は困りました

85
00:06:03,730 --> 00:06:08,468
その時 コーヒー豆を抱えた
クラスティが現れ

86
00:06:08,569 --> 00:06:11,939
こう聞いてきたんです

87
00:06:12,773 --> 00:06:14,842
“お手上げか？”

88
00:06:15,943 --> 00:06:19,513
私はうなずき 状況を説明しました

89
00:06:22,549 --> 00:06:26,086
“関連のドキュメンテーションは
見たのか？”

90
00:06:27,721 --> 00:06:33,227
私は“remove(at:)”の
クイックヘルプを見てみました

91
00:06:34,561 --> 00:06:36,530
“ほら 問題はそこだ”

92
00:06:37,865 --> 00:06:41,368
と言って 画面に
指紋を付けてきました

93
00:06:44,304 --> 00:06:48,976
私は その指紋を
クロスで拭き取りました

94
00:06:50,344 --> 00:06:53,747
“どうだ 分かったか？”

95
00:06:54,982 --> 00:06:56,350
私は答えました

96
00:06:56,617 --> 00:07:00,220
“配列の長さに比例した
ステップ数が―”

97
00:06:56,617 --> 00:07:00,220
“配列の長さに比例した
ステップ数が―”

98
00:07:00,320 --> 00:07:02,856
“要素の削除には必要だ”

99
00:07:03,357 --> 00:07:07,928
配列では後続の要素は
新たな位置に動くので

100
00:07:08,028 --> 00:07:09,663
理にかないます

101
00:07:11,231 --> 00:07:15,335
“そのことと
選択を削除との関連性は？”

102
00:07:16,069 --> 00:07:17,971
私は考えます

103
00:07:20,374 --> 00:07:24,444
彼はのど飴を取り出し
並べ始めました

104
00:07:24,678 --> 00:07:25,979
“試してみろ”

105
00:07:27,047 --> 00:07:30,717
“選択を削除”では
選択した要素ごとに

106
00:07:30,818 --> 00:07:33,587
O(n)の処理を行います

107
00:07:33,687 --> 00:07:37,057
選択できるのはｎ個までの要素で

108
00:07:37,157 --> 00:07:41,261
ステップ総数はｎの２乗に
比例します

109
00:07:42,496 --> 00:07:45,065
クラスティは付け加えます

110
00:07:45,165 --> 00:07:49,169
“順方向でも逆方向でも
それは二次式だ”

111
00:07:52,005 --> 00:07:56,944
要素の数が10から20の
小さなテストの場合

112
00:07:57,044 --> 00:07:59,780
ステップ数は数百のみです

113
00:07:59,880 --> 00:08:03,250
速さも申し分ありません

114
00:07:59,880 --> 00:08:03,250
速さも申し分ありません

115
00:08:04,051 --> 00:08:06,620
問題は数が増えた時です

116
00:08:07,788 --> 00:08:12,292
50の２乗は2500
100の２乗なら１万

117
00:08:13,627 --> 00:08:19,132
テストが左下の小さな範囲内なら
問題はないでしょう

118
00:08:19,233 --> 00:08:24,338
しかし 人々が管理する
データ量は増え続けており

119
00:08:24,438 --> 00:08:29,943
それに伴い デバイスの
メモリ容量も増えています

120
00:08:30,511 --> 00:08:35,682
予測されるニーズにとって
スケーラビリティは重要です

121
00:08:37,818 --> 00:08:43,123
問題は分かりましたが
どう対応すべきでしょうか？

122
00:08:43,222 --> 00:08:47,261
クラスティは
飴を口に入れながら言います

123
00:08:47,361 --> 00:08:51,131
“そのためのアルゴリズムがある”

124
00:08:53,267 --> 00:08:57,571
しかし私はアプリケーションの
デベロッパです

125
00:08:58,105 --> 00:09:03,043
アルゴリズムのことは
専門外になります

126
00:08:58,105 --> 00:09:03,043
アルゴリズムのことは
専門外になります

127
00:09:03,143 --> 00:09:06,180
アルゴリズムのデータ構造も

128
00:09:06,280 --> 00:09:11,151
仕事の面接対策で
勉強した程度にすぎません

129
00:09:11,251 --> 00:09:15,989
実際のプログラミングで
新人と一流を分けるのは

130
00:09:16,089 --> 00:09:21,195
コントローラなどをまとめ
システムを作る能力です

131
00:09:22,896 --> 00:09:26,033
“間抜けめ”と彼は言いました

132
00:09:27,401 --> 00:09:29,036
“コンピュータの仕事は？”

133
00:09:30,037 --> 00:09:30,871
計算です

134
00:09:31,672 --> 00:09:34,007
“どこに計算の方法が？”

135
00:09:35,576 --> 00:09:40,848
私のコードに
アルゴリズムは見当たりません

136
00:09:42,082 --> 00:09:43,617
彼は否定します

137
00:09:43,784 --> 00:09:49,356
“そんなことはない
この辞書で意味を調べてみろ”

138
00:09:51,158 --> 00:09:53,660
私は辞書を脇によけ

139
00:09:53,827 --> 00:10:00,167
“アルゴリズムの定義”と
Spotlightに入力しました

140
00:09:53,827 --> 00:10:00,167
“アルゴリズムの定義”と
Spotlightに入力しました

141
00:10:04,171 --> 00:10:10,944
“演算手続き･問題解決の
プロセスまたは一連のルール”

142
00:10:11,979 --> 00:10:17,317
確かにコードに似ていますが
確証は持てません

143
00:10:17,951 --> 00:10:21,889
“筆算だってアルゴリズムだ”
彼は言います

144
00:10:25,626 --> 00:10:30,097
再びSpotlightに入力しかかると
“紙に！”と言われ

145
00:10:30,197 --> 00:10:33,901
困って 話題をコードに戻しました

146
00:10:36,470 --> 00:10:37,504
では―

147
00:10:38,305 --> 00:10:43,177
どんなアルゴリズムが
私の問題を解決できますか？

148
00:10:44,044 --> 00:10:47,481
“手本を見せる
お前のマシンを貸せ”

149
00:10:47,581 --> 00:10:50,984
“トラックパッドをオフにして…”

150
00:10:51,084 --> 00:10:54,354
“まずは この役立たずを消す”

151
00:10:56,590 --> 00:11:02,563
“そしてshapes.removeAll…と
入力”

152
00:10:56,590 --> 00:11:02,563
“そしてshapes.removeAll…と
入力”

153
00:11:03,096 --> 00:11:05,599
“さあ これで試してみろ”

154
00:11:06,133 --> 00:11:09,503
クラスティは席を離れました

155
00:11:09,603 --> 00:11:13,540
私にコードを検証させるためです

156
00:11:14,875 --> 00:11:20,614
調べてみると コードの問題は
解決されていました

157
00:11:21,548 --> 00:11:25,419
次に 私はクイックヘルプを開き

158
00:11:25,519 --> 00:11:28,522
“removeAll(where:)”を
調べました

159
00:11:30,157 --> 00:11:35,662
“remove(at:)”のように
計算量はコレクションの長さに

160
00:11:35,762 --> 00:11:37,431
比例するようです

161
00:11:37,698 --> 00:11:40,634
でもループには入れないので

162
00:11:40,901 --> 00:11:43,704
これが すべての処理の計算量です

163
00:11:44,471 --> 00:11:49,042
これがもたらす
違いの一部をご紹介しましょう

164
00:11:50,444 --> 00:11:56,517
ｎが意味する アルゴリズムの
実行時間と問題のサイズは

165
00:11:56,617 --> 00:11:58,318
線形比例します

166
00:11:59,286 --> 00:12:02,456
オレンジはｎの２乗の線です

167
00:11:59,286 --> 00:12:02,456
オレンジはｎの２乗の線です

168
00:12:03,257 --> 00:12:07,494
一次のアルゴリズムは
小さな問題では効率が悪く

169
00:12:07,594 --> 00:12:10,898
徐々に二次よりも高くなります

170
00:12:11,798 --> 00:12:17,771
ちなみに一次のアルゴリズムの
コストがいくら高くても

171
00:12:18,205 --> 00:12:21,241
それは問題ではありません

172
00:12:22,142 --> 00:12:28,515
問題のサイズが大きくなれば
ある点以降 一次が常に上回ります

173
00:12:29,216 --> 00:12:33,420
なお これは
スケーラビリティの話です

174
00:12:36,356 --> 00:12:41,094
さて スケーラビリティの問題は
解決しましたが

175
00:12:41,195 --> 00:12:46,934
逆方向の削除に対して
標準ライブラリはどう改善するのか？

176
00:12:47,901 --> 00:12:51,471
Swiftはオープンソースなので

177
00:12:51,572 --> 00:12:55,609
GitHubからデータを引き出せます

178
00:12:59,146 --> 00:13:02,182
目に付くのはコメントの部分です

179
00:12:59,146 --> 00:13:02,182
目に付くのはコメントの部分です

180
00:13:02,549 --> 00:13:04,885
クイックヘルプのソースで

181
00:13:04,985 --> 00:13:09,556
アルゴリズムの動きと計算量を
記述しています

182
00:13:11,325 --> 00:13:17,264
次に“removeAll(where:)”は
単なるメソッドではありません

183
00:13:17,664 --> 00:13:19,500
汎用アルゴリズムで

184
00:13:19,600 --> 00:13:23,437
他のコレクションでも動作します

185
00:13:24,171 --> 00:13:26,206
主な機能は次の２つ

186
00:13:27,074 --> 00:13:30,777
要素を並べ替える
“MutableCollection”と

187
00:13:31,011 --> 00:13:38,085
長さと構造を変える
“RangeReplaceableCollection”

188
00:13:39,620 --> 00:13:43,590
ベースは複数の
O(n)アルゴリズムです

189
00:13:43,891 --> 00:13:46,994
１つ目は
“halfStablePartition”

190
00:13:47,094 --> 00:13:51,231
ある述語を満たす要素を
後ろに移動し―

191
00:13:52,900 --> 00:13:55,235
接尾辞の先頭を示します

192
00:13:56,036 --> 00:13:59,873
“halfStable”は
“半安定”という意味です

193
00:13:59,973 --> 00:14:04,144
動かない要素の順序は保持しますが

194
00:13:59,973 --> 00:14:04,144
動かない要素の順序は保持しますが

195
00:14:04,344 --> 00:14:07,748
後ろに移動する要素は入れ換えます

196
00:14:09,082 --> 00:14:15,489
次の“removeSubrange”は
場合により下位範囲を削除します

197
00:14:16,690 --> 00:14:19,092
部分範囲の表記は

198
00:14:20,093 --> 00:14:24,498
コレクションの終わりの範囲を
記すのに便利です

199
00:14:26,800 --> 00:14:32,239
“removeSubrange”は
パブリックAPIの一部ですが

200
00:14:32,339 --> 00:14:38,078
“halfStablePartition”は
実装の詳細になります

201
00:14:41,081 --> 00:14:45,519
ここでは 一部だけを
取り上げます

202
00:14:46,420 --> 00:14:51,692
まず 接尾辞の先頭の要素の
位置を検索する―

203
00:14:51,825 --> 00:14:56,296
“firstIndex(where:)”を
呼び出します

204
00:14:57,097 --> 00:14:59,333
ループ変数をｊに設定

205
00:14:59,433 --> 00:15:02,402
ループインデックスｊが

206
00:14:59,433 --> 00:15:02,402
ループインデックスｊが

207
00:15:02,970 --> 00:15:07,040
反復ごとに１つを前に動かします

208
00:15:07,541 --> 00:15:11,111
ｊが要素を１回 通過するわけです

209
00:15:12,679 --> 00:15:15,782
順序と計算量が見てとれます

210
00:15:20,420 --> 00:15:26,059
最後に このメソッドは
長さを変えず要素を再配置するため

211
00:15:26,159 --> 00:15:29,163
可変コレクションの
適合性に依存します

212
00:15:31,031 --> 00:15:33,100
これが私の学んだ―

213
00:15:33,534 --> 00:15:36,603
Swiftの標準ライブラリです

214
00:15:37,070 --> 00:15:39,506
性能特性が文書化された―

215
00:15:39,640 --> 00:15:42,676
一連のアルゴリズムが
含まれています

216
00:15:43,310 --> 00:15:46,213
実装についても触れましたが

217
00:15:46,847 --> 00:15:51,318
それなしでも使えるよう
設計されています

218
00:15:52,319 --> 00:15:58,392
ライブラリを効率的に使うには
公式ドキュメントが便利です

219
00:15:58,892 --> 00:16:01,261
“Playground”の解説もあります

220
00:15:58,892 --> 00:16:01,261
“Playground”の解説もあります

221
00:16:01,795 --> 00:16:05,799
内容が盛りだくさんで
大変に見えますが

222
00:16:06,066 --> 00:16:08,101
全部 覚えなくても大丈夫

223
00:16:08,569 --> 00:16:13,106
内容に触れて知るだけで
次につながります

224
00:16:14,608 --> 00:16:16,944
最後に クラスティによる

225
00:16:17,477 --> 00:16:20,647
別の教えも紹介しましょう

226
00:16:21,048 --> 00:16:24,117
左右どちらが簡潔明快ですか？

227
00:16:25,152 --> 00:16:29,490
左の場合 読んで
考える必要があります

228
00:16:29,957 --> 00:16:32,125
コメントも加えましょう

229
00:16:32,693 --> 00:16:37,698
ただ コメントを付けても
逆順の反復は厄介です

230
00:16:37,798 --> 00:16:42,836
他の人も触れるよう
さらに説明を加えましょう

231
00:16:45,105 --> 00:16:46,006
一方で―

232
00:16:46,106 --> 00:16:51,879
右のコードは末尾クロージャで
より明快です

233
00:16:53,547 --> 00:16:55,649
では 再びご覧ください

234
00:16:56,483 --> 00:16:58,819
どちらが正しいですか？

235
00:16:59,386 --> 00:17:02,723
左はコメントが付いていても

236
00:16:59,386 --> 00:17:02,723
左はコメントが付いていても

237
00:17:02,823 --> 00:17:07,361
比べると 右の方が
ずっと効率的に見えます

238
00:17:07,961 --> 00:17:11,298
アルゴリズムを使ったおかげです

239
00:17:13,599 --> 00:17:18,806
ショーン･ペアレントは
コードの指針を提案しました

240
00:17:19,506 --> 00:17:23,343
“ループは アルゴリズムの
呼び出しで置き換える”

241
00:17:23,743 --> 00:17:28,982
“ない場合は自作し
そのアルゴリズムにループを移す”

242
00:17:30,851 --> 00:17:33,821
その意味を理解いただけるよう

243
00:17:33,921 --> 00:17:37,291
さらに説明を続けたいと思います

244
00:17:37,925 --> 00:17:40,727
そこで 皆さんが最後に見た―

245
00:17:40,828 --> 00:17:43,931
スパゲッティコードを
思い出してください

246
00:17:45,265 --> 00:17:48,602
ループだらけ？　でしょうね

247
00:17:50,904 --> 00:17:52,272
では こちらを

248
00:17:52,372 --> 00:17:57,077
速度も簡潔さも勝るコードを
書いてみました

249
00:17:57,377 --> 00:18:01,148
私はクラスティに礼を言い―

250
00:17:57,377 --> 00:18:01,148
私はクラスティに礼を言い―

251
00:18:01,248 --> 00:18:06,019
仕事を切り上げて
帰り支度を始めました

252
00:18:06,120 --> 00:18:09,223
しかし 彼は疑念の目を向けます

253
00:18:09,323 --> 00:18:12,793
“とんでもないミスをしてるぞ”

254
00:18:14,027 --> 00:18:19,099
私は帰るのを諦め
コードのループを探し始めます

255
00:18:19,967 --> 00:18:22,536
ファイルのコマンドは―

256
00:18:24,304 --> 00:18:25,372
最前面に移動

257
00:18:27,107 --> 00:18:28,208
最背面に移動

258
00:18:29,810 --> 00:18:33,781
選択した図形を１つ前面に移動

259
00:18:34,715 --> 00:18:36,450
繰り返しましょう

260
00:18:38,252 --> 00:18:42,389
選択した図形を１つ背面に移動

261
00:18:43,690 --> 00:18:47,127
最後に 左のリスト内で直接移動

262
00:18:49,696 --> 00:18:53,634
操作自体はシンプルに見えますよね

263
00:18:54,101 --> 00:18:58,305
でも隣接しない図形を
複数 選んでも

264
00:18:58,405 --> 00:19:02,309
正しく動作させる必要があります

265
00:18:58,405 --> 00:19:02,309
正しく動作させる必要があります

266
00:19:05,512 --> 00:19:09,716
理にかなうのは
選択された複数の要素を

267
00:19:09,817 --> 00:19:12,519
隣接させることでしょう

268
00:19:13,020 --> 00:19:16,390
１番前の選択図形を前に出したあと

269
00:19:16,490 --> 00:19:20,260
残りの選択図形を
その下にまとめる

270
00:19:22,629 --> 00:19:24,565
背面に移動する時は―

271
00:19:24,665 --> 00:19:30,137
１番下の選択図形を移動し
残りを その上にまとめる

272
00:19:33,974 --> 00:19:38,645
話の全部を理解できなくても
大丈夫ですよ

273
00:19:38,745 --> 00:19:44,952
この詳細を説明できるような
コードを用意しました

274
00:19:46,453 --> 00:19:48,922
これは“bringToFront”です

275
00:19:50,424 --> 00:19:55,696
このコードを見ると
“shapes”にO(n)ループがあり

276
00:19:55,829 --> 00:20:01,168
removeとinsertの
２つのO(n)演算があります

277
00:19:55,829 --> 00:20:01,168
removeとinsertの
２つのO(n)演算があります

278
00:20:01,869 --> 00:20:05,239
つまりこれはｎの２乗です

279
00:20:06,240 --> 00:20:11,445
他の４つのコマンドにも
同じ問題が見られます

280
00:20:12,379 --> 00:20:17,584
これらは配列上をループし
挿入と削除を実行

281
00:20:17,684 --> 00:20:19,520
いずれも二次です

282
00:20:21,221 --> 00:20:23,891
この時点で私は心が折れ

283
00:20:23,991 --> 00:20:26,527
クラスティに助けを求めました

284
00:20:27,294 --> 00:20:32,166
“今夜は社交ダンスに行くので
時間がないが―”

285
00:20:32,266 --> 00:20:34,902
“とにかく始めよう”

286
00:20:35,202 --> 00:20:37,838
私はコードを見せました

287
00:20:39,273 --> 00:20:44,711
彼の最初の質問は
“この仕組みは？”です

288
00:20:45,712 --> 00:20:49,817
whileループがあり
ｊは挿入ポイント

289
00:20:49,917 --> 00:20:52,019
ｉは要素を追跡します

290
00:20:52,152 --> 00:20:55,022
“コードでなく言葉で説明を！”

291
00:20:55,589 --> 00:20:56,890
彼は言いました

292
00:20:58,325 --> 00:21:02,463
選択された図形を前面に移動し

293
00:20:58,325 --> 00:21:02,463
選択された図形を前面に移動し

294
00:21:02,563 --> 00:21:04,531
順序は維持します

295
00:21:05,766 --> 00:21:08,735
“コメントで記入し読み上げろ”

296
00:21:10,304 --> 00:21:12,773
入力は速いんです

297
00:21:15,442 --> 00:21:19,580
選択図形を前面に移動し
順序は維持

298
00:21:20,747 --> 00:21:23,183
“内容に聞き覚えは？”

299
00:21:23,951 --> 00:21:27,688
これはまるで
“halfStablePartition”です

300
00:21:28,455 --> 00:21:32,359
こちらは完全に
“stable”ですがね

301
00:21:32,459 --> 00:21:34,628
“これの名前は？”

302
00:21:34,728 --> 00:21:37,397
“stablePartition？”

303
00:21:38,432 --> 00:21:40,767
“そのとおりだ”

304
00:21:40,868 --> 00:21:45,239
“オープンソースのファイルが
実装の参考になる”

305
00:21:46,273 --> 00:21:48,809
私はファイルを入手

306
00:21:48,909 --> 00:21:55,482
コードにコメントは残したまま
コーディングを再開しました

307
00:21:57,151 --> 00:22:00,554
しかし問題が発生します

308
00:21:57,151 --> 00:22:00,554
しかし問題が発生します

309
00:22:01,588 --> 00:22:04,525
“stablePartition”は

310
00:22:04,625 --> 00:22:09,496
接尾辞への要素の移動を示す
述語を取ります

311
00:22:09,863 --> 00:22:14,501
“bringToFront”では
後方に動かす観点が必要です

312
00:22:15,302 --> 00:22:19,606
クラスティは
“思い描いてみろ”と言います

313
00:22:20,274 --> 00:22:25,345
私は未選択の図形が
後ろに集まる様子を想像し

314
00:22:25,445 --> 00:22:26,980
答えを得ました

315
00:22:29,583 --> 00:22:35,889
“sendToBack”では述語を逆にし
選択図形を後ろに送ります

316
00:22:38,258 --> 00:22:42,162
いよいよコーディングの時間です

317
00:22:42,262 --> 00:22:47,568
クラスティも夜のダンスへと
繰り出すと思ったのですが

318
00:22:47,668 --> 00:22:50,804
“ちょっと待て”と私を止めました

319
00:22:51,505 --> 00:22:56,210
“スケーラビリティを
チェックするんだ”

320
00:22:57,311 --> 00:22:58,412
確かに

321
00:22:59,046 --> 00:23:01,181
クイックヘルプを開きます

322
00:22:59,046 --> 00:23:01,181
クイックヘルプを開きます

323
00:23:03,083 --> 00:23:06,420
計算量は(n log n)

324
00:23:07,821 --> 00:23:11,859
これを考えるため
log nに注目します

325
00:23:13,660 --> 00:23:17,331
すぐに水平になり 大きくなるほど

326
00:23:17,431 --> 00:23:22,069
増加は鈍化し
一定に近づいていきます

327
00:23:22,436 --> 00:23:24,538
これにｎを掛けます

328
00:23:26,039 --> 00:23:29,676
O(n)ほど増加することなく

329
00:23:29,776 --> 00:23:33,347
徐々に線形に近づいていきます

330
00:23:34,147 --> 00:23:39,720
従ってO(n log n)は
O(n)と同じものとして扱えます

331
00:23:41,021 --> 00:23:45,125
この結果には非常に満足しています

332
00:23:46,627 --> 00:23:48,962
少し話を戻しましょう

333
00:23:49,329 --> 00:23:53,567
“bringForward()”は
一番前の選択図形を前に出して

334
00:23:53,667 --> 00:23:56,904
後ろに他の選択図形を集めます

335
00:23:57,804 --> 00:24:01,742
ただ クラスティは
この方法に反対です

336
00:23:57,804 --> 00:24:01,742
ただ クラスティは
この方法に反対です

337
00:24:02,009 --> 00:24:08,182
“あの図形は並んで
ダンスでも踊るつもりなのか？”

338
00:24:09,316 --> 00:24:12,586
そして再び のど飴を出すと―

339
00:24:13,854 --> 00:24:19,359
軽やかな手さばきで
“bringForward()”を実行しました

340
00:24:22,796 --> 00:24:24,498
“もう１回見せよう”

341
00:24:25,332 --> 00:24:28,936
ペテン師のカモになった気分です

342
00:24:34,141 --> 00:24:35,342
“見覚えは？”

343
00:24:36,210 --> 00:24:37,010
ないよ

344
00:24:37,678 --> 00:24:39,680
彼は数を減らします

345
00:24:42,516 --> 00:24:43,650
“これでどうだ？”

346
00:24:46,520 --> 00:24:50,557
なるほど
“stablePartition”です

347
00:24:51,225 --> 00:24:53,560
何となく分かりました

348
00:24:56,230 --> 00:24:59,266
選択された最前面の図形を

349
00:25:00,200 --> 00:25:02,870
その前に移動します

350
00:25:03,136 --> 00:25:07,908
そこから始まる
配列のセクションを分離すれば

351
00:25:08,275 --> 00:25:10,310
それを分割できます

352
00:25:12,446 --> 00:25:16,049
でも コレクションの
一部だけを修正する方法は？

353
00:25:16,750 --> 00:25:20,320
“スライスを知らないのか？”

354
00:25:23,023 --> 00:25:26,860
“predecessor”で始まる
“shapes”

355
00:25:27,861 --> 00:25:32,099
“これをアルゴリズムに取り込み
調整するんだ”

356
00:25:37,604 --> 00:25:38,405
さて…

357
00:25:40,040 --> 00:25:43,877
計算の効率性と正確性への
人類の探求は

358
00:25:43,977 --> 00:25:49,283
コンピュータに先んじ
古代エジプトから続いています

359
00:25:49,449 --> 00:25:54,154
コンピュータの発明以降
それは活発化しました

360
00:25:55,489 --> 00:26:00,160
標準ライブラリに
必要なものがなくても

361
00:25:55,489 --> 00:26:00,160
標準ライブラリに
必要なものがなくても

362
00:26:00,260 --> 00:26:05,165
テストや文書などが
利用できるかもしれません

363
00:26:05,632 --> 00:26:09,803
必要なものを検索できる
能力が問われます

364
00:26:12,606 --> 00:26:13,941
コードに戻りましょう

365
00:26:14,041 --> 00:26:16,210
先ほどのスライスですが

366
00:26:16,310 --> 00:26:20,547
型を調べると
配列ではありませんでした

367
00:26:21,615 --> 00:26:26,920
ここまで“stablePartition”を
配列などに使い

368
00:26:27,020 --> 00:26:29,723
配列スライスにも使えました

369
00:26:29,823 --> 00:26:32,860
汎用的なのかもしれません

370
00:26:33,694 --> 00:26:34,962
“もちろんだ”

371
00:26:35,062 --> 00:26:38,265
“stablePartition”と
配列の仕様の関係は？

372
00:26:39,066 --> 00:26:40,767
“関係はない”

373
00:26:41,235 --> 00:26:47,341
“bringForwardは 図形や選択と
どう関係してると思う？”

374
00:26:48,842 --> 00:26:53,814
図形に作用し
選択図形を前面に送ります

375
00:26:53,914 --> 00:26:55,449
“そうだ 関係ない”

376
00:26:55,549 --> 00:26:57,151
私の話は無視です

377
00:26:58,519 --> 00:27:01,221
“のど飴の列で
bringForwardできるか？”

378
00:26:58,519 --> 00:27:01,221
“のど飴の列で
bringForwardできるか？”

379
00:27:02,322 --> 00:27:03,490
“もちろんできる”

380
00:27:04,024 --> 00:27:06,093
つまり図形と関係はない

381
00:27:08,095 --> 00:27:12,366
ジェネリックにしろと
いうことですか？

382
00:27:12,633 --> 00:27:14,768
時期尚早の気もします

383
00:27:15,335 --> 00:27:19,773
私の質問に答えず
クラスティは質問します

384
00:27:20,474 --> 00:27:23,177
“このメソッドのテスト方法は？”

385
00:27:24,812 --> 00:27:28,949
キャンバスを作成し
ランダムに図形を追加

386
00:27:29,049 --> 00:27:32,085
その一部を選択して 最後に…

387
00:27:32,352 --> 00:27:36,590
でも マズい考えだと
分かっていました

388
00:27:36,990 --> 00:27:40,727
それを全部やっても
関数や初期化子の―

389
00:27:40,828 --> 00:27:44,731
テストになるかは分かりません

390
00:27:44,832 --> 00:27:50,037
IsSelectedプロパティや
AddShapeメソッドも同じです

391
00:27:50,838 --> 00:27:54,541
テストケースが必要ですが
そのコードには―

392
00:27:54,842 --> 00:27:58,212
テストの必要がないのが
理想でしょう

393
00:27:59,012 --> 00:28:01,381
のど飴を前に送る場合は

394
00:27:59,012 --> 00:28:01,381
のど飴を前に送る場合は

395
00:28:01,682 --> 00:28:05,752
“Playground”の
int型が使えそうです

396
00:28:05,853 --> 00:28:10,124
こんな感じで
３で割れる数を前に送ります

397
00:28:13,227 --> 00:28:16,763
その一方
ランダムに生成される―

398
00:28:16,864 --> 00:28:22,770
膨大なテストデータを投げ
アルゴリズムの拡張性を確認します

399
00:28:23,136 --> 00:28:28,342
しかし今のコードでは
どちらも簡単ではありません

400
00:28:29,142 --> 00:28:31,879
私はクラスティの正しさを認め

401
00:28:32,179 --> 00:28:37,484
“bringForward”を
ジェネリックに変え始めました

402
00:28:38,352 --> 00:28:42,022
最初に“Canvas”から
切り離します

403
00:28:43,524 --> 00:28:46,226
そして“Shape”の配列に移動

404
00:28:47,094 --> 00:28:51,932
これにより“shapes”を
“self”に変えます

405
00:28:53,734 --> 00:28:57,838
そして図形の動きを示す
述語を渡すことで

406
00:28:57,938 --> 00:29:01,175
“Selected”から切り離します

407
00:28:57,938 --> 00:29:01,175
“Selected”から切り離します

408
00:29:04,945 --> 00:29:07,748
コンパイルできました
すばらしい

409
00:29:08,182 --> 00:29:13,153
この時点で“shapes”に
依存関係はなくなりました

410
00:29:13,287 --> 00:29:15,889
where節を削除できます

411
00:29:17,157 --> 00:29:20,861
これで どんな配列でも
前に出せます

412
00:29:21,495 --> 00:29:26,633
ダンスの練習をしていた
クラスティの方に目をやりました

413
00:29:26,733 --> 00:29:29,336
彼は私に質問します

414
00:29:31,205 --> 00:29:34,808
“bringForwardと配列の関係は？”

415
00:29:37,277 --> 00:29:41,515
ありません
この依存関係も取り除きます

416
00:29:42,583 --> 00:29:45,252
この“stablePartition”は

417
00:29:45,352 --> 00:29:48,055
可変コレクションの適合性を
要求します

418
00:29:48,155 --> 00:29:50,591
このコレクションを移動します

419
00:29:52,893 --> 00:29:58,999
インデックス型が
int型と一致しませんね

420
00:29:59,366 --> 00:30:01,635
これを直します

421
00:29:59,366 --> 00:30:01,635
これを直します

422
00:30:04,104 --> 00:30:05,439
これをしたことは？

423
00:30:06,073 --> 00:30:07,274
お勧めしません

424
00:30:09,376 --> 00:30:13,914
これを見たクラスティは
踊るのをやめました

425
00:30:15,215 --> 00:30:16,517
何か？

426
00:30:16,850 --> 00:30:20,387
“それは新人のやることだ”

427
00:30:21,455 --> 00:30:26,427
“まず０と比較するが
配列スライスには適さない”

428
00:30:27,895 --> 00:30:32,599
このインデックスの始まりは
０じゃないんですね

429
00:30:33,267 --> 00:30:35,769
スライスのインデックスは

430
00:30:35,869 --> 00:30:40,040
元のコレクションの
インデックスに対応しています

431
00:30:41,041 --> 00:30:46,813
スライスを利用した
汎用アルゴリズムでは

432
00:30:47,080 --> 00:30:48,315
この関係は重要です

433
00:30:50,651 --> 00:30:54,955
この問題の解決には
開始インデックスを比較します

434
00:30:55,689 --> 00:31:00,494
“本当の問題は bringForwardが
どのように…”

435
00:30:55,689 --> 00:31:00,494
“本当の問題は bringForwardが
どのように…”

436
00:31:00,594 --> 00:31:04,765
整数インデックスに関係するか
ですよね？

437
00:31:05,132 --> 00:31:11,271
減算することで ｉの前に
インデックスを取得します

438
00:31:13,073 --> 00:31:16,243
クラスティは また飴を出しました

439
00:31:17,377 --> 00:31:20,747
そして 机に２本の指を置き

440
00:31:20,948 --> 00:31:27,654
右手が最初に緑色の飴を
指すまで 動かしました

441
00:31:30,157 --> 00:31:32,860
“後ろ向きの動きじゃない”

442
00:31:33,327 --> 00:31:37,931
これはアルゴリズムだと
私は気付きました

443
00:31:38,499 --> 00:31:41,468
“これをindexBeforeFirstと
名付けよう”

444
00:31:41,969 --> 00:31:47,341
“コードは他の人が書いたと思って
注意深く見るんだ”

445
00:31:47,708 --> 00:31:50,844
彼は不要な部分を消し始めました

446
00:31:50,944 --> 00:31:53,447
これに これも

447
00:31:56,817 --> 00:31:58,786
“predecessorは―”

448
00:31:58,886 --> 00:32:04,792
“述語が満たされる最初よりも
前のインデックスだ”

449
00:31:58,886 --> 00:32:04,792
“述語が満たされる最初よりも
前のインデックスだ”

450
00:32:05,225 --> 00:32:07,528
“いいコードができたぞ”

451
00:32:08,395 --> 00:32:12,065
確かに 彼の言葉は正しいですね

452
00:32:13,033 --> 00:32:19,306
図形 選択 配列 整数の
詳細を取り除いたことで

453
00:32:19,439 --> 00:32:21,475
クリアになりました

454
00:32:21,608 --> 00:32:24,711
本質のみが残りましたからね

455
00:32:26,480 --> 00:32:30,484
“indexBeforeFirstを
自分でコードで書けるか？”

456
00:32:31,818 --> 00:32:37,391
徐々に理解できているので
いけそうな気がします

457
00:32:39,459 --> 00:32:41,995
タイプは得意なんですよ

458
00:32:42,095 --> 00:32:48,969
“後続が述語と一致する
最初のインデックスを返す”

459
00:32:50,037 --> 00:32:52,773
この出来には満足です

460
00:32:53,307 --> 00:32:56,109
クラスティ 次の問題を！

461
00:32:57,344 --> 00:33:00,948
“何か忘れてないか？”
彼は言います

462
00:32:57,344 --> 00:33:00,948
“何か忘れてないか？”
彼は言います

463
00:33:01,381 --> 00:33:03,283
何のことでしょうか

464
00:33:03,383 --> 00:33:06,086
コードは簡潔明瞭です

465
00:33:06,887 --> 00:33:12,526
“セマンティクスだ
意味が分からないと使えない”

466
00:33:14,628 --> 00:33:16,663
その時 気付きました

467
00:33:16,763 --> 00:33:19,233
新しいアルゴリズムを使う時

468
00:33:19,333 --> 00:33:25,639
コードの意味や効率を知るため
ドキュメントを参照します

469
00:33:26,240 --> 00:33:31,612
アルゴリズムは流用改変が多く
参照ドキュメントは同じです

470
00:33:32,946 --> 00:33:38,385
私は最近 ある面接で
文書の役割について聞きました

471
00:33:38,485 --> 00:33:41,288
彼の言葉は印象的でした

472
00:33:41,855 --> 00:33:44,491
“本当に重要なものです”

473
00:33:45,559 --> 00:33:49,863
“文書は いわば
抽象化の塔と言えます”

474
00:33:49,963 --> 00:33:54,468
“私たちが下を気にせず
上に構築ができるのは―”

475
00:33:54,568 --> 00:33:57,571
“文書化された
基盤があるからです”

476
00:33:59,006 --> 00:34:01,208
アプリケーション開発者として

477
00:33:59,006 --> 00:34:01,208
アプリケーション開発者として

478
00:34:01,375 --> 00:34:06,680
あなたは 塔の最上階で
働いているとしましょう

479
00:34:06,780 --> 00:34:11,652
ハードウェア基盤から伸び
フレームワークを貫く塔です

480
00:34:12,686 --> 00:34:17,324
そうした中で
独自のメソッドを使う場合は

481
00:34:17,891 --> 00:34:19,393
文書化しましょう

482
00:34:20,460 --> 00:34:23,330
面接の彼は採用され そこにいます

483
00:34:26,500 --> 00:34:30,771
私は 新しいアルゴリズムを
文書化しました

484
00:34:31,804 --> 00:34:34,875
これで実装のことは忘れられます

485
00:34:36,076 --> 00:34:39,746
疑問点にはクイックヘルプです

486
00:34:41,148 --> 00:34:43,851
“bringForward”も文書化を

487
00:34:46,186 --> 00:34:46,987
いいですね

488
00:34:48,054 --> 00:34:51,324
問題はすべて解決できましたが

489
00:34:51,425 --> 00:34:56,996
ここで“stablePartition”の
中身を見たくなりました

490
00:34:57,698 --> 00:35:02,836
結果 美しく建設的な
アルゴリズムでひと安心です

491
00:34:57,698 --> 00:35:02,836
結果 美しく建設的な
アルゴリズムでひと安心です

492
00:35:03,670 --> 00:35:07,074
パブリックメソッドが
コレクションの数を取り

493
00:35:07,174 --> 00:35:08,408
ヘルパに渡します

494
00:35:09,710 --> 00:35:12,212
使うのは分割統治法です

495
00:35:13,013 --> 00:35:18,785
カウントが２未満の場合
基本ケースを処理し

496
00:35:18,885 --> 00:35:23,791
分割点が コレクションの
先頭か末尾かを判断します

497
00:35:25,993 --> 00:35:29,129
次に コレクションを
２つに分けます

498
00:35:31,331 --> 00:35:36,603
ここでは アルゴリズムの挙動を
信じなければなりません

499
00:35:36,703 --> 00:35:39,473
左半分に
“stablePartition”を実行

500
00:35:40,274 --> 00:35:41,842
右半分にも

501
00:35:45,746 --> 00:35:51,785
両端を見た時 すべてが
正しい位置にあるのが分かります

502
00:35:53,654 --> 00:35:57,691
でも中央の部分は交換が必要です

503
00:35:58,725 --> 00:36:03,964
なお この例のように
長さは一定とは限りません

504
00:35:58,725 --> 00:36:03,964
なお この例のように
長さは一定とは限りません

505
00:36:04,832 --> 00:36:08,135
交換にも
幸いアルゴリズムがあります

506
00:36:08,802 --> 00:36:11,004
それは“rotate”です

507
00:36:14,741 --> 00:36:18,512
“rotate”には詳しく触れませんが

508
00:36:18,612 --> 00:36:23,817
“stablePartition”と
同じファイルで 実装が見られます

509
00:36:25,819 --> 00:36:27,554
話を戻しましょう

510
00:36:28,088 --> 00:36:29,957
こちらは―

511
00:36:31,759 --> 00:36:36,096
図形リストへのドラッグの実装です

512
00:36:36,196 --> 00:36:39,833
複雑でバグも少なくありません

513
00:36:40,234 --> 00:36:43,637
戦略は 一時バッファを
割り当て―

514
00:36:44,771 --> 00:36:48,542
挿入点の前の図形をループします

515
00:36:48,642 --> 00:36:51,879
選択した図形を抽出して
挿入点を調整

516
00:36:52,379 --> 00:36:55,249
残りの図形を別々にループし

517
00:36:55,349 --> 00:36:58,986
その後 選択したものを抽出します

518
00:37:00,688 --> 00:37:03,123
最後に 再挿入です

519
00:37:06,793 --> 00:37:12,633
やっと正しいコードができたので
もう触りたくありません

520
00:37:12,933 --> 00:37:16,236
最後のバグは１週間前でした

521
00:37:19,406 --> 00:37:23,076
ただ このプロセスは
うまくいったので

522
00:37:23,177 --> 00:37:26,447
一度 可視化しようと思っています

523
00:37:28,982 --> 00:37:32,319
今の見覚えあるな　もう１回見よう

524
00:37:36,823 --> 00:37:41,862
まず これを行い
次にパーツを別々に扱う…

525
00:37:43,664 --> 00:37:48,702
そうか 逆の述語を持つ
２つの“stablePartition”だ

526
00:37:49,870 --> 00:37:53,874
汎用アルゴリズムは
２つにまで縮小されました

527
00:37:55,676 --> 00:37:58,078
これが“Canvas”の内容です

528
00:37:59,947 --> 00:38:02,082
古い方と並べてみます

529
00:37:59,947 --> 00:38:02,082
古い方と並べてみます

530
00:38:04,685 --> 00:38:05,819
悪くありません

531
00:38:07,054 --> 00:38:10,557
再利用可能で 文書化された―

532
00:38:10,657 --> 00:38:14,328
汎用アルゴリズムに変身しました

533
00:38:18,565 --> 00:38:20,901
ここまで見てきたのは―

534
00:38:21,635 --> 00:38:25,873
アプリケーションドメインに
固有の詳細

535
00:38:26,006 --> 00:38:28,342
コードの基本的な動作

536
00:38:28,442 --> 00:38:31,845
再利用可能な
汎用コードでの再現です

537
00:38:32,179 --> 00:38:34,181
練習を必要とします

538
00:38:34,815 --> 00:38:38,018
実用的な観点から言うと

539
00:38:38,352 --> 00:38:43,524
汎用アルゴリズムは
不必要な細部を切り離せます

540
00:38:43,624 --> 00:38:48,962
再利用可能で検証も簡単
それに より明確です

541
00:38:49,596 --> 00:38:54,735
また プログラミング好きに
やりがいを与えてくれます

542
00:38:55,502 --> 00:39:00,708
それから 実際にハードウェアの
制約の中で行う―

543
00:38:55,502 --> 00:39:00,708
それから 実際にハードウェアの
制約の中で行う―

544
00:39:00,808 --> 00:39:04,111
真実と美の探求でもあります

545
00:39:04,745 --> 00:39:09,016
まさに“プログラミングは
真実を解き明かす”です

546
00:39:10,184 --> 00:39:13,587
計算を一級市民と考えましょう

547
00:39:13,954 --> 00:39:20,094
権利と義務を背負って
型とアーキテクチャに向き合い

548
00:39:20,194 --> 00:39:27,434
識別し 名前を付け テストし
意味と性能を文書化しましょう

549
00:39:29,103 --> 00:39:34,575
最後にショーン･ペアレントの
言葉をご紹介します

550
00:39:35,976 --> 00:39:39,379
“コードの品質を上げたいなら”

551
00:39:39,479 --> 00:39:45,352
“コーディングの基準を
No Raw Loopsに置き換えよう”

552
00:39:46,386 --> 00:39:47,387
以上です

553
00:39:47,488 --> 00:39:53,594
(拍手)