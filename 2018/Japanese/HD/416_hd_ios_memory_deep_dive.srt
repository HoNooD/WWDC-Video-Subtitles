
1
00:00:07,140 --> 00:00:16,550
(音楽)

2
00:00:23,390 --> 00:00:27,995
(拍手)

3
00:00:28,095 --> 00:00:30,797
Appleのソフトウェアエンジニアの
カイルです

4
00:00:30,898 --> 00:00:33,901
本日はiOSのメモリの話をします

5
00:00:34,001 --> 00:00:37,171
iOSにフォーカスした話ですが

6
00:00:37,271 --> 00:00:40,908
他のプラットフォームへも
適用可能です

7
00:00:43,177 --> 00:00:47,214
最初のトピックは
なぜメモリを減らすのか？

8
00:00:48,882 --> 00:00:53,120
ここで言うメモリとは
メモリフットプリントです

9
00:00:53,220 --> 00:00:54,454
後ほど詳しく説明します

10
00:00:55,355 --> 00:00:58,458
次にメモリフットプリントを
分析するツールの話

11
00:00:59,092 --> 00:01:03,463
画像がバックグラウンドにある時の
最適化の話もします

12
00:00:59,092 --> 00:01:03,463
画像がバックグラウンドにある時の
最適化の話もします

13
00:01:03,564 --> 00:01:05,599
そして最後はデモです

14
00:01:06,400 --> 00:01:09,236
さて なぜメモリを減らすのか？

15
00:01:10,437 --> 00:01:13,240
ユーザの使い勝手を
よくするためです

16
00:01:13,340 --> 00:01:16,743
Appの起動ばかりか
動作も速くなります

17
00:01:16,844 --> 00:01:20,247
誰のAppでも
メモリに長くとどまります

18
00:01:20,347 --> 00:01:21,915
利点ばかりです

19
00:01:22,216 --> 00:01:28,121
今 隣に座っている
デベロッパを助けているのです

20
00:01:29,990 --> 00:01:32,826
メモリフットプリントの
話をしましょう

21
00:01:32,926 --> 00:01:34,661
すべてのメモリは異なります

22
00:01:34,761 --> 00:01:35,996
その意味とは？

23
00:01:36,964 --> 00:01:38,498
ページを例にします

24
00:01:38,599 --> 00:01:40,100
紙のページとは違い

25
00:01:40,534 --> 00:01:42,302
メモリのページです

26
00:01:42,402 --> 00:01:45,339
システムから提供されて

27
00:01:45,606 --> 00:01:47,975
ヒープ上で 複数のオブジェクトを
所持できます

28
00:01:48,075 --> 00:01:51,879
数ページに渡る
オブジェクトもあります

29
00:01:54,047 --> 00:01:56,316
サイズは大抵16キロバイトです

30
00:01:56,416 --> 00:01:58,619
クリーンかダーティな
ページに分かれます

31
00:02:00,487 --> 00:02:05,192
メモリ使用量とは
ページ数とページサイズの積です

32
00:02:07,194 --> 00:02:09,696
クリーンとダーティの
例を挙げます

33
00:02:09,795 --> 00:02:14,668
例えば ２万個の整数を
配置するとします

34
00:02:14,768 --> 00:02:17,271
そのシステムには
６ページ要するかもしれません

35
00:02:18,572 --> 00:02:21,074
配置時のページはクリーンです

36
00:02:21,208 --> 00:02:23,143
ただデータバッファに
何かを入力した場合

37
00:02:23,243 --> 00:02:26,213
例えば先頭部分に入力すると

38
00:02:26,380 --> 00:02:28,115
ページはダーティになります

39
00:02:28,782 --> 00:02:29,716
同じように

40
00:02:30,184 --> 00:02:36,023
データバッファの最終ページに
入力してもダーティになります

41
00:02:36,390 --> 00:02:40,294
挟まれた４ページは
クリーンなままです

42
00:02:42,796 --> 00:02:45,999
さらに興味深いのは
メモリマップトファイルです

43
00:02:46,099 --> 00:02:49,803
これはディスク上で
メモリにロードされたファイルです

44
00:02:50,237 --> 00:02:53,440
読み込み専用ファイルは
常にクリーンなページになります

45
00:02:53,774 --> 00:02:57,244
カーネルがRAMへの
移動を管理します

46
00:02:58,979 --> 00:03:01,481
分かりやすい例はJPEGです

47
00:02:58,979 --> 00:03:01,481
分かりやすい例はJPEGです

48
00:03:01,582 --> 00:03:04,218
このJPEGのサイズが
50キロバイトの場合―

49
00:03:05,185 --> 00:03:10,824
メモリがマップされ
ページにすると約４ページです

50
00:03:10,924 --> 00:03:14,728
４ページ目は空きがあり
まだ使用可能です

51
00:03:14,828 --> 00:03:16,797
少しトリッキーですね

52
00:03:16,897 --> 00:03:22,135
最初の３ページはパージ可能です

53
00:03:24,137 --> 00:03:26,440
通常のAppでは―

54
00:03:27,107 --> 00:03:31,612
フットプリントの要素はダーティ
圧縮 クリーンに分かれます

55
00:03:32,079 --> 00:03:33,447
詳しく説明しましょう

56
00:03:34,681 --> 00:03:38,252
クリーンなメモリは
ページアウト可能です

57
00:03:38,685 --> 00:03:40,888
これがメモリマップトファイルです

58
00:03:40,988 --> 00:03:44,825
画像やBLOBデータ
トレーニングモデルなど

59
00:03:45,959 --> 00:03:47,561
フレームワークでもよいです

60
00:03:48,495 --> 00:03:51,999
フレームワークは
DATA CONSTを持ち

61
00:03:52,466 --> 00:03:57,371
swizzlingなどを実行すると
ダーティになります

62
00:04:01,008 --> 00:04:05,012
ダーティはAppによる
書込みがあるメモリです

63
00:04:05,612 --> 00:04:07,781
ダーティメモリにはオブジェクトや
文字列や配列などの

64
00:04:07,881 --> 00:04:10,851
mallocで定義された
あらゆるものがあります

65
00:04:12,619 --> 00:04:15,789
またデコードされた
イメージバッファや

66
00:04:17,391 --> 00:04:18,992
フレームワークもそうです

67
00:04:19,259 --> 00:04:23,730
フレームワークには通常のデータと
ダーティな部分がありますが

68
00:04:24,231 --> 00:04:27,301
ダーティとして認識されています

69
00:04:27,935 --> 00:04:30,637
フレームワークは
２度登場しました

70
00:04:30,737 --> 00:04:35,642
フレームワークをリンクするには
両方のメモリを使うのです

71
00:04:35,742 --> 00:04:38,478
フレームワークのリンクの
話をすると

72
00:04:38,579 --> 00:04:40,447
このフレームワークの整備には

73
00:04:40,781 --> 00:04:43,483
Singletonsと
グローバルイニシャライザが

74
00:04:43,584 --> 00:04:46,320
ダーティメモリ削減に役立ちます

75
00:04:46,420 --> 00:04:50,290
Singletonsは生成された後
必ずメモリに起生し

76
00:04:50,424 --> 00:04:54,962
イニシャライザはリンク時
クラスのロード時に実行されます

77
00:04:57,631 --> 00:05:00,033
次は圧縮されたメモリです

78
00:04:57,631 --> 00:05:00,033
次は圧縮されたメモリです

79
00:05:00,667 --> 00:05:03,504
iOSはディスクスワップの
システムがありません

80
00:05:04,505 --> 00:05:06,473
代わりに
メモリ圧縮プログラムを使います

81
00:05:06,573 --> 00:05:08,308
iOS 7でリリースされました

82
00:05:08,575 --> 00:05:12,012
この圧縮プログラムは
未アクセスのページを―

83
00:05:12,246 --> 00:05:16,116
圧縮してスペースを生み出します

84
00:05:16,316 --> 00:05:20,787
またアクセス時にはページを解凍し
メモリを読み取れます

85
00:05:21,121 --> 00:05:22,556
例を見ましょう

86
00:05:23,390 --> 00:05:25,692
キャッシュ用の
ディクショナリがあるとします

87
00:05:25,859 --> 00:05:28,595
使用メモリは３ページ分

88
00:05:29,296 --> 00:05:32,966
アクセスがなく
システムがスペースを要求すれば

89
00:05:33,066 --> 00:05:35,769
１ページまで圧縮できます

90
00:05:35,869 --> 00:05:38,138
このように圧縮されて

91
00:05:39,540 --> 00:05:42,676
２ページ分の空きができました

92
00:05:42,809 --> 00:05:45,646
アクセスすれば元に戻ります

93
00:05:46,747 --> 00:05:49,116
次はメモリ不足警告について

94
00:05:49,750 --> 00:05:53,320
警告の原因がAppとは限りません

95
00:05:53,787 --> 00:05:57,124
ローメモリのデバイスでの
電話受信は―

96
00:05:57,224 --> 00:05:58,959
警告の原因になります

97
00:05:59,059 --> 00:06:03,330
皆さんのAppが
原因ではありません

98
00:05:59,059 --> 00:06:03,330
皆さんのAppが
原因ではありません

99
00:06:03,931 --> 00:06:07,401
この圧縮プログラムは
メモリ開放を複雑にします

100
00:06:07,935 --> 00:06:12,172
圧縮対象によっては
よりメモリを使うからです

101
00:06:12,272 --> 00:06:14,741
そこでポリシーの変更を
お薦めします

102
00:06:14,842 --> 00:06:17,611
一定期間キャッシュを停止するとか

103
00:06:17,711 --> 00:06:21,481
バックグラウンド作業の
一部を抑制するなど

104
00:06:22,482 --> 00:06:25,285
対応済みの方も
いるかと思いますが―

105
00:06:26,553 --> 00:06:29,857
警告を受けたら キャッシュから
すべてのオブジェクトを削除します

106
00:06:31,291 --> 00:06:34,228
圧縮されたディクショナリの
例に戻りましょう

107
00:06:34,695 --> 00:06:35,796
どうなるでしょう？

108
00:06:35,896 --> 00:06:38,499
ディクショナリにアクセスすると

109
00:06:38,899 --> 00:06:41,602
ページの使用数が増えました

110
00:06:42,035 --> 00:06:46,006
制限されたメモリ環境では
問題ですね

111
00:06:46,406 --> 00:06:48,642
私はオブジェクトを削除し

112
00:06:49,142 --> 00:06:53,480
圧縮時と同じ１ページに戻すため
多くの作業をしています

113
00:06:54,181 --> 00:06:58,285
一般的に
メモリ不足警告には要注意です

114
00:06:59,620 --> 00:07:02,823
さてキャッシュに関する
重要ポイントです

115
00:06:59,620 --> 00:07:02,823
さてキャッシュに関する
重要ポイントです

116
00:07:03,190 --> 00:07:07,127
キャッシュは
CPUのリピート作業を避けます

117
00:07:07,227 --> 00:07:10,264
度を越えると
メモリを使い果たし

118
00:07:10,697 --> 00:07:13,000
システムには問題です

119
00:07:13,367 --> 00:07:16,537
メモリ圧縮プログラムと
キャッシュがありますが

120
00:07:16,637 --> 00:07:20,841
キャッシュと再計算の
バランスを考慮してください

121
00:07:21,341 --> 00:07:24,845
またディクショナリの代わりに
NSCacheを使えば

122
00:07:24,945 --> 00:07:28,382
安全にオブジェクトを保存できます

123
00:07:28,482 --> 00:07:32,252
NSCacheで割り当てられた
メモリはパージ可能で

124
00:07:32,352 --> 00:07:34,855
メモリ制約下では有効です

125
00:07:36,690 --> 00:07:39,827
Appのメモリ構造に戻りましょう

126
00:07:39,927 --> 00:07:45,032
Appのフットプリントと言えば
ダーティか圧縮の部分です

127
00:07:45,132 --> 00:07:47,234
クリーンは別ものです

128
00:07:47,801 --> 00:07:52,105
どんなAppにも
フットプリントの限度があります

129
00:07:52,973 --> 00:07:55,442
上限はかなり高いですが

130
00:07:55,542 --> 00:07:59,346
デバイスによって
限度は変わります

131
00:07:59,446 --> 00:08:03,283
１ギガバイトのデバイスでは
４ギガバイトのデバイスほど

132
00:07:59,446 --> 00:08:03,283
１ギガバイトのデバイスでは
４ギガバイトのデバイスほど

133
00:08:03,383 --> 00:08:05,385
メモリは使えません

134
00:08:06,820 --> 00:08:10,524
そこでExtensionを使います

135
00:08:10,624 --> 00:08:12,793
Extensionの
フットプリントは低いです

136
00:08:12,893 --> 00:08:16,930
使用の際は
心に留めておいてください

137
00:08:17,965 --> 00:08:21,735
フットプリントが超過すると
例外を得ます

138
00:08:22,135 --> 00:08:26,573
それがEXC RESOURCE EXCEPTIONです

139
00:08:27,341 --> 00:08:29,476
それではこれから

140
00:08:30,043 --> 00:08:33,179
フットプリントの分析について
ジェイムスが話します

141
00:08:34,615 --> 00:08:37,183
(拍手)

142
00:08:37,284 --> 00:08:38,150
よろしく　ジェイムス

143
00:08:38,251 --> 00:08:39,052
ありがとう

144
00:08:40,587 --> 00:08:41,388
ありがとう　カイル

145
00:08:41,688 --> 00:08:44,358
Appleのソフトウェアエンジニアの
ジェイムスです

146
00:08:44,458 --> 00:08:49,897
フットプリントの分析のための
ツールを紹介します

147
00:08:51,398 --> 00:08:54,301
Xcodeのメモリ測定は
ご存知ですね

148
00:08:54,401 --> 00:09:00,474
デバッグナビゲータに表示され
フットプリントを確認できます

149
00:08:54,401 --> 00:09:00,474
デバッグナビゲータに表示され
フットプリントを確認できます

150
00:09:00,908 --> 00:09:04,978
Xcode 10ではシステムの
グレードも表示されますが―

151
00:09:05,078 --> 00:09:08,549
Xcode 9との違いは
気にしないでください

152
00:09:09,149 --> 00:09:13,053
XcodeでAppの実行をし
多くのメモリを消費しています

153
00:09:13,353 --> 00:09:15,022
調査に使うツールは？

154
00:09:15,289 --> 00:09:17,591
Instrumentsです

155
00:09:18,292 --> 00:09:21,695
これで様々な方法で
フットプリントの調査ができます

156
00:09:23,096 --> 00:09:25,732
AllocationsとLeaksは
ご存知ですね

157
00:09:25,833 --> 00:09:28,769
Allocationsは
ヒープの配置を分析し

158
00:09:28,869 --> 00:09:31,371
Leaksはメモリのリークを
チェックします

159
00:09:31,471 --> 00:09:35,175
そして聞きなれないVM Trackerと
Virtual Memory Traceです

160
00:09:36,443 --> 00:09:40,380
カイルがiOSの
メモリについて話しました―

161
00:09:40,480 --> 00:09:42,783
ダーティおよび圧縮メモリです

162
00:09:42,883 --> 00:09:46,153
VM Trackerはそれらを
分析できます

163
00:09:47,054 --> 00:09:51,058
ダーティと圧縮の
別々の記録を持ち

164
00:09:51,158 --> 00:09:53,494
レジデントサイズの情報を
提供します

165
00:09:53,994 --> 00:09:57,798
ダーティメモリのサイズ調査に
有効です

166
00:09:58,832 --> 00:10:01,535
最後はVirtual Memory Traceです

167
00:09:58,832 --> 00:10:01,535
最後はVirtual Memory Traceです

168
00:10:01,735 --> 00:10:06,507
Appの仮想メモリシステムの
パフォーマンスを表示します

169
00:10:09,009 --> 00:10:11,745
Operationタブから見られます

170
00:10:11,879 --> 00:10:15,983
仮想メモリの分析や
ページのキャッシュヒット数や

171
00:10:16,083 --> 00:10:18,519
ページのゼロフィルも表示されます

172
00:10:21,355 --> 00:10:27,161
デバイスのメモリが上限に近づくと
例外の警告を受け取ります

173
00:10:27,261 --> 00:10:29,730
Xcode 10でAppを起動すると

174
00:10:30,531 --> 00:10:33,467
Xcodeが例外をキャッチし
Appを停止します

175
00:10:33,567 --> 00:10:37,037
メモリデバッガを起動し
調査を開始できます

176
00:10:37,137 --> 00:10:38,939
とても便利です

177
00:10:40,674 --> 00:10:43,310
Xcode 8より導入されました

178
00:10:43,410 --> 00:10:46,980
オブジェクトの依存 サイクル
リークを追跡できます

179
00:10:47,080 --> 00:10:50,417
Xcode 10には
レイアウトのよい更新がありました

180
00:10:50,517 --> 00:10:53,353
大きなmemgraphが
見やすくなりました

181
00:10:53,887 --> 00:10:59,760
Xcodeがmemgraphを利用し
Appのメモリ情報を蓄積しています

182
00:11:00,060 --> 00:11:04,832
実は コマンドラインツールでも
memgraphを使えます

183
00:11:06,300 --> 00:11:08,802
まずXcodeからmemgraphを
エクスポートします

184
00:11:08,902 --> 00:11:10,103
とてもシンプルです

185
00:11:10,938 --> 00:11:15,075
エクスポートボタンを押して
保存するだけです

186
00:11:15,309 --> 00:11:16,076
そして

187
00:11:16,877 --> 00:11:21,448
そのmemgraphを
コマンドラインに移します

188
00:11:22,182 --> 00:11:26,220
私がXcode 10でAppを実行し
例外を受け取ったとして

189
00:11:26,320 --> 00:11:29,523
memgraphを使い調査します

190
00:11:29,623 --> 00:11:30,891
何をするのか？

191
00:11:30,991 --> 00:11:32,960
ターミナルへ行きます

192
00:11:34,128 --> 00:11:36,463
使うツールはvmmapです

193
00:11:36,563 --> 00:11:39,266
プロセスに割り当てられた
仮想メモリ領域を表示することで

194
00:11:39,366 --> 00:11:42,503
Appのメモリ消費の分析が
可能になります

195
00:11:43,871 --> 00:11:46,206
まずはsummary flagを
お薦めします

196
00:11:46,673 --> 00:11:50,978
領域のメモリのサイズを
詳細に表示し

197
00:11:52,713 --> 00:11:54,481
ダーティな領域も表示

198
00:11:55,449 --> 00:11:58,151
圧縮されたメモリ量も示します

199
00:11:58,252 --> 00:12:01,321
ダーティやスワップは
とても重要です

200
00:11:58,252 --> 00:12:01,321
ダーティやスワップは
とても重要です

201
00:12:01,922 --> 00:12:07,427
ただスワップサイズは
圧縮される前のサイズだということ

202
00:12:07,528 --> 00:12:09,263
圧縮サイズとは違います

203
00:12:10,197 --> 00:12:13,400
より詳細な情報を望む場合

204
00:12:13,500 --> 00:12:17,771
memgraphに対しvmmapを実行し
コンテンツを取得してください

205
00:12:17,871 --> 00:12:21,108
すると実行可能コードのような―

206
00:12:21,208 --> 00:12:23,177
書き込み不可能な領域が判明します

207
00:12:24,144 --> 00:12:27,147
これでインスタンスなどの
書き込み可能な領域も判明します

208
00:12:27,247 --> 00:12:29,149
ヒープがある場所です

209
00:12:30,684 --> 00:12:36,256
すべてのツールがコマンドライン
ユーティリティでうまく機能します

210
00:12:36,456 --> 00:12:39,827
先日VM Trackerで
私のAppを分析したところ

211
00:12:39,927 --> 00:12:42,930
ダーティメモリが増加していました

212
00:12:43,063 --> 00:12:44,331
そこでmemgraphを使い

213
00:12:44,832 --> 00:12:47,100
ダーティデータの原因となる―

214
00:12:47,201 --> 00:12:50,704
フレームワークや
ライブラリを探しました

215
00:12:52,206 --> 00:12:55,676
その時のmemgraphに
実行したvmmapです

216
00:12:56,243 --> 00:12:58,712
ページフラグを使いました

217
00:12:58,812 --> 00:13:02,850
バイト数の代わりに
ページ数で表示されます

218
00:12:58,812 --> 00:13:02,850
バイト数の代わりに
ページ数で表示されます

219
00:13:04,918 --> 00:13:06,720
私は検索のため グレップに―

220
00:13:06,820 --> 00:13:09,890
“ダイナミックライブラリ”と
挿入しました

221
00:13:10,991 --> 00:13:13,961
最後にawkスクリプトを挿入して

222
00:13:14,061 --> 00:13:18,332
ダーティなカラムを合算し
ページ数を表示させます

223
00:13:19,333 --> 00:13:21,835
便利なので
常にこれを使っています

224
00:13:21,935 --> 00:13:26,607
デベロッパにとって有効な
デバッギング作業となるでしょう

225
00:13:29,076 --> 00:13:33,514
macOSデベロッパはleaksを
ご存じかもしれません

226
00:13:33,780 --> 00:13:37,551
ランタイムにどこにも根付かない
オブジェクトを記録します

227
00:13:37,651 --> 00:13:41,788
leaksで見つかったオブジェクトは
開放不可なダーティメモリです

228
00:13:43,457 --> 00:13:45,259
メモリデバッガのリークを見ると

229
00:13:46,193 --> 00:13:51,598
互いに関連する
３つのオブジェクトがあります

230
00:13:51,765 --> 00:13:55,335
leaksツールで見てみましょう

231
00:13:56,603 --> 00:14:00,807
最新のleaksは
リークされたオブジェクト以外に

232
00:13:56,603 --> 00:14:00,807
最新のleaksは
リークされたオブジェクト以外に

233
00:14:01,808 --> 00:14:05,612
それらが属するサイクルも
表示されます

234
00:14:05,913 --> 00:14:08,582
mallocスタックログが
プロセス上で可能なら

235
00:14:08,682 --> 00:14:11,385
ルートノードの
バックトレースも提供されます

236
00:14:14,354 --> 00:14:17,691
メモリはどこへ行くのでしょう？

237
00:14:18,058 --> 00:14:22,329
vmmapを調べると
ヒープは本当に大きいです

238
00:14:22,563 --> 00:14:27,234
ヒープツールはプロセス上すべての
オブジェクト配置情報を提供します

239
00:14:27,334 --> 00:14:31,772
同じ種類のオブジェクトや
配置の追跡に役立ちます

240
00:14:34,274 --> 00:14:39,046
Xcodeがメモリリソースの例外を
キャッチした際のmemgraphです

241
00:14:39,146 --> 00:14:40,714
ヒープを調査します

242
00:14:40,814 --> 00:14:46,119
するとオブジェクト情報
クラス名などが分かります

243
00:14:47,087 --> 00:14:48,489
オブジェクトの数量や

244
00:14:49,490 --> 00:14:53,694
平均サイズや
合計サイズなども

245
00:14:54,895 --> 00:14:59,833
小さなオブジェクトも
多数 表示されますが

246
00:14:59,933 --> 00:15:02,236
それは問題ではありません

247
00:14:59,933 --> 00:15:02,236
それは問題ではありません

248
00:15:05,606 --> 00:15:07,841
ヒープは数でソートされます

249
00:15:08,308 --> 00:15:11,945
私が見たいのは
数ではなくサイズなので

250
00:15:12,045 --> 00:15:15,582
sortBySizeフラグを使い
サイズでソートします

251
00:15:16,583 --> 00:15:19,786
NSConcreteDataが巨大ですね

252
00:15:19,887 --> 00:15:24,992
結果はバグレポートにしますが
まだ十分ではありません

253
00:15:25,092 --> 00:15:26,860
源を探るのです

254
00:15:27,761 --> 00:15:31,265
NSConcreteDataの１つを
アドレスを取得します

255
00:15:31,899 --> 00:15:33,233
アドレスフラグを使い―

256
00:15:33,333 --> 00:15:38,071
クラス名でアドレス指定をすると
アドレスが取得できます

257
00:15:39,773 --> 00:15:43,010
データの源が分かりました

258
00:15:43,877 --> 00:15:46,146
ここでmallocのスタックログが
役立ちます

259
00:15:46,480 --> 00:15:50,184
システムが各配置を記録します

260
00:15:50,284 --> 00:15:53,253
ログはmemgraphの記録時に
キャプチャされ

261
00:15:53,353 --> 00:15:56,723
ツールの出力時に
注釈を付けます

262
00:15:57,090 --> 00:16:00,961
diagnosticsタブで設定可能です

263
00:15:57,090 --> 00:16:00,961
diagnosticsタブで設定可能です

264
00:16:01,428 --> 00:16:05,065
私のお薦めはLive Allocationsです

265
00:16:06,633 --> 00:16:10,537
memgraphはmallocスタックログに
キャプチャされました

266
00:16:10,804 --> 00:16:13,073
次は配置のバックトレースです

267
00:16:13,173 --> 00:16:15,242
使うのはmalloc historyです

268
00:16:15,509 --> 00:16:17,644
memgraphに
malloc historyをパス

269
00:16:17,744 --> 00:16:19,580
さらにインスタンスの
アドレスをパス

270
00:16:19,680 --> 00:16:21,982
バックトレースがあれば
表示されます

271
00:16:24,051 --> 00:16:27,387
これはNSConcreteDataの
アドレスの１つです

272
00:16:27,487 --> 00:16:29,189
malloc historyにパスすると

273
00:16:30,090 --> 00:16:31,358
バックトレースがありました

274
00:16:31,525 --> 00:16:36,830
NoirFilter.applyメソッドが
巨大なNSデータを生成しています

275
00:16:37,097 --> 00:16:42,002
これはバグレポートに添付して
誰かに見てもらいます

276
00:16:43,403 --> 00:16:48,375
以上はAppの動作を調査する
ほんの一部の方法です

277
00:16:48,609 --> 00:16:51,445
メモリ問題の対処に使うツールは？

278
00:16:52,045 --> 00:16:53,947
３つ考えられます

279
00:16:54,248 --> 00:16:55,983
オブジェクトの生成を見る場合

280
00:16:56,083 --> 00:16:58,919
オブジェクトに関連するものを
見る場合

281
00:16:59,019 --> 00:17:01,355
単にサイズを見たい場合

282
00:16:59,019 --> 00:17:01,355
単にサイズを見たい場合

283
00:17:02,356 --> 00:17:07,127
もしプロセス開始時に
mallocスタックログが有効なら

284
00:17:07,227 --> 00:17:09,930
malloc historyが オブジェクトの
バックトレースを見つけます

285
00:17:10,830 --> 00:17:13,267
オブジェクト関連を見たいなら

286
00:17:13,433 --> 00:17:18,338
leaksやその他のオプションを
使うことができます

287
00:17:19,172 --> 00:17:22,376
そしてサイズを確認したいなら

288
00:17:22,476 --> 00:17:24,411
vmmapとheapです

289
00:17:24,811 --> 00:17:30,484
私自身はvmmapとsummary flagを
使うことをお薦めします

290
00:17:30,584 --> 00:17:32,419
そしてスレッドに従います

291
00:17:34,054 --> 00:17:35,322
ここでカイルが―

292
00:17:35,422 --> 00:17:40,394
最大のオブジェクトである
画像について説明します

293
00:17:40,627 --> 00:17:41,161
カイル？

294
00:17:41,295 --> 00:17:46,233
(拍手)

295
00:17:46,333 --> 00:17:47,334
ありがとう

296
00:17:47,834 --> 00:17:48,402
それでは

297
00:17:48,902 --> 00:17:49,837
画像です

298
00:17:50,470 --> 00:17:53,507
画像で最も重要なことは

299
00:17:53,607 --> 00:17:59,079
メモリに関連するのはファイルの
サイズではなく寸法だということ

300
00:17:59,646 --> 00:18:05,886
ここにiPad Appの背景に使いたい
美しい画像があります

301
00:17:59,646 --> 00:18:05,886
ここにiPad Appの背景に使いたい
美しい画像があります

302
00:18:06,587 --> 00:18:10,124
寸法は幅が2048ピクセル
高さが1536ピクセル

303
00:18:10,457 --> 00:18:13,727
ディスク上で590キロバイトです

304
00:18:13,927 --> 00:18:16,497
さて メモリの使用量は？

305
00:18:18,732 --> 00:18:19,900
10メガバイトです

306
00:18:20,000 --> 00:18:22,202
とても大きいですね

307
00:18:22,469 --> 00:18:27,875
2048ピクセルと1536ピクセルの
積のサイズがその原因です

308
00:18:27,975 --> 00:18:31,178
1ピクセル４バイトなので
約10メガバイトになります

309
00:18:31,712 --> 00:18:34,381
なぜこんなに大きいのか？

310
00:18:34,948 --> 00:18:38,051
iOSでの画像の説明をします

311
00:18:38,151 --> 00:18:40,721
“Load”と“Decode”
そして“Render”があります

312
00:18:41,321 --> 00:18:47,728
ロードには590キロに圧縮された
JPEGファイルがあります

313
00:18:47,828 --> 00:18:49,129
メモリにロードします

314
00:18:49,797 --> 00:18:55,769
デコードではJPEGをGPUで
読み込めるフォーマットに変換

315
00:18:55,869 --> 00:18:59,406
この解凍で10メガバイトになります

316
00:18:59,907 --> 00:19:02,910
デコードすると
レンダーが可能です

317
00:18:59,907 --> 00:19:02,910
デコードすると
レンダーが可能です

318
00:19:03,477 --> 00:19:07,347
画像ついての詳細や
最適化の方法は―

319
00:19:07,448 --> 00:19:12,186
“Images and Graphics Best
Practice”のセッションをどうぞ

320
00:19:14,154 --> 00:19:17,824
画像はSRGBフォーマットで
表示されます

321
00:19:18,158 --> 00:19:22,196
これは最も典型的な
画像のフォーマットです

322
00:19:22,296 --> 00:19:24,298
１ピクセル８ビットです

323
00:19:25,699 --> 00:19:26,233
そのため

324
00:19:26,867 --> 00:19:32,005
赤が１バイト緑が１バイト
青が１バイトそしてその他

325
00:19:33,106 --> 00:19:34,608
さらに大きいのが

326
00:19:35,843 --> 00:19:39,213
iOSのワイドフォーマットです

327
00:19:39,313 --> 00:19:43,584
色が豊かになり
１ピクセルに２バイト必要です

328
00:19:43,684 --> 00:19:45,886
サイズが倍になりました

329
00:19:46,320 --> 00:19:51,291
iPhone 7 8 Ｘや
iPad Proなどのカメラは―

330
00:19:51,391 --> 00:19:55,462
このハイファイコンテンツに
対応しています

331
00:19:55,562 --> 00:19:59,333
スポーツロゴなどにも
使える精密さです

332
00:19:59,967 --> 00:20:05,072
しかし便利なのは
大きなディスプレイの場合です

333
00:19:59,967 --> 00:20:05,072
しかし便利なのは
大きなディスプレイの場合です

334
00:20:05,706 --> 00:20:08,175
つまり実際は小さなサイズでも
対応できます

335
00:20:08,308 --> 00:20:10,477
ルミナンスと
アルファ８フォーマットが

336
00:20:10,577 --> 00:20:14,681
これはグレースケールと
アルファ値のみで

337
00:20:14,848 --> 00:20:19,019
通常はMetal Appのような
シェーダなどで使われます

338
00:20:19,253 --> 00:20:21,288
一般的ではありません

339
00:20:21,388 --> 00:20:23,257
さらに小さくなると

340
00:20:23,690 --> 00:20:26,427
アルファ８フォーマットです

341
00:20:26,527 --> 00:20:29,062
１チャネルのみで
１ピクセル１バイトです

342
00:20:29,162 --> 00:20:29,797
とても小さく

343
00:20:29,897 --> 00:20:32,466
SRGBより75％も小さいので

344
00:20:33,033 --> 00:20:38,472
マスクやモノクロの
テキストなどに最適でしょう

345
00:20:39,006 --> 00:20:41,808
内訳を確認してみると

346
00:20:42,242 --> 00:20:47,347
１ピクセル１バイトから
１ピクセル８バイトまであり

347
00:20:47,448 --> 00:20:48,982
幅広いですね

348
00:20:49,082 --> 00:20:52,619
必要なのは
正しい選択を知ることです

349
00:20:52,886 --> 00:20:54,755
正しいフォーマットを選ぶには？

350
00:20:55,956 --> 00:20:58,358
フォーマットを選ばずに―

351
00:20:58,458 --> 00:20:59,960
選ばせます

352
00:21:01,061 --> 00:21:06,133
もしUIGraphicsBeginImageContext
WithOptionsを使っているなら

353
00:21:06,467 --> 00:21:09,136
これは初期からあったAPIですが

354
00:21:09,236 --> 00:21:12,206
UIGraphicsImageRendererに
変えてください

355
00:21:12,306 --> 00:21:14,942
メモリを抑えられますよ

356
00:21:15,042 --> 00:21:21,115
UIGraphicsBeginImageContext
WithOptionsは１ピクセル４バイト

357
00:21:21,949 --> 00:21:23,016
SRGBですね

358
00:21:23,116 --> 00:21:28,322
従ってワイドフォーマットも
アルファ８も使えません

359
00:21:28,689 --> 00:21:31,458
UIGraphicsImageRendererの
APIを使えば

360
00:21:31,558 --> 00:21:36,830
APIが自動的に
最適なフォーマットを選びます

361
00:21:38,465 --> 00:21:39,533
これが例です

362
00:21:39,633 --> 00:21:41,735
マスク用に円を描きます

363
00:21:41,902 --> 00:21:46,206
ハイライトされたdrawing codeを
処理するのは旧型のAPIですが

364
00:21:46,306 --> 00:21:50,177
黒い円を描くのに１ピクセルあたり
４バイトのフォーマットです

365
00:21:50,978 --> 00:21:55,282
新しいAPIに変更して
同様に実行すると

366
00:21:55,582 --> 00:21:59,052
１ピクセルあたり
１バイトになりました

367
00:21:59,152 --> 00:22:02,623
75％のメモリ削減になります

368
00:21:59,152 --> 00:22:02,623
75％のメモリ削減になります

369
00:22:02,723 --> 00:22:05,492
すばらしい節約ですね

370
00:22:08,161 --> 00:22:10,531
さらなる利点もあります

371
00:22:10,631 --> 00:22:14,067
マスクの再利用時
色の変更が可能です

372
00:22:14,434 --> 00:22:18,372
imageviewで複数色に変えられます

373
00:22:18,472 --> 00:22:21,175
更なるメモリは必要ありません

374
00:22:21,275 --> 00:22:23,477
黒の円だけではなく

375
00:22:23,577 --> 00:22:28,248
青や赤や緑の円を描いても
追加メモリは必要ありません

376
00:22:32,186 --> 00:22:35,122
その他の処理と言えば
ダウンサンプリングです

377
00:22:35,422 --> 00:22:39,293
サムネイル用などに
縮小したい場合

378
00:22:39,793 --> 00:22:42,896
UIImageは使いたくありません

379
00:22:42,996 --> 00:22:45,132
もしUIImageを使えば

380
00:22:45,232 --> 00:22:49,169
座標空間の変更が必要なため
パフォーマンスが悪くなるうえに

381
00:22:49,269 --> 00:22:53,106
メモリ内の画像を
解凍しなければなりません

382
00:22:53,574 --> 00:22:56,343
そこでImageIOフレームワークです

383
00:22:56,510 --> 00:22:59,079
ImageIOはダウンサンプルが可能で

384
00:22:59,179 --> 00:23:04,017
最終画像にはダーティメモリの
コストしか必要ないため

385
00:22:59,179 --> 00:23:04,017
最終画像にはダーティメモリの
コストしか必要ないため

386
00:23:04,117 --> 00:23:06,053
メモリ使用量の上昇を防ぎます

387
00:23:07,521 --> 00:23:10,357
例えば ディスクからファイルを
取得した際のコードです

388
00:23:10,457 --> 00:23:12,359
ダウンロードした
ファイルでも可です

389
00:23:12,893 --> 00:23:17,931
そしてUIImageを使い
小さい長方形を描きます

390
00:23:18,031 --> 00:23:20,267
メモリ使用量が上昇します

391
00:23:21,001 --> 00:23:25,672
今度はImageIOを使い ディスクから
ファイルをロードします

392
00:23:26,140 --> 00:23:31,245
画像の大きさを入力する
パラメータをセットします

393
00:23:31,678 --> 00:23:35,749
そしてCGImageSourceCreate
ThumbnailAtIndexを使い作成します

394
00:23:35,849 --> 00:23:38,919
CG画像は
UIImageでも作れます

395
00:23:39,019 --> 00:23:43,190
より小さな画像を
以前の半分の時間で手にしました

396
00:23:45,425 --> 00:23:49,396
次のトピックはバックグラウンドで
使用する場合の最適化です

397
00:23:49,830 --> 00:23:54,067
フルスクリーンのAppの画像が
あるとします

398
00:23:54,167 --> 00:23:55,769
とても美しい画像です

399
00:23:55,869 --> 00:24:01,275
しかし通知を確認する際などに
ホームスクリーンに戻ります

400
00:23:55,869 --> 00:24:01,275
しかし通知を確認する際などに
ホームスクリーンに戻ります

401
00:24:01,942 --> 00:24:03,977
画像はメモリの中です

402
00:24:04,545 --> 00:24:10,317
今までの経験から“表示されない
大きなリソースはアンロード”です

403
00:24:12,719 --> 00:24:13,821
方法は２つあります

404
00:24:13,921 --> 00:24:15,122
まずはApp lifecycleです

405
00:24:15,222 --> 00:24:21,128
バックグラウンドでも
フォアグラウンドでも使用できます

406
00:24:21,628 --> 00:24:27,601
UIViewControllerに準拠しておらず
オンスクリーンでの適用です

407
00:24:27,701 --> 00:24:30,938
UIViewControllerのメソッドは―

408
00:24:31,405 --> 00:24:34,308
複数view controllersがありますが

409
00:24:34,408 --> 00:24:36,477
スクリーンに
表示されるのは１枚です

410
00:24:36,643 --> 00:24:39,613
viewWillAppearや
viewDidDisappearを活用して

411
00:24:39,713 --> 00:24:43,150
メモリフットプリントを
小さくできます

412
00:24:43,984 --> 00:24:45,319
これが例です

413
00:24:46,153 --> 00:24:50,090
バックグラウンドにある
Appに通知をセットします

414
00:24:50,190 --> 00:24:53,026
この場合は
画像のアンロードをセットします

415
00:24:53,794 --> 00:24:56,697
Appがフォアグラウンドに来ると
通知されます

416
00:24:57,531 --> 00:24:59,199
画像をリロードしても

417
00:24:59,299 --> 00:25:04,238
バックグラウンドではメモリを
セーブでき 忠実性も維持できます

418
00:24:59,299 --> 00:25:04,238
バックグラウンドではメモリを
セーブでき 忠実性も維持できます

419
00:25:04,338 --> 00:25:08,509
システムに
メモリの余裕ができます

420
00:25:10,377 --> 00:25:14,381
Navigation Controllerや
Tab Bar Controllerと同様に

421
00:25:14,481 --> 00:25:17,584
ViewControllerは
画像が消えるとアンロードします

422
00:25:17,684 --> 00:25:21,955
そしてviewWillAppearで戻る前に
リロードできるので

423
00:25:22,055 --> 00:25:24,224
ユーザは違いを感じませんが

424
00:25:24,324 --> 00:25:27,060
メモリの使用量は減少します

425
00:25:30,030 --> 00:25:34,101
ここからは
クリスにデモをお願いしましょう

426
00:25:34,401 --> 00:25:35,102
クリス？

427
00:25:35,202 --> 00:25:39,973
(拍手)

428
00:25:40,073 --> 00:25:42,709
デモマシーンに切り替えます

429
00:25:43,277 --> 00:25:43,944
始めます

430
00:25:44,044 --> 00:25:45,445
使うのはこのAppです

431
00:25:45,546 --> 00:25:51,251
まずはこの高解像度の画像から
始めたいと思います

432
00:25:51,351 --> 00:25:56,256
NASAの太陽系の写真に
様々なフィルタを適用します

433
00:25:56,356 --> 00:26:00,828
簡単な例として 太陽に
フィルタを適用するのが見えます

434
00:25:56,356 --> 00:26:00,828
簡単な例として 太陽に
フィルタを適用するのが見えます

435
00:26:00,928 --> 00:26:03,497
これまでの結果に
満足しています

436
00:26:03,697 --> 00:26:06,266
私がジェイムスに意見を求めると

437
00:26:06,366 --> 00:26:09,570
返信メールに
ファイルが２つ添付されていました

438
00:26:09,837 --> 00:26:14,007
１つはmemgraphファイルで
もう１つはこの画像でした

439
00:26:15,742 --> 00:26:19,379
ジェイムスは
とても控えめな男性なので

440
00:26:19,479 --> 00:26:25,152
こんな絵文字を送るなんて
相当 混乱しているようです

441
00:26:25,819 --> 00:26:29,490
私は彼に“何が問題か分からない”

442
00:26:29,690 --> 00:26:33,861
“赤い部分に達してないから
まだ500メガバイトはあるはずだ”

443
00:26:33,961 --> 00:26:37,231
“使っていいだろう？”と
聞きました

444
00:26:37,798 --> 00:26:41,802
そして優秀なジェイムスは
私の考え方の―

445
00:26:41,902 --> 00:26:44,338
間違いを指摘しました

446
00:26:44,438 --> 00:26:50,377
まず このゲージは２ギガバイトの
デバイスの測定結果です

447
00:26:50,477 --> 00:26:52,713
それ以下のメモリの
デバイスもあります

448
00:26:52,813 --> 00:26:56,417
１ギガバイトのデバイスで
同じコードを実行したら

449
00:26:56,517 --> 00:27:00,420
AppはOSから
強制終了させられるでしょう

450
00:26:56,517 --> 00:27:00,420
AppはOSから
強制終了させられるでしょう

451
00:27:01,188 --> 00:27:02,189
第２に

452
00:27:03,123 --> 00:27:08,762
OSはAppを強制終了する際
今使用しているAppだけでなく

453
00:27:08,862 --> 00:27:13,567
他に実行されているAppや
OSのメモリも考慮します

454
00:27:13,967 --> 00:27:19,540
従って 赤い部分に達してなくても
強制終了の危険性はあります

455
00:27:20,107 --> 00:27:24,344
第３にユーザにとっては
最悪の例ですが

456
00:27:24,611 --> 00:27:27,414
使用量の比較を
示したチャートに―

457
00:27:27,514 --> 00:27:31,185
ゼロキロバイトの
メモリが存在します

458
00:27:31,485 --> 00:27:35,923
これはAppのスペースのために
OSから放棄されたメモリです

459
00:27:36,823 --> 00:27:40,260
ここで私をにらんでくださいね

460
00:27:40,360 --> 00:27:44,531
ユーザは他のAppを使う際
再ロードする必要があるからです

461
00:27:45,732 --> 00:27:47,167
ジェイムスは正しいです

462
00:27:47,267 --> 00:27:53,607
この針が示すメモリ使用量を
最大限小さくするために―

463
00:27:54,007 --> 00:27:56,076
何ができるでしょう

464
00:27:56,510 --> 00:27:59,112
memgraphファイルを見ます

465
00:28:01,115 --> 00:28:03,484
memgraphを使う時に―

466
00:28:05,285 --> 00:28:09,289
私にはいくつかの戦略があります

467
00:28:09,389 --> 00:28:12,960
第１に…
スクリーン表示を調整します

468
00:28:13,060 --> 00:28:15,095
まずリークを探します

469
00:28:15,362 --> 00:28:18,766
フィルタツールバーに行き

470
00:28:18,866 --> 00:28:20,534
leaksフィルタをクリックします

471
00:28:20,634 --> 00:28:24,538
memgraphにある
リークが表示されます

472
00:28:24,638 --> 00:28:27,841
このファイルにはありませんね

473
00:28:27,941 --> 00:28:30,978
これは良いニュースであり
悪いニュースでもあります

474
00:28:31,111 --> 00:28:35,449
何が起きているのか
調べる必要があります

475
00:28:36,583 --> 00:28:38,752
memgraphのいいところは―

476
00:28:38,852 --> 00:28:44,725
予測以上のインスタンス数を
表示してくれるところです

477
00:28:44,825 --> 00:28:45,959
このmemgraphを使って

478
00:28:46,059 --> 00:28:51,865
コードから特定のオブジェクトに
絞ると

479
00:28:51,965 --> 00:28:55,969
メモリには５つしかなく 実際は
１つずつなのが分かります

480
00:28:56,069 --> 00:28:59,172
複数のrootViewControllerや

481
00:28:59,273 --> 00:29:03,010
複数のnoirFilter
multiple filtersなどがあれば

482
00:28:59,273 --> 00:29:03,010
複数のnoirFilter
multiple filtersなどがあれば

483
00:29:03,110 --> 00:29:06,246
予想以上に
調べられることは多いでしょう

484
00:29:06,447 --> 00:29:10,083
予測以上の
インスタンスはないようです

485
00:29:10,184 --> 00:29:12,252
１つのサイズが大きいので

486
00:29:12,352 --> 00:29:14,254
念のため調べてみましょう

487
00:29:14,354 --> 00:29:18,158
メモリインスペクタを使い
確認します

488
00:29:18,258 --> 00:29:20,828
オブジェクトの
サイズがリスト化されます

489
00:29:20,928 --> 00:29:23,831
私のAppは32バイトです

490
00:29:23,931 --> 00:29:26,133
viewcontrollerのデータは1500

491
00:29:26,233 --> 00:29:27,868
よく見てみても

492
00:29:28,469 --> 00:29:33,106
ここにあるどのオブジェクトも
Appが１ギガを超えている―

493
00:29:33,240 --> 00:29:36,543
原因ではなさそうに思えます

494
00:29:37,010 --> 00:29:41,315
これがXcodeで
memgraphを扱う方法です

495
00:29:41,415 --> 00:29:42,816
次はどうしましょう？

496
00:29:43,217 --> 00:29:47,120
WWDCセッションで学んだ―

497
00:29:47,221 --> 00:29:51,158
コマンドラインツールを使います

498
00:29:51,425 --> 00:29:54,828
何か見つかるか試してみましょう

499
00:29:55,329 --> 00:29:58,332
ジェイムスのお薦めは―

500
00:29:58,432 --> 00:30:01,969
summary flagと
vmmapを使うことでした

501
00:29:58,432 --> 00:30:01,969
summary flagと
vmmapを使うことでした

502
00:30:02,736 --> 00:30:07,141
私のmemgraphファイルで
試してみましょう

503
00:30:09,376 --> 00:30:11,044
出力を確認します

504
00:30:11,678 --> 00:30:14,081
ここで私が探すべきは？

505
00:30:14,481 --> 00:30:16,583
普通は大きな数字ですね

506
00:30:16,683 --> 00:30:21,355
メモリの使用量が多い
何かを見つけるのです

507
00:30:21,488 --> 00:30:25,392
多くのカラムが存在しますね

508
00:30:25,492 --> 00:30:27,661
重要なものもあります

509
00:30:27,761 --> 00:30:32,399
まずは現実ではない
仮想サイズですが

510
00:30:32,499 --> 00:30:34,768
このカラムは無視します

511
00:30:34,868 --> 00:30:38,505
Appが要求したメモリですが
今は使用されていません

512
00:30:38,772 --> 00:30:42,409
ダーティは響きが悪いので
使用したくありませんね

513
00:30:42,509 --> 00:30:47,347
私は自分のAppは
クリーンなほうがいいです

514
00:30:47,448 --> 00:30:50,484
そして iOSなので
圧縮物を探します

515
00:30:51,318 --> 00:30:55,622
カイルとジェイムスが話したとおり

516
00:30:55,722 --> 00:30:58,892
ダーティなサイズと
圧縮されたサイズの合計が

517
00:30:58,992 --> 00:31:04,098
OSがAppのために
要求するメモリの容量です

518
00:30:58,992 --> 00:31:04,098
OSがAppのために
要求するメモリの容量です

519
00:31:04,198 --> 00:31:06,600
これら２つのカラムに注目し

520
00:31:06,700 --> 00:31:08,902
大きな数値を探します

521
00:31:09,002 --> 00:31:11,472
CG画像がすぐ目に入りました

522
00:31:11,572 --> 00:31:15,109
ダーティなサイズと
圧縮されたサイズです

523
00:31:15,209 --> 00:31:18,212
今はとにかく探し続けます

524
00:31:18,412 --> 00:31:23,183
IOSurfaceに大きな
ダーティサイズがあります

525
00:31:23,283 --> 00:31:25,018
圧縮されたサイズはありません

526
00:31:25,119 --> 00:31:28,655
MALLOC LARGEにも
ダーティサイズがありますね

527
00:31:28,755 --> 00:31:31,725
圧縮されたサイズはとても少量です

528
00:31:31,825 --> 00:31:35,429
他にはそれほど
大きなサイズのものはありません

529
00:31:35,529 --> 00:31:38,131
ここで見る限りでは

530
00:31:38,232 --> 00:31:42,736
仮想領域のCG画像に
集中していくべきですね

531
00:31:43,036 --> 00:31:45,038
それを理解した上で進みましょう

532
00:31:45,505 --> 00:31:47,908
次のステップは？

533
00:31:48,108 --> 00:31:51,678
仮想メモリについて知りたいですね

534
00:31:51,778 --> 00:31:54,481
vmmapに行きましょう

535
00:31:54,581 --> 00:32:00,754
今回はsummay flagではなく
Memgraghファイルを実行します

536
00:31:54,581 --> 00:32:00,754
今回はsummay flagではなく
Memgraghファイルを実行します

537
00:32:01,221 --> 00:32:04,224
心配なのはCG画像です

538
00:32:04,324 --> 00:32:08,896
vmmapが示す他の仮想メモリ領域は

539
00:32:08,996 --> 00:32:10,664
気にしません

540
00:32:10,764 --> 00:32:13,167
グレップを使いましょう

541
00:32:13,267 --> 00:32:17,838
CG画像についての
ラインが見たいです

542
00:32:17,938 --> 00:32:19,473
どうでしょうか？

543
00:32:20,007 --> 00:32:21,508
ラインは３つあり

544
00:32:21,608 --> 00:32:25,279
２つの仮想メモリ領域が
存在します

545
00:32:25,379 --> 00:32:28,782
それから
開始と終了のアドレスがあります

546
00:32:28,916 --> 00:32:31,518
上記と同じカラムと分かります

547
00:32:31,618 --> 00:32:36,557
仮想でかつ常駐
ダーティで圧縮されたラインです

548
00:32:36,657 --> 00:32:39,793
最後のラインは
サマリーラインなので

549
00:32:41,328 --> 00:32:44,098
上のラインと同じですね

550
00:32:44,464 --> 00:32:49,269
２つの領域のうち１つは小さく
片方は巨大です

551
00:32:49,369 --> 00:32:52,706
私はこの巨大な領域を
見たかったのです

552
00:32:53,841 --> 00:32:58,679
この領域について
より詳細を知るためには？

553
00:32:58,879 --> 00:33:01,915
vmmapについての
書類を見たところ

554
00:32:58,879 --> 00:33:01,915
vmmapについての
書類を見たところ

555
00:33:02,015 --> 00:33:04,551
verboseフラグに気づきました

556
00:33:04,651 --> 00:33:08,755
このverboseフラグは
多くの情報を出力します

557
00:33:08,856 --> 00:33:10,824
何が分かるでしょうか？

558
00:33:11,425 --> 00:33:16,396
verboseとmemgraphを
実行してみましょう

559
00:33:17,831 --> 00:33:23,370
再度言いますが
私が注視するのはCG画像の領域のみ

560
00:33:23,470 --> 00:33:26,306
グレップを使いフィルタをかけます

561
00:33:26,840 --> 00:33:30,043
多くの領域が現れました

562
00:33:30,144 --> 00:33:31,678
どうでしょうか？

563
00:33:31,778 --> 00:33:34,281
さてvmmapは初期設定で―

564
00:33:34,381 --> 00:33:38,752
連続した領域が見つかると
一緒に折り畳みます

565
00:33:38,852 --> 00:33:41,755
２ライン目を見てみましょう

566
00:33:41,855 --> 00:33:46,293
この領域の
終了と開始のアドレスが同じです

567
00:33:46,393 --> 00:33:48,796
同じパターンが続いているので―

568
00:33:48,896 --> 00:33:52,733
vmmapがそれらを
単一の領域に変えます

569
00:33:52,900 --> 00:33:55,802
いくつかの違いにも気づきます

570
00:33:55,903 --> 00:34:00,507
ダーティなメモリを
さらに使用するものもあり

571
00:33:55,903 --> 00:34:00,507
ダーティなメモリを
さらに使用するものもあり

572
00:34:00,607 --> 00:34:02,576
圧縮されたメモリもある

573
00:34:02,676 --> 00:34:06,647
注目すべきものが分かりました

574
00:34:06,780 --> 00:34:09,083
しかし別の方法を使います

575
00:34:09,183 --> 00:34:13,821
必須ではないですが
一般的なルールとして

576
00:34:14,021 --> 00:34:18,725
仮想メモリ領域作成が遅れると

577
00:34:18,824 --> 00:34:21,962
Appの作動も遅くなります

578
00:34:22,062 --> 00:34:26,699
このmemgraphはメモリ使用量の
上昇中に取得されたので

579
00:34:26,934 --> 00:34:32,339
これらの領域は
メモリの上昇と関連しています

580
00:34:32,505 --> 00:34:38,445
最大のダーティや圧縮サイズでなく
領域の最後から探ってみます

581
00:34:39,746 --> 00:34:42,716
最終領域の最初のアドレスを取得し

582
00:34:43,116 --> 00:34:45,152
次にすることは？

583
00:34:45,786 --> 00:34:50,556
ジェイムスが先に述べた
ヒープがありますが

584
00:34:50,757 --> 00:34:55,696
ただし仮想メモリ領域では
役に立ちません

585
00:34:56,330 --> 00:34:59,299
試したいリークは存在せず

586
00:34:59,399 --> 00:35:04,538
Memgraphにも見当たらないので
leaksは使えません

587
00:34:59,399 --> 00:35:04,538
Memgraphにも見当たらないので
leaksは使えません

588
00:35:04,638 --> 00:35:09,676
leaksに関するヘルプ情報を
調べてみました

589
00:35:09,777 --> 00:35:11,879
leaksでできることは多く

590
00:35:11,979 --> 00:35:17,217
ヒープ上や仮想メモリ領域の
関連オブジェクトも―

591
00:35:17,317 --> 00:35:19,119
示してくれます

592
00:35:19,253 --> 00:35:21,355
進めてみましょう

593
00:35:21,622 --> 00:35:27,828
leaksを使いtraceTreeフラグに
パスしてみます

594
00:35:27,961 --> 00:35:30,998
これで関連するアドレスの―

595
00:35:31,098 --> 00:35:34,868
ツリービューが表示されます

596
00:35:34,968 --> 00:35:38,772
ここで私の仮想メモリ領域の―

597
00:35:38,872 --> 00:35:42,209
開始のアドレスをパスします

598
00:35:42,376 --> 00:35:45,279
最後にmemgraphファイルを
提供します

599
00:35:46,213 --> 00:35:47,247
どうなるでしょう？

600
00:35:47,347 --> 00:35:50,918
関連するツリーを見てみましょう

601
00:35:51,018 --> 00:35:52,519
スクロールをして

602
00:35:53,120 --> 00:35:54,788
上を見てみます

603
00:35:54,888 --> 00:35:58,926
仮想メモリ領域と
CG画像領域があります

604
00:35:59,026 --> 00:36:01,729
そしてツリービューがあります

605
00:35:59,026 --> 00:36:01,729
そしてツリービューがあります

606
00:36:01,829 --> 00:36:06,800
関連するものが
すべて表示されています

607
00:36:06,934 --> 00:36:09,670
ここでXcodeに戻り―

608
00:36:09,770 --> 00:36:12,472
同じアドレスでフィルタをかけます

609
00:36:13,474 --> 00:36:16,143
そしてオブジェクトを見ると

610
00:36:16,443 --> 00:36:19,313
ツリーはリークスから得たものと
全く同じもので

611
00:36:19,413 --> 00:36:23,417
ノードの１つ１つを
展開することも可能です

612
00:36:23,517 --> 00:36:25,786
詳細を見てみましょう

613
00:36:26,219 --> 00:36:28,255
少し時間がかかるし退屈です

614
00:36:28,355 --> 00:36:31,458
leaksの出力で良い点は

615
00:36:31,558 --> 00:36:36,396
スキャンや検索や
フィルタが素早くできること

616
00:36:36,497 --> 00:36:39,667
バグレポートや
Eメールに挿入可能なことです

617
00:36:39,767 --> 00:36:43,537
Xcodeのグラフィカルビューでは
不可能です

618
00:36:43,637 --> 00:36:45,973
何が見つかるでしょう？

619
00:36:46,106 --> 00:36:47,508
理想的には

620
00:36:47,608 --> 00:36:52,512
私のAppのクラスを
見つけたいですね

621
00:36:52,613 --> 00:36:56,517
ですがクラスがないことは
確認済みです

622
00:36:56,617 --> 00:36:58,218
さてどうしましょう？

623
00:36:58,318 --> 00:37:01,855
フレームワークのようなクラスは

624
00:36:58,318 --> 00:37:01,855
フレームワークのようなクラスは

625
00:37:01,955 --> 00:37:05,426
代理もしくは
直接作ったものです

626
00:37:05,526 --> 00:37:09,697
私のAppにはUiviewがあり
UIImageがあります

627
00:37:09,797 --> 00:37:14,468
そしてコアイメージクラスを
フィルタリングに使っています

628
00:37:14,568 --> 00:37:16,437
先に進みましょう

629
00:37:16,537 --> 00:37:21,074
洗練されたデバッグツールを
調べてみましょう

630
00:37:21,542 --> 00:37:24,177
さらに見ていきますよ

631
00:37:25,779 --> 00:37:28,749
欲しいものがあるでしょうか

632
00:37:31,118 --> 00:37:32,920
大きな出力です

633
00:37:33,020 --> 00:37:34,755
少し混乱しますね

634
00:37:35,055 --> 00:37:38,025
例えばフォントに関連するものです

635
00:37:38,125 --> 00:37:40,627
私のAppで使っています

636
00:37:40,728 --> 00:37:45,432
フォントは メモリを
大量には消費しませんので

637
00:37:45,532 --> 00:37:47,234
意味がありません

638
00:37:47,868 --> 00:37:50,204
下部を見てみると

639
00:37:50,571 --> 00:37:54,508
CIクラスが
多数表示されています

640
00:37:54,608 --> 00:37:57,544
これはコアイメージフィルタなどで

641
00:37:57,644 --> 00:38:00,247
Appのフィルタ機能を作成します

642
00:37:57,644 --> 00:38:00,247
Appのフィルタ機能を作成します

643
00:38:00,681 --> 00:38:04,184
これも確認しておきたいことです

644
00:38:04,284 --> 00:38:08,021
しかし既に確認し
何も見つかりませんでした

645
00:38:09,223 --> 00:38:13,126
従ってleaksの出力は
必要ありませんね

646
00:38:13,227 --> 00:38:14,995
残念でした

647
00:38:15,596 --> 00:38:18,465
次はどうしましょう？

648
00:38:19,500 --> 00:38:25,372
幸いにもジェイムスには
メモリバックトレースがありました

649
00:38:25,472 --> 00:38:29,409
memgraphをキャプチャした際に
記録したものです

650
00:38:29,510 --> 00:38:32,546
従って別のツールを使います

651
00:38:32,646 --> 00:38:36,717
それでオブジェクトの
バックトレースを見ましょう

652
00:38:36,817 --> 00:38:38,919
malloc historyを使います

653
00:38:40,053 --> 00:38:44,024
まずmemgraphファイルにパスします

654
00:38:45,859 --> 00:38:50,698
ヘルプ文書から
fullStacksフラグにパスします

655
00:38:50,998 --> 00:38:56,970
そして人間が読みやすいように
出力します

656
00:38:57,071 --> 00:39:01,408
次に仮想メモリ領域の
開始アドレスにパスをして

657
00:38:57,071 --> 00:39:01,408
次に仮想メモリ領域の
開始アドレスにパスをして

658
00:39:01,775 --> 00:39:03,277
様子を見ます

659
00:39:03,977 --> 00:39:10,417
バックトレースは大きくないので
コードがラインに表示されています

660
00:39:10,517 --> 00:39:14,388
ライン６から９は
私のAppのコードです

661
00:39:14,488 --> 00:39:16,823
ライン６にあるのは

662
00:39:16,924 --> 00:39:19,660
NoirFilter apply関数で

663
00:39:19,760 --> 00:39:24,798
特定の仮想メモリ領域作成の
元になっています

664
00:39:24,898 --> 00:39:31,572
私のAppでどの部分がメモリを
使用しているかが分かる証拠です

665
00:39:31,805 --> 00:39:34,441
Memgraphファイルに戻ると

666
00:39:34,541 --> 00:39:38,879
Xcodeと同じバックトレースが
見て取れます

667
00:39:39,146 --> 00:39:42,983
NoirFilter applyメソッドも
あります

668
00:39:43,183 --> 00:39:48,655
実際にデバッグしていないので
ハイライトは見られません

669
00:39:48,755 --> 00:39:50,390
memgraphファイルを
読み込んでいるので

670
00:39:50,490 --> 00:39:53,927
malloc historyと
同じ出力ですね

671
00:39:54,294 --> 00:39:59,299
そして実際に
さらに確認をしてみると

672
00:39:59,399 --> 00:40:05,772
仮想メモリ領域の
CG画像のフルリストがあります

673
00:39:59,399 --> 00:40:05,772
仮想メモリ領域の
CG画像のフルリストがあります

674
00:40:05,873 --> 00:40:10,711
下から２番目の行をクリックして
移動させます

675
00:40:10,811 --> 00:40:13,514
バックトレースを見ましょう

676
00:40:15,482 --> 00:40:17,351
同じバックトレースですね

677
00:40:17,451 --> 00:40:20,721
同じコードパスが
その領域にもあります

678
00:40:20,988 --> 00:40:24,191
いくつかの領域を見てみると―

679
00:40:24,291 --> 00:40:26,727
バックトレースは同じでした

680
00:40:26,827 --> 00:40:31,665
さて これで
アプリケーションのどの部分が

681
00:40:31,765 --> 00:40:36,236
仮想メモリ領域を作成する原因と
なるのかが分かりました

682
00:40:36,603 --> 00:40:38,505
どうしましょうか？

683
00:40:38,605 --> 00:40:42,643
Xcodeに戻り
memgraphファイルを閉じます

684
00:40:43,377 --> 00:40:48,082
私が最初にしたいことは
このコードの中の―

685
00:40:48,348 --> 00:40:50,784
フィルタを見ると

686
00:40:52,219 --> 00:40:54,955
apply関数があるのが分かります

687
00:40:55,055 --> 00:40:57,391
さらに何かが表示されています

688
00:40:57,491 --> 00:41:01,962
UIGraphicsBeginImage
ContextWithOptionsや―

689
00:40:57,491 --> 00:41:01,962
UIGraphicsBeginImage
ContextWithOptionsや―

690
00:41:02,362 --> 00:41:06,733
UIGraphicsEnd
ImageContextよりも

691
00:41:06,833 --> 00:41:09,436
この状況に最適なAPIがあります

692
00:41:09,603 --> 00:41:14,308
まずは基準値を
設定する必要があります

693
00:41:14,408 --> 00:41:20,314
Appのメモリ消費に どれほど
影響があるか確かめるためです

694
00:41:20,414 --> 00:41:23,083
Appを実行してみます

695
00:41:23,584 --> 00:41:28,455
そしてデバッグナビゲータで
メモリレポートを確認します

696
00:41:28,555 --> 00:41:32,993
私のAppのメモリ使用量を
見てみましょう

697
00:41:33,394 --> 00:41:37,631
私はこの土星の北極の
画像が大好きです

698
00:41:37,798 --> 00:41:42,770
奇妙な六角形が
クールで 少し不気味です

699
00:41:43,170 --> 00:41:47,307
フィルタを適用して
結果を見ましょう

700
00:41:47,608 --> 00:41:53,046
１ギガ ３ギガ ４ギガ ６ギガ
７ギガ

701
00:41:53,146 --> 00:41:55,182
最悪です

702
00:41:57,518 --> 00:42:02,189
しかしこれはデバイスでは
使い物になりません

703
00:41:57,518 --> 00:42:02,189
しかしこれはデバイスでは
使い物になりません

704
00:42:02,289 --> 00:42:06,894
シミュレータ実行時は
デバッグやテストに役に立ちます

705
00:42:06,994 --> 00:42:09,997
デバイス上でも確認しましょう

706
00:42:10,097 --> 00:42:14,101
シミュレータは決して
メモリ不足になりません

707
00:42:14,201 --> 00:42:18,972
Appが強制終了された時は
シミュレータを使ってみてください

708
00:42:19,073 --> 00:42:23,277
割り当てができるので
強制終了されることはありません

709
00:42:23,377 --> 00:42:25,512
それで調査もできます

710
00:42:25,612 --> 00:42:30,951
ここに表示されている
グラフに注目したいと思います

711
00:42:31,985 --> 00:42:34,788
7.7ギガバイトに達しています

712
00:42:34,922 --> 00:42:36,256
ひどいですね

713
00:42:37,024 --> 00:42:39,593
さて 何ができるでしょう？

714
00:42:40,794 --> 00:42:44,231
ここでapply関数に戻ります

715
00:42:44,331 --> 00:42:48,669
beginImageContextWith
Optionsに戻りますが

716
00:42:48,769 --> 00:42:51,305
カイルの言葉を思い出します

717
00:42:51,405 --> 00:42:56,510
画像を扱っている時
メモリに関して最も重要なことは？

718
00:42:56,643 --> 00:42:58,045
画像のサイズです

719
00:42:58,145 --> 00:43:01,014
それでは見てみましょう

720
00:42:58,145 --> 00:43:01,014
それでは見てみましょう

721
00:43:01,115 --> 00:43:04,418
再度フィルタを挿入します

722
00:43:06,620 --> 00:43:08,755
デバッガで停止したら

723
00:43:10,991 --> 00:43:14,395
画像のサイズを確認します

724
00:43:14,495 --> 00:43:19,900
そして戻ってくる前に
水を飲みます

725
00:43:20,601 --> 00:43:23,270
やはり飲むのはやめました

726
00:43:24,571 --> 00:43:27,841
これは１万5000と１万3000の積です

727
00:43:27,941 --> 00:43:29,810
文書を見ると

728
00:43:29,910 --> 00:43:34,314
UIImageでは
ピクセルではなくポイントでした

729
00:43:34,548 --> 00:43:37,584
2Xもしくは3Xのデバイスであれば

730
00:43:37,684 --> 00:43:41,321
さらに大きい数を
掛ける必要があります

731
00:43:41,421 --> 00:43:45,125
カイルは10メガバイトで
驚いていました

732
00:43:45,225 --> 00:43:47,494
これは彼には秘密です

733
00:43:47,928 --> 00:43:51,398
試したいことがあります

734
00:43:51,498 --> 00:43:52,599
やってみます

735
00:43:53,734 --> 00:43:58,705
１万5000と１万3000の積として

736
00:43:59,506 --> 00:44:03,510
iPhone Xは3Xデバイスなので
幅３を掛けます

737
00:43:59,506 --> 00:44:03,510
iPhone Xは3Xデバイスなので
幅３を掛けます

738
00:44:04,711 --> 00:44:10,083
さらに高さ３を掛け
１ピクセル４バイトも掛けます

739
00:44:11,852 --> 00:44:14,154
また大きな数字ですね

740
00:44:15,789 --> 00:44:21,929
メモリの内7.5ギガバイツほどを
使用しているということです

741
00:44:23,096 --> 00:44:25,933
原因はbeginImageContextではなく

742
00:44:26,033 --> 00:44:27,601
画像サイズでした

743
00:44:27,701 --> 00:44:30,804
画像は大きくなくてよいです

744
00:44:30,904 --> 00:44:35,008
自分のビューと同じ寸法へ
縮小したいです

745
00:44:35,108 --> 00:44:37,244
メモリの削減にもなります

746
00:44:37,444 --> 00:44:40,214
画像をロードするコードに
戻ります

747
00:44:40,314 --> 00:44:43,384
その前にブレークポイントを
無効にします

748
00:44:44,785 --> 00:44:46,153
どうなるか見てみましょう

749
00:44:46,253 --> 00:44:47,521
簡単ですね

750
00:44:47,621 --> 00:44:49,923
バンドルからURLを取得し

751
00:44:50,023 --> 00:44:54,061
URLのデータから
UIImageにロードしています

752
00:44:54,161 --> 00:44:57,031
それがフィルタにパスされます

753
00:44:57,364 --> 00:45:01,902
フィルタに渡る前に
画像を縮小したいです

754
00:44:57,364 --> 00:45:01,902
フィルタに渡る前に
画像を縮小したいです

755
00:45:02,002 --> 00:45:04,405
カイルの言っていたように

756
00:45:04,505 --> 00:45:06,540
UIImageは使いません

757
00:45:06,640 --> 00:45:11,545
画像全体をメモリに
読む込むことは避けたいからです

758
00:45:12,379 --> 00:45:15,883
この関数は使わないでおきます

759
00:45:16,150 --> 00:45:20,220
カイルの提案どおりの
コードに置き換えます

760
00:45:22,589 --> 00:45:24,958
すると どうなるでしょう？

761
00:45:25,792 --> 00:45:30,664
バンドルから画像を取得します

762
00:45:30,898 --> 00:45:31,732
今回は―

763
00:45:31,832 --> 00:45:34,301
少し幅を広げて…

764
00:45:34,735 --> 00:45:37,838
CGImageSourceCreateWithURLを
呼び出します

765
00:45:37,938 --> 00:45:43,977
それからCGImageSourceCreate
ThumbnailAtIndexにパスし

766
00:45:44,077 --> 00:45:49,516
全体をメモリに読み込まずとも
サイズが変更できます

767
00:45:49,950 --> 00:45:52,753
違いを確認しましょう

768
00:45:52,853 --> 00:45:54,488
再構築します

769
00:45:55,823 --> 00:45:58,559
そしてAppの起動を待ちます

770
00:45:59,426 --> 00:46:01,028
一旦表示されると…

771
00:45:59,426 --> 00:46:01,028
一旦表示されると…

772
00:46:01,995 --> 00:46:03,964
おっと 警告が出ました

773
00:46:07,901 --> 00:46:10,037
この部分を省きます

774
00:46:10,938 --> 00:46:12,005
どうなるでしょう

775
00:46:12,740 --> 00:46:14,475
作っています

776
00:46:15,208 --> 00:46:16,777
作成中です

777
00:46:17,211 --> 00:46:19,246
出来上がりました

778
00:46:19,346 --> 00:46:22,115
メモリレポートを確認し

779
00:46:22,850 --> 00:46:26,186
土星の北極の画像に戻りましょう

780
00:46:26,286 --> 00:46:28,989
これが ずっと言いたかったんです

781
00:46:29,857 --> 00:46:33,327
画像がどうなるか見てみましょう

782
00:46:33,427 --> 00:46:36,797
75…93メガバイトになりました

783
00:46:36,897 --> 00:46:41,435
グラフの最高点は93メガバイトです

784
00:46:41,568 --> 00:46:43,337
著しく向上しました

785
00:46:43,437 --> 00:46:45,472
(拍手)

786
00:46:45,572 --> 00:46:51,411
シャットダウン寸前の
7.5ギガバイトからの改善です

787
00:46:52,179 --> 00:46:54,915
ここで戻りたいと思います

788
00:46:55,015 --> 00:46:58,018
そして停止させます

789
00:46:58,118 --> 00:47:01,121
フィルタメソッドに戻り

790
00:46:58,118 --> 00:47:01,121
フィルタメソッドに戻り

791
00:47:02,122 --> 00:47:07,061
UIBeginImageContextを
カイルの提案どおりに変更します

792
00:47:07,161 --> 00:47:10,497
このコードを消すことにして

793
00:47:10,597 --> 00:47:13,467
新たなフィルタを追加します

794
00:47:14,401 --> 00:47:19,273
そしてUIGraphicsImageRendererを
使います

795
00:47:19,373 --> 00:47:24,311
そしてこのRenderer内で
フィルタを適用するため

796
00:47:25,178 --> 00:47:26,146
CIFilterを使います

797
00:47:27,681 --> 00:47:29,183
実行します

798
00:47:29,283 --> 00:47:30,517
願わくは―

799
00:47:30,617 --> 00:47:34,321
メモリ使用量の違いが
現れますように

800
00:47:35,956 --> 00:47:40,160
デバッグナビゲータと
メモリレポートに戻りましょう

801
00:47:40,561 --> 00:47:44,031
そして再び 土星の画像に戻ります

802
00:47:46,667 --> 00:47:50,637
ここでフィルタを適用させます

803
00:47:51,338 --> 00:47:54,708
これでグラフがどうなるか？

804
00:47:54,808 --> 00:47:55,909
98メガバイトですね

805
00:47:56,010 --> 00:47:58,879
先ほどと ほぼ同じですね

806
00:47:58,979 --> 00:48:02,082
私が期待したとおりです

807
00:47:58,979 --> 00:48:02,082
私が期待したとおりです

808
00:48:02,182 --> 00:48:06,487
画像は１ピクセルあたり
４バイトを使用しています

809
00:48:06,587 --> 00:48:10,724
ここではメモリ削減が
目標ではありません

810
00:48:10,824 --> 00:48:14,361
しかし削減のチャンスはあります

811
00:48:14,728 --> 00:48:19,700
例えばOSがピクセルあたりの
バイト数を少なくしたり

812
00:48:19,800 --> 00:48:24,137
さらなるバイト数を要求しても
問題はないです

813
00:48:24,471 --> 00:48:29,710
大きな向上はないですが
私のコードは改善しました

814
00:48:30,477 --> 00:48:33,414
まだできることがあります

815
00:48:33,514 --> 00:48:37,117
Appがバックグラウンドに入った時
画像をアンロードし

816
00:48:37,217 --> 00:48:41,221
スクリーンにない画像はビューに
表示しないようにするなどです

817
00:48:41,321 --> 00:48:44,858
しかし この結果に
本当に満足しています

818
00:48:44,958 --> 00:48:46,927
ジェイムスに返送しましょう

819
00:48:47,461 --> 00:48:52,800
スクリーンショットと共に
注意書きを付けます

820
00:48:52,900 --> 00:48:56,136
私の喜びを知ってもらいたいのです

821
00:48:56,236 --> 00:48:59,206
私が彼に送るのは―

822
00:49:01,809 --> 00:49:03,944
目が星の絵文字です

823
00:49:04,478 --> 00:49:07,781
ジェイムスが
喜んでくれると願います

824
00:49:08,682 --> 00:49:13,220
では最後を締めてくれる
カイルを呼びましょう

825
00:49:13,320 --> 00:49:13,854
ありがとうございました

826
00:49:13,954 --> 00:49:16,623
(拍手)

827
00:49:16,723 --> 00:49:17,724
ありがとう　クリス

828
00:49:20,027 --> 00:49:21,094
ありがとう

829
00:49:21,528 --> 00:49:22,563
すばらしいですね

830
00:49:22,663 --> 00:49:28,235
少しの作業でメモリ使用量を
大幅に削減できました

831
00:49:30,704 --> 00:49:35,809
まとめるとメモリとは
有限で共有物だということ

832
00:49:36,477 --> 00:49:39,079
個人が使えば他人は使えない

833
00:49:39,179 --> 00:49:43,851
メモリは必要な分だけを使う
心がけが必要です

834
00:49:46,553 --> 00:49:50,524
デバッグの際は
Xcodeのメモリレポートが重要です

835
00:49:50,624 --> 00:49:53,660
Appの実行時に
Xcodeも実行すれば

836
00:49:53,760 --> 00:49:57,631
デバッグで不具合に
気づくことができるでしょう

837
00:49:59,333 --> 00:50:03,637
iOSは画像フォーマットを
選択します

838
00:49:59,333 --> 00:50:03,637
iOSは画像フォーマットを
選択します

839
00:50:03,737 --> 00:50:07,474
SRGBからアルファ８で
75％のメモリを節約できたのは

840
00:50:07,574 --> 00:50:12,679
UIImageGraphicsRendererの
使用によるものです

841
00:50:12,780 --> 00:50:15,115
マスクやテキストに最適です

842
00:50:16,350 --> 00:50:20,821
画像をダウンサンプリングする際は
ImageIOを使用します

843
00:50:21,188 --> 00:50:23,857
メモリの急上昇を避け

844
00:50:23,957 --> 00:50:27,227
UIImageでの
描画よりも高速です

845
00:50:29,129 --> 00:50:33,801
画面上にない画像やリソースを
アンロードしたいのです

846
00:50:33,901 --> 00:50:37,204
ユーザが見えないもので
メモリを消費するのは無意味です

847
00:50:38,205 --> 00:50:41,341
これだけやっても
まだ足りません

848
00:50:41,942 --> 00:50:44,478
Memgraphの使用は

849
00:50:44,578 --> 00:50:48,549
メモリフットプリントの
削減と状況把握に役立ちます

850
00:50:48,649 --> 00:50:53,420
malloc historyとの組み合わせで
メモリの状態が把握できました

851
00:50:54,121 --> 00:50:57,858
従って
私が皆さんにお薦めするのは

852
00:50:57,958 --> 00:51:01,895
malloc historyを使い
ツールを分析することです

853
00:50:57,958 --> 00:51:01,895
malloc historyを使い
ツールを分析することです

854
00:51:03,497 --> 00:51:07,301
詳細はスライドをご参照ください

855
00:51:07,401 --> 00:51:08,602
そしてさらに

856
00:51:09,436 --> 00:51:14,408
質問がある方はこの後
ラボにお越しください

857
00:51:15,075 --> 00:51:17,511
WWDCへの
ご参加ありがとうございます

858
00:51:17,611 --> 00:51:22,349
(拍手)