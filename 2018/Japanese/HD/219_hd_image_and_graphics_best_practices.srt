
1
00:00:07,074 --> 00:00:16,550
(音楽)

2
00:00:19,019 --> 00:00:24,825
(拍手)

3
00:00:24,925 --> 00:00:28,795
画像処理の最良事例を
ご紹介します

4
00:00:28,896 --> 00:00:31,064
私はカイルです

5
00:00:31,565 --> 00:00:33,734
画像コンテンツの―

6
00:00:33,834 --> 00:00:38,472
効率的な処理技術について
お話ししましょう

7
00:00:39,740 --> 00:00:45,078
UIImageと
UIImageViewは

8
00:00:45,479 --> 00:00:50,250
画像に使用する
UIKitのツールです

9
00:00:51,051 --> 00:00:57,291
アプリケーションにおける
UIKitの描画法をご紹介し

10
00:00:58,025 --> 00:01:03,764
最後はCPUとGPUを
統合する技術についても

11
00:00:58,025 --> 00:01:03,764
最後はCPUとGPUを
統合する技術についても

12
00:01:04,063 --> 00:01:05,465
軽く触れます

13
00:01:06,667 --> 00:01:09,203
今回 特に注目するのは

14
00:01:09,303 --> 00:01:13,340
デバイスで不足する
２つのリソース

15
00:01:13,440 --> 00:01:15,709
メモリとCPUです

16
00:01:16,210 --> 00:01:19,513
この２つは
分けて考えがちですよね

17
00:01:19,613 --> 00:01:25,752
デバッグナビゲータも
Instrumentsも違います

18
00:01:25,886 --> 00:01:28,288
しかし関連があります

19
00:01:29,323 --> 00:01:34,428
アプリケーションが
CPUを多く使えば

20
00:01:34,928 --> 00:01:39,867
バッテリーの寿命が縮み
処理が遅くなります

21
00:01:40,634 --> 00:01:42,970
しかし お気づきですか？

22
00:01:43,070 --> 00:01:48,175
各種のアプリケーションが
メモリを消費すると

23
00:01:48,275 --> 00:01:51,478
CPUの使用量も増えます

24
00:01:51,612 --> 00:01:55,949
バッテリーや
処理速度に悪影響です

25
00:01:56,283 --> 00:01:59,586
リソースを
うまく使いましょう

26
00:02:01,688 --> 00:02:05,225
写真の処理を例に
ご説明します

27
00:02:05,592 --> 00:02:09,496
写真Appがいいでしょう

28
00:02:10,130 --> 00:02:12,099
この写真を使います

29
00:02:12,332 --> 00:02:18,539
画像データを扱う
上位クラスのUIImageで

30
00:02:18,639 --> 00:02:22,609
リッチコンテンツを
表示します

31
00:02:23,577 --> 00:02:27,347
画像コンテンツは
２種類あります

32
00:02:27,548 --> 00:02:30,851
つまり写真と図形です

33
00:02:31,318 --> 00:02:35,889
UIImageは
ボタンのアイコンなどの

34
00:02:36,056 --> 00:02:38,225
表示にも使います

35
00:02:39,893 --> 00:02:42,062
UIImageViewは

36
00:02:42,296 --> 00:02:47,301
UIImageを表示するための
クラスです

37
00:02:50,337 --> 00:02:55,475
MVCではUIImageは
モデルオブジェクト

38
00:02:55,576 --> 00:02:58,946
UIImageViewはビューです

39
00:02:59,513 --> 00:03:04,651
モデルとビューには
それぞれ役割があります

40
00:02:59,513 --> 00:03:04,651
モデルとビューには
それぞれ役割があります

41
00:03:04,885 --> 00:03:08,222
UIImageはデータをロードし

42
00:03:08,322 --> 00:03:11,959
UIImageViewは
それを表示します

43
00:03:13,493 --> 00:03:18,432
一方通行の単純な
関係のように思えますが

44
00:03:19,166 --> 00:03:22,102
実際は もう少し複雑です

45
00:03:23,103 --> 00:03:27,774
繰り返し行われる
レンダリングに加えて

46
00:03:28,242 --> 00:03:34,581
アプリケーションの速度に
関わるフェーズがあります

47
00:03:35,115 --> 00:03:36,650
デコードです

48
00:03:37,818 --> 00:03:42,122
しかし まず先に
バッファの話をしましょう

49
00:03:43,590 --> 00:03:48,128
バッファはメモリに
隣接する領域ですが

50
00:03:48,228 --> 00:03:52,266
通常はサイズも内部構造も
画一的な―

51
00:03:52,499 --> 00:03:56,770
要素の配列から成る
メモリを指します

52
00:03:57,838 --> 00:04:02,276
今回 重要となる
イメージバッファとは

53
00:03:57,838 --> 00:04:02,276
今回 重要となる
イメージバッファとは

54
00:04:02,376 --> 00:04:07,881
インメモリで画像を
表示するバッファのことです

55
00:04:08,782 --> 00:04:10,450
各要素には

56
00:04:10,551 --> 00:04:16,322
画像のピクセルごとの色と
透明度が記述されています

57
00:04:17,057 --> 00:04:21,728
よってバッファサイズは
含まれる画像の―

58
00:04:21,928 --> 00:04:24,198
サイズに比例します

59
00:04:25,332 --> 00:04:30,537
特に重要となるのが
フレームバッファ

60
00:04:31,305 --> 00:04:36,009
レンダリングの出力内容を
保持する領域です

61
00:04:36,877 --> 00:04:40,981
ビュー階層を更新すると
UIKitが

62
00:04:41,081 --> 00:04:46,153
ウィンドウとサブビューを
レンダリングします

63
00:04:47,154 --> 00:04:50,524
このフレームバッファの
色情報を―

64
00:04:50,624 --> 00:04:55,562
ディスプレイが読み
各ピクセルを彩色します

65
00:04:58,198 --> 00:05:00,968
彩色のフレームレートは

66
00:04:58,198 --> 00:05:00,968
彩色のフレームレートは

67
00:05:01,568 --> 00:05:05,506
60fps つまり
１秒間に60回です

68
00:05:05,806 --> 00:05:12,045
ProMotionディスプレイの
iPadなら120fps

69
00:05:13,814 --> 00:05:16,016
何も動きがなければ

70
00:05:16,116 --> 00:05:20,988
ディスプレイは
同じデータを受け取ります

71
00:05:21,822 --> 00:05:23,323
しかし例えば―

72
00:05:24,124 --> 00:05:29,963
新しいUIImageを
ビューに割り当てると

73
00:05:30,998 --> 00:05:35,369
UIKitがフレームバッファに
再レンダリング

74
00:05:35,802 --> 00:05:40,174
それをディスプレイが読み
表示します

75
00:05:41,842 --> 00:05:43,744
これと対照的なのが

76
00:05:43,844 --> 00:05:49,082
データバッファという
バイト配列を含む領域です

77
00:05:49,883 --> 00:05:54,488
ネットやディスクから
取り込んだ画像を含む―

78
00:05:54,621 --> 00:05:58,292
データバッファについて
お話しします

79
00:05:59,660 --> 00:06:03,864
通常 画像サイズなどの
メタデータが

80
00:05:59,660 --> 00:06:03,864
通常 画像サイズなどの
メタデータが

81
00:06:03,964 --> 00:06:06,800
先頭に格納されています

82
00:06:07,901 --> 00:06:10,070
その次が画像データ

83
00:06:10,170 --> 00:06:14,741
エンコードされた
JPEGやPNGです

84
00:06:16,176 --> 00:06:19,446
つまりメタデータの
次のバイトには

85
00:06:19,613 --> 00:06:23,784
ピクセルの情報は直接
記述されていません

86
00:06:26,954 --> 00:06:30,390
このパイプラインを
詳しく見てみましょう

87
00:06:31,091 --> 00:06:35,662
フレームバッファの
レンダリング領域を

88
00:06:35,963 --> 00:06:38,432
ハイライトして示しました

89
00:06:38,832 --> 00:06:41,168
UIImageをビューへ

90
00:06:42,302 --> 00:06:48,542
画像ファイルを表示するのは
データバッファですが

91
00:06:49,343 --> 00:06:54,615
ピクセルの情報を持つ
フレームバッファも必要です

92
00:06:55,382 --> 00:07:00,053
そこでUIImageは
イメージバッファを

93
00:06:55,382 --> 00:07:00,053
そこでUIImageは
イメージバッファを

94
00:07:00,621 --> 00:07:04,791
画像と同じサイズで
割り当てます

95
00:07:05,492 --> 00:07:13,333
そしてデコードにより
JPEGなどの画像データを

96
00:07:13,433 --> 00:07:16,703
ピクセル単位の色情報に
変換します

97
00:07:17,604 --> 00:07:23,210
UIKitがレンダリングを
要求すると 画像ビューは

98
00:07:23,810 --> 00:07:28,348
イメージバッファから
フレームバッファへ―

99
00:07:28,448 --> 00:07:30,017
コピーします

100
00:07:32,619 --> 00:07:38,225
大きな画像のデコードは
CPUには負担です

101
00:07:38,692 --> 00:07:43,363
でもUIImageを
毎回コピーせずに

102
00:07:43,931 --> 00:07:48,802
イメージバッファに残せば
一度で済みます

103
00:07:49,436 --> 00:07:53,207
これなら
画像をすべてデコードしても

104
00:07:53,307 --> 00:07:56,844
大容量のメモリを
確保できます

105
00:07:57,978 --> 00:08:03,016
この割り当てに比例するのは
画像サイズであり

106
00:07:57,978 --> 00:08:03,016
この割り当てに比例するのは
画像サイズであり

107
00:08:03,116 --> 00:08:07,120
画像ビューのサイズでは
ありません

108
00:08:08,255 --> 00:08:11,458
これが処理速度の低下を
招きます

109
00:08:12,392 --> 00:08:16,597
アプリケーションの
アドレス空間が大きく

110
00:08:16,697 --> 00:08:20,234
関連コンテンツが
分散するのです

111
00:08:20,334 --> 00:08:23,804
これが
フラグメンテーションです

112
00:08:25,873 --> 00:08:30,277
アプリケーションが
メモリを多く使うと

113
00:08:30,377 --> 00:08:35,849
OSが物理的メモリの内容を
圧縮し始めます

114
00:08:36,750 --> 00:08:39,686
アプリケーション内
だけでなく

115
00:08:39,785 --> 00:08:43,222
ここでもCPUが使われます

116
00:08:43,323 --> 00:08:48,028
この負荷の増大を
ユーザは制御できません

117
00:08:48,962 --> 00:08:52,966
メモリの使用量が
多くなりすぎると

118
00:08:53,133 --> 00:08:59,306
優先度の低いプロセスから
OSが終了処理を始めます

119
00:09:00,140 --> 00:09:01,341
最終的には

120
00:09:01,441 --> 00:09:05,879
アプリケーション自体が
終了してしまいます

121
00:09:06,346 --> 00:09:09,716
優先度が低くても
重要なプロセスは

122
00:09:09,816 --> 00:09:12,586
すぐ再起動するでしょう

123
00:09:13,520 --> 00:09:17,925
たとえメモリを使うのは
短時間でも―

124
00:09:18,458 --> 00:09:23,197
CPUの負荷への影響は
長引きかねません

125
00:09:24,031 --> 00:09:27,568
メモリの使用量を
減らす手法に

126
00:09:27,768 --> 00:09:31,538
ダウンサンプリングが
あります

127
00:09:32,773 --> 00:09:36,877
パイプラインを
詳しく見てみましょう

128
00:09:36,977 --> 00:09:40,247
画像を表示する画像ビューは

129
00:09:40,514 --> 00:09:44,418
画像データより
小さなサイズです

130
00:09:44,985 --> 00:09:49,189
Core Animationの
フレームワークは

131
00:09:49,289 --> 00:09:51,692
画像を縮小しますが

132
00:09:52,226 --> 00:09:55,963
ダウンサンプリングで
メモリを節約できます

133
00:09:56,063 --> 00:10:02,636
この手法では縮小の工程で
サムネイルを作ります

134
00:09:56,063 --> 00:10:02,636
この手法では縮小の工程で
サムネイルを作ります

135
00:10:03,270 --> 00:10:06,773
イメージバッファが
小さくなるので

136
00:10:07,541 --> 00:10:11,278
メモリの使用量も減ります

137
00:10:12,613 --> 00:10:16,083
画像ソースで
サムネイルを作り

138
00:10:16,350 --> 00:10:19,953
イメージバッファを
UIImageにして―

139
00:10:20,053 --> 00:10:22,823
画像ビューに割り当てます

140
00:10:23,423 --> 00:10:26,760
データバッファは不要になり

141
00:10:26,994 --> 00:10:31,498
メモリフットプリントも
かなり小さくなります

142
00:10:31,598 --> 00:10:35,636
重要なコードを数行
ご紹介しましょう

143
00:10:35,736 --> 00:10:39,907
CGImageSource
オブジェクトを―

144
00:10:40,374 --> 00:10:42,976
作るところから始めます

145
00:10:44,178 --> 00:10:47,714
CGImageSourceCreateは

146
00:10:47,815 --> 00:10:51,952
shouldCacheフラグを
渡します

147
00:10:52,052 --> 00:10:56,790
Core Graphics
フレームワークに

148
00:10:57,424 --> 00:11:00,661
オブジェクトを生成させます

149
00:10:57,424 --> 00:11:00,661
オブジェクトを生成させます

150
00:11:01,695 --> 00:11:04,431
デコードは まだですよ

151
00:11:04,531 --> 00:11:09,036
URLの情報で
オブジェクトを作るだけです

152
00:11:11,138 --> 00:11:14,842
次に画像の辺の長さを
計算しますが

153
00:11:14,942 --> 00:11:19,079
縮尺比と
ポイントサイズを基にします

154
00:11:19,880 --> 00:11:22,349
大きいほうの寸法です

155
00:11:22,649 --> 00:11:27,454
サムネイルの
ディクショナリも作ります

156
00:11:28,222 --> 00:11:32,893
いくつかのオプションが
書かれていますね

157
00:11:32,993 --> 00:11:37,431
CacheImmediatelyは
特に重要です

158
00:11:38,465 --> 00:11:44,104
これでCore Graphicsは
サムネイルと同時に

159
00:11:44,204 --> 00:11:48,876
デコードした
イメージバッファを作ります

160
00:11:49,576 --> 00:11:53,580
その時のCPU使用量も
制御できます

161
00:11:56,016 --> 00:12:00,621
CGImageの
サムネイルを生成し

162
00:11:56,016 --> 00:12:00,621
CGImageの
サムネイルを生成し

163
00:12:00,721 --> 00:12:04,224
ヘルパー機能で
UIImageにラップ

164
00:12:05,959 --> 00:12:09,463
この成果を
数字で表しましょう

165
00:12:09,763 --> 00:12:14,368
これは3000×2000ピクセルの
写真です

166
00:12:14,601 --> 00:12:19,606
最適化せずStoryboardの
UIImageViewに入れると

167
00:12:20,040 --> 00:12:24,411
静止画の表示だけで
31.5MB必要です

168
00:12:25,846 --> 00:12:27,781
ダウンサンプリングで

169
00:12:27,881 --> 00:12:31,585
イメージバッファを
作るだけで―

170
00:12:32,152 --> 00:12:36,723
メモリの使用量は
18.4MBになります

171
00:12:36,823 --> 00:12:39,526
大幅に節約できました

172
00:12:41,962 --> 00:12:44,264
(拍手)

173
00:12:44,364 --> 00:12:48,769
この技術を使えば
皆さんも称賛されますよ

174
00:12:49,236 --> 00:12:53,474
アプリケーションに
大きな画像が多くても

175
00:12:53,574 --> 00:12:56,343
狭い場所に表示できます

176
00:12:56,844 --> 00:13:00,848
カメラロールを例に
ご説明しましょう

177
00:12:56,844 --> 00:13:00,848
カメラロールを例に
ご説明しましょう

178
00:13:02,649 --> 00:13:08,589
UICollectionViewで
こんな命令を実行しました

179
00:13:09,089 --> 00:13:13,527
先ほど記述した
ヘルパー機能を使って

180
00:13:13,727 --> 00:13:18,131
画面上のセルに合わせ
画像を縮小します

181
00:13:19,700 --> 00:13:22,035
すばらしいでしょう？

182
00:13:22,135 --> 00:13:26,907
メモリの使用量を
大幅に減らせました

183
00:13:27,374 --> 00:13:30,477
しかし まだ問題があります

184
00:13:30,577 --> 00:13:34,481
スクロールビューで
起きる現象です

185
00:13:35,382 --> 00:13:38,652
スムーズに
スクロールできない時が

186
00:13:38,752 --> 00:13:40,721
ありますよね

187
00:13:41,188 --> 00:13:43,457
その原因は こうです

188
00:13:43,924 --> 00:13:48,795
スクロール中 CPUは
ほぼ休止しているか

189
00:13:49,062 --> 00:13:54,802
画像処理より優先すべき
命令を実行しています

190
00:13:55,502 --> 00:13:57,237
更新された画像を―

191
00:13:57,337 --> 00:14:02,576
ディスプレイがすぐ
受け取れば問題ありません

192
00:13:57,337 --> 00:14:02,576
ディスプレイがすぐ
受け取れば問題ありません

193
00:14:03,277 --> 00:14:06,079
今は別の画像を表示します

194
00:14:06,346 --> 00:14:10,017
Core Graphicsでデコードし

195
00:14:10,384 --> 00:14:12,853
セルをUICollectionViewへ

196
00:14:13,453 --> 00:14:19,927
CPUの負荷が増して
画像データを更新できません

197
00:14:20,861 --> 00:14:25,899
しかしディスプレイは
動作するので 画面の動きは

198
00:14:25,999 --> 00:14:27,501
不安定です

199
00:14:29,303 --> 00:14:34,107
デコード後のセルを
UICollectionViewへ

200
00:14:35,008 --> 00:14:39,246
スクロールが再開し
また止まりました

201
00:14:40,848 --> 00:14:45,118
この問題による影響は
他にも及びます

202
00:14:45,886 --> 00:14:49,890
バッテリーの寿命が
少し縮むのです

203
00:14:50,424 --> 00:14:54,862
iOSは電力需要の調整が
得意ですが

204
00:14:55,562 --> 00:14:59,633
CPUを少しずつ
使う場合に限ります

205
00:14:59,733 --> 00:15:01,969
今は急上昇しています

206
00:14:59,733 --> 00:15:01,969
今は急上昇しています

207
00:15:02,069 --> 00:15:05,105
新しい行が
表示されるたび―

208
00:15:05,939 --> 00:15:10,677
CPUの使用量は跳ね上がり
また戻ります

209
00:15:12,246 --> 00:15:17,217
使用量の急上昇を
抑える技術は２つあります

210
00:15:17,518 --> 00:15:19,253
１つ目は“先読み”

211
00:15:19,720 --> 00:15:22,990
詳しくはWWDC18の講演―

212
00:15:23,190 --> 00:15:27,294
“A Tour of
UICollectionView”をどうぞ

213
00:15:27,427 --> 00:15:30,264
先読みでは
コレクションビューが

214
00:15:30,364 --> 00:15:33,300
データソースに対して

215
00:15:33,700 --> 00:15:37,805
“もうすぐセルが
必要になる”と伝えます

216
00:15:37,905 --> 00:15:44,545
作業を早く始められる上
CPUの負荷も分散できるので

217
00:15:45,212 --> 00:15:47,981
最大使用量が減ります

218
00:15:49,616 --> 00:15:53,187
２つ目は
バックグラウンド処理

219
00:15:53,287 --> 00:15:58,025
処理量が分散し
CPUの使用率が減ります

220
00:16:01,595 --> 00:16:05,632
これでアプリケーションの
反応速度が上がり

221
00:16:05,732 --> 00:16:08,135
バッテリーの寿命も延びます

222
00:16:09,503 --> 00:16:15,642
ここではデータソースに
先読みの手法を使いました

223
00:16:16,610 --> 00:16:21,548
またヘルパー機能を呼び出し
画像を縮小して

224
00:16:21,849 --> 00:16:25,786
コレクションビューのセルに
表示します

225
00:16:27,187 --> 00:16:32,326
非同期キューの１つに
ディスパッチするのです

226
00:16:33,694 --> 00:16:36,897
バックグラウンドで
処理できました

227
00:16:37,564 --> 00:16:40,267
しかし欠点があります

228
00:16:40,767 --> 00:16:43,871
“スレッド爆発”です

229
00:16:44,505 --> 00:16:50,477
CPUに能力以上の仕事を
させると起きる現象です

230
00:16:51,411 --> 00:16:55,182
６～８枚の画像を
同時に表示する時

231
00:16:55,616 --> 00:17:00,854
CPUが２個だけでは
一気に処理できません

232
00:16:55,616 --> 00:17:00,854
CPUが２個だけでは
一気に処理できません

233
00:17:00,954 --> 00:17:03,724
CPUが足りないのです

234
00:17:04,992 --> 00:17:09,930
ディスパッチの際
デッドロックを避けるため

235
00:17:10,230 --> 00:17:15,335
GCDが新しいスレッドを
生成し 処理します

236
00:17:16,236 --> 00:17:20,307
CPUはスレッド間を
行き来しながら

237
00:17:20,406 --> 00:17:25,612
OSに命じられている処理を
徐々に進めます

238
00:17:25,712 --> 00:17:29,316
これが
オーバーヘッドの原因です

239
00:17:31,351 --> 00:17:35,722
CPUの画像処理の負荷を
減らせたら

240
00:17:35,989 --> 00:17:38,325
とても助かりますよね

241
00:17:39,126 --> 00:17:43,497
去年の講演で
紹介された技術の出番です

242
00:17:43,730 --> 00:17:46,600
Modernizing Grand
Central Dispatch Usage

243
00:17:46,700 --> 00:17:50,938
タスクを同期…　失礼
順番に並べましょう

244
00:17:52,940 --> 00:17:57,211
非同期キューを
単にディスパッチせず

245
00:17:58,212 --> 00:18:00,247
シリアルキューを作成

246
00:17:58,212 --> 00:18:00,247
シリアルキューを作成

247
00:18:01,181 --> 00:18:03,917
先読みをしつつ
非同期で―

248
00:18:05,285 --> 00:18:07,554
ディスパッチします

249
00:18:07,888 --> 00:18:12,826
個々の画像の立ち上がりは
遅くなりますが

250
00:18:13,560 --> 00:18:19,132
CPUのタスクの切り替えは
以前より早まります

251
00:18:21,568 --> 00:18:24,771
画像の保存先は様々です

252
00:18:25,139 --> 00:18:30,477
アプリケーション内なら
イメージアセットでしょう

253
00:18:30,577 --> 00:18:35,415
ファイルの中や
ネットワーク上でしょうか

254
00:18:36,016 --> 00:18:42,756
ドキュメントディレクトリや
キャッシュかもしれませんね

255
00:18:43,690 --> 00:18:46,193
アートワークの場合は

256
00:18:46,493 --> 00:18:50,264
イメージアセットを
強く勧めます

257
00:18:51,198 --> 00:18:52,966
理由があります

258
00:18:54,501 --> 00:18:58,472
画像に名称や特性を持たせて
管理するため―

259
00:18:58,572 --> 00:19:04,845
ディスクのファイル検索より
速く画像を探せるのです

260
00:18:58,572 --> 00:19:04,845
ディスクのファイル検索より
速く画像を探せるのです

261
00:19:06,880 --> 00:19:12,519
アセットカタログは随時
バッファサイズを調整します

262
00:19:13,854 --> 00:19:18,926
イメージアセットだけの
特色もあります

263
00:19:19,026 --> 00:19:24,531
例えばデバイスに関連する
画像リソースだけを

264
00:19:24,631 --> 00:19:27,100
ダウンロードできます

265
00:19:27,201 --> 00:19:28,802
ベクタ画像も扱えます

266
00:19:30,904 --> 00:19:36,477
イメージアセットの設定で
チェックを入れれば

267
00:19:36,577 --> 00:19:39,379
ベクタ画像を使えます

268
00:19:40,147 --> 00:19:44,218
これが画像ビューに
レンダリングされると

269
00:19:44,384 --> 00:19:48,455
サイズが変わっても
画質は鮮明です

270
00:19:49,389 --> 00:19:54,728
ラスタ化してあるため
ジャギーが出ません

271
00:19:55,796 --> 00:20:03,237
OSのアクセシビリティ設定で
フォントサイズを大きくして

272
00:19:55,796 --> 00:20:03,237
OSのアクセシビリティ設定で
フォントサイズを大きくして

273
00:20:03,537 --> 00:20:08,408
タブバーのアイテムを押すと
HUDが現れ

274
00:20:08,509 --> 00:20:13,146
指で押さえている画像が
拡大されます

275
00:20:14,047 --> 00:20:18,252
こういう時に画像の見栄えを
よくするには

276
00:20:18,719 --> 00:20:23,757
Preserve Vector
Dataを―

277
00:20:23,857 --> 00:20:25,959
設定してください

278
00:20:26,760 --> 00:20:30,364
先ほどのパイプラインに
似ています

279
00:20:30,631 --> 00:20:37,104
ラスタ化ではベクタ画像を
ビットマップ画像に変換し

280
00:20:37,204 --> 00:20:40,941
フレームバッファに
コピーします

281
00:20:45,078 --> 00:20:50,751
このベクタ画像の処理に
CPUをかなり使うため

282
00:20:50,851 --> 00:20:52,619
最適化しましょう

283
00:20:53,120 --> 00:20:57,024
設定済みのベクタ画像を
通常サイズで

284
00:20:57,291 --> 00:20:59,927
レンダリングしました

285
00:21:01,195 --> 00:21:05,032
アセットカタログの
コンパイラは

286
00:21:05,132 --> 00:21:09,036
変換前の画像を
すでに保存しています

287
00:21:09,336 --> 00:21:14,842
だったら それをデコードし
カタログに保存すれば

288
00:21:15,209 --> 00:21:22,516
フレームバッファに直接
レンダリングできるわけです

289
00:21:24,952 --> 00:21:29,490
例えば
大小２種類のアイコンを

290
00:21:29,590 --> 00:21:33,393
レンダリングすると
しましょう

291
00:21:33,794 --> 00:21:37,331
その場合はベクタ画像の
設定に頼らず

292
00:21:37,698 --> 00:21:43,237
レンダリングに適した
イメージアセットを作ります

293
00:21:45,005 --> 00:21:47,040
これならCPUは―

294
00:21:47,741 --> 00:21:52,412
フレームバッファに
毎回 描画する必要はなく

295
00:21:52,679 --> 00:21:55,883
ラスタ化だけで済みます

296
00:21:58,218 --> 00:22:01,722
UIImageと
UIImageViewでした

297
00:21:58,218 --> 00:22:01,722
UIImageと
UIImageViewでした

298
00:22:02,823 --> 00:22:09,329
アプリケーションの実行中に
描画するケースもありますね

299
00:22:12,332 --> 00:22:13,967
例を挙げます

300
00:22:14,268 --> 00:22:19,506
Photosで編集する場合を
考えましょう

301
00:22:21,208 --> 00:22:27,614
UIButtonはアイコンを
表示するオブジェクトですが

302
00:22:28,482 --> 00:22:35,289
Live Photoのボタンは
サポートしていません

303
00:22:36,190 --> 00:22:38,458
自作してみましょう

304
00:22:39,326 --> 00:22:45,065
このようにUIViewの
サブクラスを作ります

305
00:22:45,399 --> 00:22:51,405
角が丸い黄色の長方形と
文字と画像を入れました

306
00:22:53,707 --> 00:22:55,309
この方法は―

307
00:22:56,243 --> 00:22:57,444
ダメですね

308
00:22:58,045 --> 00:23:03,750
ビューのサブクラスと
UIImageViewを比べます

309
00:22:58,045 --> 00:23:03,750
ビューのサブクラスと
UIImageViewを比べます

310
00:23:04,318 --> 00:23:07,287
UIViewを支えるのは

311
00:23:07,387 --> 00:23:11,058
Core Animationの
CALayerです

312
00:23:11,725 --> 00:23:13,227
画像ビューは―

313
00:23:13,327 --> 00:23:18,165
デコードした
イメージバッファを要求し

314
00:23:19,066 --> 00:23:24,705
それをCALayerに渡し
レイヤとして使います

315
00:23:26,173 --> 00:23:28,442
しかし サブクラスは―

316
00:23:29,776 --> 00:23:31,578
少し違います

317
00:23:31,678 --> 00:23:36,817
レイヤがdrawメソッドの
イメージバッファを作り

318
00:23:37,317 --> 00:23:43,524
サブクラスがdraw機能で
コンテンツを上書きします

319
00:23:43,624 --> 00:23:48,295
その後 フレームバッファに
コピーするのです

320
00:23:55,068 --> 00:24:00,574
この処理は負担が大きいので
別の方法がよいでしょう

321
00:23:55,068 --> 00:24:00,574
この処理は負担が大きいので
別の方法がよいでしょう

322
00:24:01,608 --> 00:24:03,811
バッキングストアも

323
00:24:03,944 --> 00:24:06,780
CALayerの
イメージバッファも

324
00:24:06,880 --> 00:24:10,150
サイズは
表示するビュー次第です

325
00:24:11,151 --> 00:24:14,621
iOS 12で最適化されたのは

326
00:24:14,988 --> 00:24:19,226
バッキングストアの
要素のサイズです

327
00:24:19,493 --> 00:24:24,198
標準色域にない色を
使うかどうかによって

328
00:24:24,298 --> 00:24:28,502
サイズが
ダイナミックに変わります

329
00:24:29,036 --> 00:24:33,674
拡張したsRGBの色を使って
描画すると

330
00:24:33,907 --> 00:24:36,210
バッキングストアは―

331
00:24:37,044 --> 00:24:42,249
０と１で表す色だけの時より
大きくなります

332
00:24:43,951 --> 00:24:49,523
iOS 11ではCALayerの
コンテンツ形式プロパティで

333
00:24:49,623 --> 00:24:52,960
Core Animationに対し

334
00:24:53,060 --> 00:24:58,565
ビューで広色域のサポートが
必要かどうかを伝えました

335
00:24:58,966 --> 00:25:03,270
しかし これは
iOS 12で導入した最適化を

336
00:24:58,966 --> 00:25:03,270
しかし これは
iOS 12で導入した最適化を

337
00:25:03,370 --> 00:25:05,272
無効にします

338
00:25:05,372 --> 00:25:08,709
layerWillDrawを
チェックして

339
00:25:08,809 --> 00:25:14,581
iOS 12の最適化を
無効にしないよう ご注意を

340
00:25:17,684 --> 00:25:21,388
バッキングストアに
情報を伝えるより

341
00:25:21,488 --> 00:25:23,757
いい方法があります

342
00:25:23,857 --> 00:25:27,895
バッキングストアの
量も減ります

343
00:25:27,995 --> 00:25:32,466
サブビューに
リファクタリングして

344
00:25:33,000 --> 00:25:36,837
draw機能の上書きを
削除します

345
00:25:38,238 --> 00:25:42,042
メモリのコピー画像が
不要になり

346
00:25:42,843 --> 00:25:47,848
UIViewの最適化プロパティを
使えます

347
00:25:50,851 --> 00:25:56,457
drawメソッドの上書きには
バッキングストアが必須です

348
00:25:57,391 --> 00:26:01,662
上書きしなくても
プロパティは機能します

349
00:25:57,391 --> 00:26:01,662
上書きしなくても
プロパティは機能します

350
00:26:01,762 --> 00:26:04,665
バッキングストアが
不要な例は

351
00:26:04,765 --> 00:26:09,303
UIViewの背景が
パターン色でない場合です

352
00:26:09,403 --> 00:26:13,507
パターン色の背景は
避けましょう

353
00:26:15,209 --> 00:26:20,147
UIImageViewを作り
画像をビューに割り当て―

354
00:26:20,247 --> 00:26:24,852
タイリングを設定するための
機能を使います

355
00:26:27,921 --> 00:26:31,525
長方形の角を切る時は
CALayerの―

356
00:26:32,226 --> 00:26:35,495
cornerRadiusを
指定します

357
00:26:35,829 --> 00:26:38,599
Core Animationなら

358
00:26:38,966 --> 00:26:42,736
メモリを割り当てなくても
可能です

359
00:26:43,437 --> 00:26:47,674
maskViewなどを
使う場合は

360
00:26:48,375 --> 00:26:51,812
マスクを保存する領域が
必要です

361
00:26:53,714 --> 00:26:57,785
一部が透明など
複雑な背景の場合は

362
00:26:58,118 --> 00:27:03,123
UIImageViewを
使ってみてください

363
00:26:58,118 --> 00:27:03,123
UIImageViewを
使ってみてください

364
00:27:03,824 --> 00:27:06,126
アセットカタログに
保存するか

365
00:27:06,226 --> 00:27:08,195
レンダリングして

366
00:27:08,295 --> 00:27:12,666
画像ビューに
データを提供します

367
00:27:15,135 --> 00:27:18,705
最後は
アイコンを作りましょう

368
00:27:19,773 --> 00:27:24,344
UIImageViewは
メモリを追加しなくても

369
00:27:24,444 --> 00:27:27,214
画像を彩色できます

370
00:27:28,182 --> 00:27:31,552
イメージアセットエディタで

371
00:27:31,652 --> 00:27:37,157
レンダリングモードを
テンプレートに設定します

372
00:27:37,758 --> 00:27:41,128
または
withRenderingMode機能で

373
00:27:41,228 --> 00:27:43,931
UIImageを作ります

374
00:27:44,932 --> 00:27:51,338
画像を画像ビューに割り当て
tintColorで彩色しましょう

375
00:27:52,139 --> 00:27:58,345
画像をフレームバッファに
レンダリングするUIImageは

376
00:27:58,445 --> 00:28:00,447
単色を設定します

377
00:27:58,445 --> 00:28:00,447
単色を設定します

378
00:28:00,581 --> 00:28:05,586
単色のコピー画像を
別々には持ちません

379
00:28:07,988 --> 00:28:11,058
一方 UILabelは

380
00:28:11,358 --> 00:28:15,262
カラーの文字や
絵文字ではなく

381
00:28:15,863 --> 00:28:20,801
黒い文字の表示なら
メモリを75％節約します

382
00:28:21,835 --> 00:28:25,539
この最適化の詳細は
WWDC18の―

383
00:28:25,839 --> 00:28:31,145
“iOS Memory Deep Dive”を
どうぞ

384
00:28:31,345 --> 00:28:34,982
A8のバッキングストアの
解説です

385
00:28:38,252 --> 00:28:39,887
UIKitで―

386
00:28:41,388 --> 00:28:45,959
オフスクリーンバッファの
画像をレンダリングする時は

387
00:28:46,093 --> 00:28:50,264
UIGraphicsImageRendererを
使います

388
00:28:50,898 --> 00:28:56,970
UIGraphicsBeginImage
Contextは使いません

389
00:28:57,070 --> 00:29:02,443
前者だけが広色域を
正しくレンダリングできます

390
00:28:57,070 --> 00:29:02,443
前者だけが広色域を
正しくレンダリングできます

391
00:29:03,977 --> 00:29:09,049
前者でオフスクリーン
バッファにレンダリングして

392
00:29:09,283 --> 00:29:13,220
UIImageViewで
画面に表示します

393
00:29:15,055 --> 00:29:20,427
先ほどのバッキングストアの
最適化と同様に

394
00:29:20,694 --> 00:29:26,033
UIGraphicsImageRendererも
ダイナミックに―

395
00:29:26,133 --> 00:29:31,238
イメージバッファの
サイズを拡大します

396
00:29:33,974 --> 00:29:37,911
iOS 12より前のOSで
実行するなら

397
00:29:38,178 --> 00:29:43,150
prefersExtendedRangeで

398
00:29:43,517 --> 00:29:47,287
広色域かをUIKitに伝えます

399
00:29:50,490 --> 00:29:53,060
しかし 迷うところです

400
00:29:53,393 --> 00:29:57,564
最初 レンダラに
画像を生成すると

401
00:29:58,198 --> 00:30:00,534
その画像が使う色は

402
00:29:58,198 --> 00:30:00,534
その画像が使う色は

403
00:30:00,634 --> 00:30:05,139
sRGBの範囲を
超えるかもしれません

404
00:30:06,073 --> 00:30:10,777
しかし その情報を持つのは
小さな要素です

405
00:30:10,878 --> 00:30:12,813
UIImageには

406
00:30:13,113 --> 00:30:16,183
再レンダリングの
ストレージがある―

407
00:30:16,283 --> 00:30:22,723
オブジェクトを得るための
レンダラのプロパティがあります

408
00:30:26,960 --> 00:30:31,298
iOSが提供する
CPUとGPUの技術の―

409
00:30:31,398 --> 00:30:35,602
アプリケーションへの
統合法をお話しします

410
00:30:37,571 --> 00:30:42,876
高度な画像処理を瞬時に
行う場合 お勧めなのが

411
00:30:43,343 --> 00:30:45,112
Core Imageです

412
00:30:46,046 --> 00:30:51,318
Core Imageは
画像加工のフレームワークで

413
00:30:51,685 --> 00:30:54,922
CPUとGPUを使い分けます

414
00:30:55,756 --> 00:31:00,494
CIImageからUIImageを作り

415
00:30:55,756 --> 00:31:00,494
CIImageからUIImageを作り

416
00:31:00,727 --> 00:31:05,666
それをUIImageViewが
GPUで加工します

417
00:31:06,767 --> 00:31:11,038
その間 CPUは
他のタスクを処理できます

418
00:31:12,105 --> 00:31:17,978
CIImageを作った後
イニシャライザを使います

419
00:31:19,813 --> 00:31:25,185
iOSで画像処理できる
高度なフレームワークは

420
00:31:25,319 --> 00:31:26,720
他にも あります

421
00:31:26,820 --> 00:31:30,190
Metal　Vision
Accelerateです

422
00:31:31,158 --> 00:31:35,596
データ型は
CVPixelBuffer

423
00:31:36,563 --> 00:31:39,333
バッファの働きをする―

424
00:31:39,433 --> 00:31:43,804
CPUやGPUで使用可能な
データ型です

425
00:31:44,571 --> 00:31:48,509
このピクセルバッファを
構成する時は

426
00:31:48,609 --> 00:31:51,979
最良のイニシャライザを
使います

427
00:31:52,746 --> 00:31:56,383
エンコードは
しないでください

428
00:31:56,750 --> 00:32:00,687
UIImageなどが
デコード済みです

429
00:31:56,750 --> 00:32:00,687
UIImageなどが
デコード済みです

430
00:32:01,655 --> 00:32:04,758
CPUとGPUのデータ移行は

431
00:32:04,858 --> 00:32:10,197
作業を交換しないよう注意し
並行処理します

432
00:32:11,498 --> 00:32:14,568
Accelerateとsimdの

433
00:32:14,668 --> 00:32:17,805
バッファの
正しいフォーマットを―

434
00:32:17,905 --> 00:32:20,274
最後に解説します

435
00:32:22,843 --> 00:32:25,212
要点だけにしますね

436
00:32:25,913 --> 00:32:31,585
ビューを先読みすると
速く滑らかに処理できます

437
00:32:33,053 --> 00:32:35,956
最適化を
無効にしないでください

438
00:32:36,256 --> 00:32:41,762
バッキングストアを
UIKitが小さくしています

439
00:32:43,864 --> 00:32:48,535
画像はアセットカタログに
まとめましょう

440
00:32:49,103 --> 00:32:52,105
ファイルには
保存しないでください

441
00:32:53,807 --> 00:32:56,844
大小のアイコンを作る時は

442
00:32:57,544 --> 00:33:00,881
画像の設定を
過信しないように

443
00:32:57,544 --> 00:33:00,881
画像の設定を
過信しないように

444
00:33:03,183 --> 00:33:07,788
更に詳しく
お知りになりたい場合は

445
00:33:08,021 --> 00:33:12,359
パフォーマンス向上の講演が
お勧めです

446
00:33:12,693 --> 00:33:14,461
ご質問があれば―

447
00:33:14,561 --> 00:33:18,799
明日と金曜日のラボに
お越しください

448
00:33:19,833 --> 00:33:21,034
ありがとう

449
00:33:21,135 --> 00:33:24,972
(拍手)