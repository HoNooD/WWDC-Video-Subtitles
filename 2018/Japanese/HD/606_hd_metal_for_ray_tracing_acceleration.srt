
1
00:00:07,140 --> 00:00:16,250
(音楽)

2
00:00:17,351 --> 00:00:22,589
(拍手)

3
00:00:23,524 --> 00:00:24,658
こんにちは

4
00:00:25,025 --> 00:00:28,395
GPUソフトウェアエンジニアの
ショーンです

5
00:00:28,595 --> 00:00:31,265
レイトレーシングについて
お話しします

6
00:00:31,365 --> 00:00:36,069
“State of the Union”で
デモを見た人がいるでしょう

7
00:00:36,670 --> 00:00:39,840
自分のアプリケーションで
使いたい人も

8
00:00:39,940 --> 00:00:43,977
今から話すのは
アプリケーションでの使い方と

9
00:00:44,077 --> 00:00:47,514
Metalを用いたGPUでの高速化です

10
00:00:48,482 --> 00:00:51,618
Metal Performance Shaderを
使います

11
00:00:52,452 --> 00:00:59,927
このMPSはiOSとmacOSに最適化した
GPU計算プリミティブの集合体です

12
00:01:00,894 --> 00:01:06,066
画像処理と線形代数
機械学習をサポートします

13
00:01:06,767 --> 00:01:10,671
これまでのセッションで
ご説明しました

14
00:01:11,271 --> 00:01:14,675
今年はトレーニングへの
サポートも追加

15
00:01:14,875 --> 00:01:17,711
明日のセッションでお話しします

16
00:01:18,245 --> 00:01:23,116
本日はレイトレーシングに関する
新機能をご説明します

17
00:01:23,684 --> 00:01:26,153
まずレイトレーシングとは？

18
00:01:27,754 --> 00:01:30,824
レイトレーシングの
アプリケーションでは―

19
00:01:30,924 --> 00:01:33,861
レイの軌跡をたどります

20
00:01:34,494 --> 00:01:38,165
レイとは 光線や音線
その他のエネルギーです

21
00:01:38,398 --> 00:01:40,267
レンダリングや―

22
00:01:40,367 --> 00:01:44,037
音響･物理シミュレーションに
用いる方法です

23
00:01:44,771 --> 00:01:47,741
また レイは
ある点が見えるかなど―

24
00:01:47,841 --> 00:01:50,377
抽象的な概念も表せるのです

25
00:01:51,245 --> 00:01:56,984
従って 衝突判定や人工知能
経路探索にも使われます

26
00:01:57,885 --> 00:02:03,457
本日は１つの例として
レンダリングに焦点を当てます

27
00:01:57,885 --> 00:02:03,457
本日は１つの例として
レンダリングに焦点を当てます

28
00:02:05,058 --> 00:02:07,928
ラスタ化パイプラインは
ご存じですね

29
00:02:08,228 --> 00:02:11,665
ラスタ化では
三角形を１つずつ投影させ

30
00:02:11,765 --> 00:02:15,335
対応するピクセルを
シェーディングします

31
00:02:15,636 --> 00:02:18,672
GPUハードウェアで
素早く処理できるので―

32
00:02:18,772 --> 00:02:22,843
ゲームなどリアルタイムの表示に
選択されてきました

33
00:02:24,211 --> 00:02:29,416
しかしラスタ化では
表現しにくい現象があります

34
00:02:30,717 --> 00:02:32,753
例えば光の反射です

35
00:02:32,986 --> 00:02:35,789
ラスタ化では反射の実装に―

36
00:02:35,889 --> 00:02:39,693
キューブマップなどの
近似値を使います

37
00:02:40,527 --> 00:02:44,464
一方 レイトレーシングでは
反射を正確に計算できます

38
00:02:45,833 --> 00:02:47,768
２つ目の例は影です

39
00:02:48,068 --> 00:02:52,239
ラスタ化では
シャドウマップで影を表現

40
00:02:52,439 --> 00:02:57,144
しかし エイリアス化や
解像度の問題があり

41
00:02:57,678 --> 00:03:02,783
均一なソフトシャドウに
なりがちです

42
00:02:57,678 --> 00:03:02,783
均一なソフトシャドウに
なりがちです

43
00:03:03,584 --> 00:03:08,622
レイトレーシングでは
個々の点を計算します

44
00:03:08,722 --> 00:03:10,591
クリーンなシャドウで

45
00:03:10,691 --> 00:03:16,430
ハードからソフトシャドウに
リアルに遷移します

46
00:03:18,432 --> 00:03:21,034
最後の例は
グローバルイルミネーションです

47
00:03:22,102 --> 00:03:25,239
物体表面の照り返しを表現します

48
00:03:25,606 --> 00:03:29,543
ラスタ化で生成するのは
困難ですが―

49
00:03:29,643 --> 00:03:32,713
レイトレーシングでは
自然です

50
00:03:32,880 --> 00:03:37,818
ゲームやリアルタイムの
アプリケーションでは この技術で

51
00:03:37,918 --> 00:03:42,422
事前に計算し
テクスチャに保存しています

52
00:03:42,523 --> 00:03:45,492
そして実行時に表示するのです

53
00:03:47,294 --> 00:03:50,664
他にも多くの効果を
シミュレートできます

54
00:03:50,764 --> 00:03:55,035
アンビエントオクルージョン
屈折や面光源―

55
00:03:55,135 --> 00:03:58,405
被写界深度や
モーションブラーなどです

56
00:03:59,506 --> 00:04:04,745
従って写実的なオフラインの
描画に用いられます

57
00:03:59,506 --> 00:04:04,745
従って写実的なオフラインの
描画に用いられます

58
00:04:05,779 --> 00:04:10,817
しかしレイトレーシングは
作業量が膨大なため

59
00:04:10,918 --> 00:04:14,154
ラスタ化より
計算コストが高いのです

60
00:04:14,988 --> 00:04:18,392
まずレイトレーシングの
レンダリングに触れ―

61
00:04:18,492 --> 00:04:21,295
Metalでの高速化を説明します

62
00:04:23,463 --> 00:04:25,365
パストレーシング法を使います

63
00:04:26,400 --> 00:04:29,403
現実では光源から光子が放たれ

64
00:04:29,503 --> 00:04:33,173
跳ね返りながら
カメラや目に届きます

65
00:04:33,841 --> 00:04:37,211
ただ カメラに届くのは
光子の一部なので―

66
00:04:37,311 --> 00:04:39,880
すべてを追うのはムダです

67
00:04:40,414 --> 00:04:46,353
そこでカメラの位置から
逆方向に光をトレースします

68
00:04:47,120 --> 00:04:52,125
まずカメラから空間に向けて
プライマリレイを飛ばし

69
00:04:53,393 --> 00:04:56,363
物体との交点で
シェーディングします

70
00:04:56,763 --> 00:05:01,101
計算するのは
交点に届いた光量と―

71
00:04:56,763 --> 00:05:01,101
計算するのは
交点に届いた光量と―

72
00:05:01,201 --> 00:05:05,005
反射して
カメラに戻る光の割合です

73
00:05:05,472 --> 00:05:09,042
ここで２種類の光が登場します

74
00:05:10,711 --> 00:05:12,913
その１つが直接光で―

75
00:05:13,146 --> 00:05:17,150
光源から交点に
直接 届いた光です

76
00:05:18,118 --> 00:05:22,623
交点に達した光量と
反射して戻る光の割合は

77
00:05:22,723 --> 00:05:24,791
簡単に計算できます

78
00:05:25,058 --> 00:05:27,327
ライティングの前に―

79
00:05:27,427 --> 00:05:31,198
影の領域でないことを
確認しましょう

80
00:05:32,499 --> 00:05:37,905
そのために交点から光源に
シャドウレイを飛ばします

81
00:05:38,939 --> 00:05:41,775
レイが光源に到達しなければ

82
00:05:41,875 --> 00:05:46,446
その点は影ということを
意味します

83
00:05:48,782 --> 00:05:51,552
もう１つの光は間接光で―

84
00:05:52,019 --> 00:05:57,191
他の物体の表面で跳ね返り
交点に達した光です

85
00:05:57,858 --> 00:06:03,530
ここでは交点からランダムに
セカンダリレイを飛ばし

86
00:05:57,858 --> 00:06:03,530
ここでは交点からランダムに
セカンダリレイを飛ばし

87
00:06:04,565 --> 00:06:08,435
２番目の交点で
シェーディングします

88
00:06:09,837 --> 00:06:11,138
計算するのは―

89
00:06:11,238 --> 00:06:14,842
２番目の交点に
直接 達した光量と―

90
00:06:14,942 --> 00:06:19,546
反射して１番目の交点を経て―

91
00:06:19,646 --> 00:06:22,082
カメラに戻る光の割合です

92
00:06:22,850 --> 00:06:27,120
さらに２番目の交点から
シャドウレイを照射

93
00:06:28,856 --> 00:06:34,161
この工程を繰り返し
反射をシミュレートします

94
00:06:36,830 --> 00:06:40,868
ソフトシャドウと
反射光の効果を得るために―

95
00:06:41,001 --> 00:06:45,639
無数のシャドウレイと
セカンダリレイを飛ばします

96
00:06:46,406 --> 00:06:51,245
反射が増えると
レイの本数は急増するのです

97
00:06:51,845 --> 00:06:53,981
この増加を避けるため―

98
00:06:54,281 --> 00:06:59,119
それぞれのレイを反射ごとに
１本ずつにします

99
00:06:59,987 --> 00:07:02,289
ノイズが生じますが―

100
00:06:59,987 --> 00:07:02,289
ノイズが生じますが―

101
00:07:02,523 --> 00:07:05,859
複数フレームの平均値が出せます

102
00:07:06,193 --> 00:07:09,029
各フレームでは
プライマリレイを生成

103
00:07:09,129 --> 00:07:14,535
被写界深度や
モーションブラーも表現できます

104
00:07:16,470 --> 00:07:18,639
図で示しましょう

105
00:07:19,873 --> 00:07:22,142
まずプライマリレイを飛ばし

106
00:07:22,809 --> 00:07:25,112
物体との交点を求めます

107
00:07:26,213 --> 00:07:28,815
そしてシェーディングを計算

108
00:07:28,916 --> 00:07:31,118
工程を繰り返し―

109
00:07:31,218 --> 00:07:36,290
シャドウレイとセカンダリレイで
物体との交差を調べます

110
00:07:36,757 --> 00:07:39,893
最後に
計算した色を付けます

111
00:07:40,894 --> 00:07:43,397
以上がレンダリングですが

112
00:07:43,497 --> 00:07:48,435
レイと三角形の交差判定に
かなり時間がかかります

113
00:07:49,336 --> 00:07:54,541
つまり交差させるインターセクタは
レンダリング全体に―

114
00:07:54,641 --> 00:07:57,644
大きく影響するのです

115
00:07:58,412 --> 00:08:03,283
レイトレーシングの
アプリケーションでも同様です

116
00:07:58,412 --> 00:08:03,283
レイトレーシングの
アプリケーションでも同様です

117
00:08:04,785 --> 00:08:07,921
この問題を解決するために

118
00:08:08,021 --> 00:08:13,493
高性能なインターセクタを
提供することにしました

119
00:08:14,661 --> 00:08:18,632
今年 導入する
MPSRayIntersectorのAPIです

120
00:08:19,566 --> 00:08:22,936
macOSとiOSデバイスのGPU上で―

121
00:08:23,036 --> 00:08:27,207
交差判定を高速化します

122
00:08:28,442 --> 00:08:33,881
レイは まとめて
Metalバッファに格納します

123
00:08:34,548 --> 00:08:37,751
最も近い交点をMPSが見つけ―

124
00:08:37,851 --> 00:08:40,254
別のバッファに格納します

125
00:08:40,654 --> 00:08:43,957
あとは
交差判定をしたい箇所で―

126
00:08:44,057 --> 00:08:47,761
Metalコマンドバッファを
提供するだけ

127
00:08:47,861 --> 00:08:51,465
そこに交差情報をエンコードします

128
00:08:52,699 --> 00:08:55,669
詳しくご説明しましょう

129
00:08:59,640 --> 00:09:00,507
出ましたね

130
00:08:59,640 --> 00:09:00,507
出ましたね

131
00:09:01,475 --> 00:09:05,479
3Dモデルは通常
三角形で表します

132
00:09:06,013 --> 00:09:09,016
これらの三角形とレイの交点を―

133
00:09:09,116 --> 00:09:11,919
調べる必要があります

134
00:09:12,853 --> 00:09:17,858
また レイの始点に
最も近い交点を求めます

135
00:09:19,026 --> 00:09:20,794
一番 単純な方法は―

136
00:09:20,894 --> 00:09:24,932
すべての三角形で
交点を求めることです

137
00:09:25,232 --> 00:09:28,936
しかし時間がかかりすぎます

138
00:09:29,803 --> 00:09:34,007
そこで“加速構造”という
データ構造を作成

139
00:09:34,608 --> 00:09:37,845
再帰的にシーンを分割することで

140
00:09:37,945 --> 00:09:41,215
空間内で近い三角形を
グループ化

141
00:09:42,382 --> 00:09:47,955
ツリー内の境界ボックスと
レイを交差させます

142
00:09:48,255 --> 00:09:52,159
交差しないサブツリーは
スキップして

143
00:09:52,993 --> 00:09:57,931
交点を求める三角形を
最終的に残すのです

144
00:09:59,032 --> 00:10:02,236
以上が交差判定の高速化です

145
00:09:59,032 --> 00:10:02,236
以上が交差判定の高速化です

146
00:10:03,203 --> 00:10:05,539
これは単純化した例なので―

147
00:10:06,073 --> 00:10:10,177
実際の加速構造は
もう少し複雑です

148
00:10:11,278 --> 00:10:13,146
この画像では―

149
00:10:13,247 --> 00:10:17,284
複雑なジオメトリに
加速構造を使っています

150
00:10:17,751 --> 00:10:21,154
つまり
大半の時間を費やすのは―

151
00:10:21,255 --> 00:10:25,392
ジオメトリの
複雑な範囲だけなのです

152
00:10:26,460 --> 00:10:32,232
加速構造の理解のため
このことに触れています

153
00:10:32,432 --> 00:10:34,902
でも心配は無用です

154
00:10:35,002 --> 00:10:37,404
MPSがすべてサポートします

155
00:10:38,939 --> 00:10:41,308
三角形のモデルは―

156
00:10:41,708 --> 00:10:45,946
頂点として
頂点バッファに格納されます

157
00:10:46,713 --> 00:10:52,352
MPSを呼び 頂点バッファから
加速構造を作ってください

158
00:10:53,287 --> 00:10:58,559
交差判定の際 加速構造を
インターセクタに提供します

159
00:10:59,560 --> 00:11:02,396
アプリケーションで
使ってみましょう

160
00:10:59,560 --> 00:11:02,396
アプリケーションで
使ってみましょう

161
00:11:03,363 --> 00:11:05,632
３段階に分けます

162
00:11:05,732 --> 00:11:08,068
まずプライマリレイを生成し

163
00:11:08,168 --> 00:11:11,538
交点を求めて
シェーディングを計算

164
00:11:11,905 --> 00:11:17,077
ラスタ化と同じですが
次の段階があります

165
00:11:18,145 --> 00:11:19,880
次に影を生成

166
00:11:19,980 --> 00:11:24,852
MPSがシャドウレイを支援し
速度が上がります

167
00:11:26,086 --> 00:11:30,791
最後にセカンダリレイで
光の跳ね返りをシミュレート

168
00:11:31,291 --> 00:11:33,627
ラスタ化では困難ですが―

169
00:11:33,727 --> 00:11:37,064
レイトレーシングでは
簡単な拡張機能です

170
00:11:38,599 --> 00:11:40,334
まず プライマリレイですが―

171
00:11:41,568 --> 00:11:43,637
次の５つの処理をします

172
00:11:44,271 --> 00:11:47,107
インターセクタを生成

173
00:11:48,442 --> 00:11:51,612
頂点バッファから加速構造を作成

174
00:11:53,380 --> 00:11:57,151
プライマリレイを生成し
レイバッファに格納

175
00:11:58,652 --> 00:12:03,357
インターセクタで
レイと物体の交差を判定

176
00:11:58,652 --> 00:12:03,357
インターセクタで
レイと物体の交差を判定

177
00:12:03,924 --> 00:12:07,928
最後に その結果から
シェーディングを計算

178
00:12:09,096 --> 00:12:10,998
では まず
インターセクタです

179
00:12:12,499 --> 00:12:17,671
MPSRayIntersectorクラスで
交差判定を支援

180
00:12:18,238 --> 00:12:23,377
交差判定に使うMetalデバイスを
提供するだけで作成できます

181
00:12:25,279 --> 00:12:27,481
次は加速構造の作成です

182
00:12:28,882 --> 00:12:32,820
MPSTriangleAccelerationStructure
クラスで―

183
00:12:32,986 --> 00:12:38,358
インターセクタの時と同じ
Metalデバイスを提供するだけです

184
00:12:39,960 --> 00:12:43,630
vertexBufferをアタッチし
triangleCountを指定

185
00:12:44,198 --> 00:12:47,367
そして加速構造を構築します

186
00:12:47,467 --> 00:12:53,006
１回 作成しておけば
何度でも再利用できます

187
00:12:56,543 --> 00:13:00,280
次はプライマリレイの生成と
バッファ格納です

188
00:12:56,543 --> 00:13:00,280
次はプライマリレイの生成と
バッファ格納です

189
00:13:01,048 --> 00:13:05,886
ピクセルごとに１スレッドで
2D計算カーネルを起動

190
00:13:06,420 --> 00:13:10,057
各スレッドに
このレイ構造体を記述します

191
00:13:11,358 --> 00:13:15,929
カメラの前に
平面が浮き出るイメージです

192
00:13:17,297 --> 00:13:22,135
プライマリレイの始点は
カメラの位置にします

193
00:13:22,636 --> 00:13:24,404
方向については―

194
00:13:24,505 --> 00:13:29,676
カメラ前の画面上の
ピクセルを通して計算します

195
00:13:32,479 --> 00:13:36,783
次はインターセクタで
交差を判定

196
00:13:38,185 --> 00:13:42,656
encodeIntersectionで
すべてを結び付けます

197
00:13:43,357 --> 00:13:47,060
エンコードは
Metalコマンドバッファに

198
00:13:47,828 --> 00:13:51,765
交点の求め方は
いくつかありますが―

199
00:13:51,932 --> 00:13:56,637
この場合は各レイで
最も近い交点を使います

200
00:13:58,071 --> 00:14:03,043
そしてプライマリレイを
格納したレイバッファと―

201
00:13:58,071 --> 00:14:03,043
そしてプライマリレイを
格納したレイバッファと―

202
00:14:03,310 --> 00:14:06,813
交差情報を
格納するバッファを提供します

203
00:14:07,748 --> 00:14:12,853
画像の幅×高さで示される
レイの本数も必要です

204
00:14:13,687 --> 00:14:16,356
最後に加速構造を提供します

205
00:14:17,624 --> 00:14:23,063
MPSは最も近い交点を求め
交差情報をバッファに格納

206
00:14:23,230 --> 00:14:27,000
あとはシェーディングの計算です

207
00:14:28,535 --> 00:14:31,071
別の計算カーネルを起動します

208
00:14:31,572 --> 00:14:35,809
フラグメントシェーダと
同様の処理が可能です

209
00:14:35,909 --> 00:14:40,481
標準的なテクスチャや関数が
計算カーネルでも―

210
00:14:40,581 --> 00:14:42,616
利用できます

211
00:14:43,684 --> 00:14:46,653
しかしシェーディングには

212
00:14:46,753 --> 00:14:49,823
交点と頂点属性の両方が必要です

213
00:14:49,990 --> 00:14:53,727
フラグメントシェーダがする
頂点属性の補間は

214
00:14:53,827 --> 00:14:57,564
交差データに基づき
自分で行ってください

215
00:14:58,832 --> 00:15:01,735
まず交点を計算しましょう

216
00:14:58,832 --> 00:15:01,735
まず交点を計算しましょう

217
00:15:03,103 --> 00:15:06,573
レイは始点と方向で定義されます

218
00:15:09,343 --> 00:15:13,080
これが
交差判定の結果の構造体です

219
00:15:13,447 --> 00:15:15,148
distanceに―

220
00:15:15,249 --> 00:15:20,754
レイの始点から交点までの
距離が示されます

221
00:15:20,988 --> 00:15:24,458
交差がない場合は
負となります

222
00:15:26,426 --> 00:15:29,496
primitiveIndexは
交差した三角形を示し

223
00:15:30,230 --> 00:15:33,800
最終フィールドは
頂点属性の補間に使用します

224
00:15:35,035 --> 00:15:39,206
ここには UとVという
重心座標が入り

225
00:15:39,306 --> 00:15:44,545
三角形の頂点に対する
交点の位置を示します

226
00:15:45,412 --> 00:15:49,016
３つ目の重心座標は
合計の１から―

227
00:15:49,116 --> 00:15:54,021
先ほどの２つの座標を引き
Wを算出します

228
00:15:55,422 --> 00:16:01,628
三角形の各頂点で
頂点属性が定義されていれば―

229
00:15:55,422 --> 00:16:01,628
三角形の各頂点で
頂点属性が定義されていれば―

230
00:16:02,262 --> 00:16:07,868
補間されるのは 重心座標で
加重和された属性です

231
00:16:08,168 --> 00:16:11,071
例えば 頂点の色属性があれば―

232
00:16:11,171 --> 00:16:15,642
各頂点の色の加重和が
補間された色です

233
00:16:18,111 --> 00:16:22,816
ここまででインターセクタと
加速構造を作成

234
00:16:23,450 --> 00:16:27,721
プライマリレイを生成して
交点を調べ―

235
00:16:28,222 --> 00:16:32,826
シェーディングを計算して
色を付けました

236
00:16:32,926 --> 00:16:34,695
画像を見ましょう

237
00:16:35,963 --> 00:16:39,266
加速構造が表すジオメトリと

238
00:16:39,366 --> 00:16:42,936
補間した頂点色とライティングが
確認できます

239
00:16:43,804 --> 00:16:47,341
さらに効果を加えましょう

240
00:16:48,642 --> 00:16:51,278
まずは影を加えます

241
00:16:53,347 --> 00:16:55,782
シェーディング点に―

242
00:16:55,883 --> 00:17:00,087
光が到達していることを
確認しましょう

243
00:16:55,883 --> 00:17:00,087
光が到達していることを
確認しましょう

244
00:17:00,821 --> 00:17:06,393
そのために交点から光源に
シャドウレイを飛ばします

245
00:17:07,528 --> 00:17:12,332
光源に到達しなければ
その点は影ということで

246
00:17:12,432 --> 00:17:14,701
色を加えないほうがいいです

247
00:17:17,570 --> 00:17:19,640
シャドウレイを格納するために

248
00:17:19,740 --> 00:17:22,976
シェーディングカーネルを
修正します

249
00:17:24,310 --> 00:17:27,347
そして再び交差を判定し

250
00:17:28,015 --> 00:17:29,783
最終カーネルを起動

251
00:17:29,883 --> 00:17:33,053
シャドウレイの交差情報に
基づき―

252
00:17:33,153 --> 00:17:35,889
画像に色付けしてくれます

253
00:17:36,857 --> 00:17:39,426
まずは
シェーディングカーネルです

254
00:17:40,794 --> 00:17:43,931
シャドウレイは
プライマリレイと違います

255
00:17:44,031 --> 00:17:47,734
光源へのオーバーシュートを
避けるため―

256
00:17:47,834 --> 00:17:50,704
交差距離を最大に取ります

257
00:17:52,406 --> 00:17:59,012
三角形インデックスや
重心座標を知る必要はありません

258
00:18:00,180 --> 00:18:04,017
シェーディング点が
影でないと確認するまで―

259
00:18:04,117 --> 00:18:07,554
色を加えてもいけません

260
00:18:07,788 --> 00:18:12,359
シェーディングカーネルから
インターセクタを通じ―

261
00:18:12,459 --> 00:18:15,596
最終カーネルに色を伝えます

262
00:18:16,263 --> 00:18:18,899
レイ構造体をカスタムしましょう

263
00:18:22,135 --> 00:18:26,673
まずインターセクタに
渡すデータを選びます

264
00:18:27,074 --> 00:18:31,545
最小と最大距離の
フィールドを含むデータです

265
00:18:32,246 --> 00:18:35,449
MPSは この範囲外の交差を無視し

266
00:18:35,549 --> 00:18:38,619
光源へのオーバーシュートを
避けます

267
00:18:40,020 --> 00:18:44,925
次にアプリケーション固有の
データがあるなら―

268
00:18:45,025 --> 00:18:49,229
レイ構造体の最後に追加できます

269
00:18:49,663 --> 00:18:53,133
そうすれば
読み出す際に飛ばします

270
00:18:53,734 --> 00:18:56,870
この場合は
色のシェードを加えれば―

271
00:18:56,970 --> 00:19:00,774
最終カーネルに伝達されるのです

272
00:18:56,970 --> 00:19:00,774
最終カーネルに伝達されるのです

273
00:19:02,142 --> 00:19:04,845
インターセクタに構成します

274
00:19:05,179 --> 00:19:08,816
まず rayDataTypeを設定し―

275
00:19:10,551 --> 00:19:14,188
それから rayStrideを設定します

276
00:19:16,457 --> 00:19:19,092
次にシャドウレイを飛ばします

277
00:19:20,794 --> 00:19:23,230
これは元の呼び出しです

278
00:19:23,464 --> 00:19:28,769
シャドウレイの目的は
光源から見えるかどうかの確認です

279
00:19:28,869 --> 00:19:30,871
２つ最適化できます

280
00:19:31,472 --> 00:19:34,775
１つ目は レイと同様に―

281
00:19:34,875 --> 00:19:40,447
交差データタイプや
戻すデータをカスタムすること

282
00:19:41,882 --> 00:19:47,087
この場合は距離の正負で
交差の有無が確認できるので

283
00:19:47,387 --> 00:19:50,524
データタイプを
距離だけに設定します

284
00:19:50,624 --> 00:19:55,395
これで読み書きするメモリ帯域幅が
節約できます

285
00:19:57,297 --> 00:20:00,834
２つ目は
いずれかの三角形に―

286
00:19:57,297 --> 00:20:00,834
２つ目は
いずれかの三角形に―

287
00:20:00,934 --> 00:20:04,538
交差した時点で
交点探しを終えることです

288
00:20:04,638 --> 00:20:08,509
最も近い交点を探すより
速くなります

289
00:20:09,009 --> 00:20:10,911
intersectionTypeを―

290
00:20:11,011 --> 00:20:15,482
“nearest”から“any”に
変えてください

291
00:20:18,285 --> 00:20:22,322
最後に最終カーネルを起動し
色を加えます

292
00:20:24,124 --> 00:20:29,263
各スレッドがシャドウレイと
交差データを読み込みます

293
00:20:30,164 --> 00:20:32,299
交差距離が正なら―

294
00:20:32,399 --> 00:20:36,737
交点は影なので
それ以上の作業は不要です

295
00:20:37,404 --> 00:20:40,040
正以外なら 影ではないので―

296
00:20:41,108 --> 00:20:44,978
レイの色を読み込み 画像に反映

297
00:20:45,879 --> 00:20:48,315
このように影を付けます

298
00:20:50,651 --> 00:20:54,688
光源から各点が見えるか
確認してから―

299
00:20:54,788 --> 00:20:56,957
ライティングを加えます

300
00:20:57,524 --> 00:20:59,426
レイトレーシングでは―

301
00:20:59,526 --> 00:21:04,731
表面をランダムにトレースし
美しいソフトシャドウにします

302
00:20:59,526 --> 00:21:04,731
表面をランダムにトレースし
美しいソフトシャドウにします

303
00:21:07,201 --> 00:21:09,603
最後はセカンダリレイです

304
00:21:11,104 --> 00:21:15,008
光の跳ね返りを
シミュレートします

305
00:21:15,542 --> 00:21:20,114
すべてのカーネルを
ループで繰り返し―

306
00:21:20,380 --> 00:21:25,152
各回でランダムな方向に
レイを飛ばします

307
00:21:29,623 --> 00:21:31,458
繰り返しのため―

308
00:21:31,558 --> 00:21:34,394
シェーディングカーネルを
修正します

309
00:21:35,062 --> 00:21:37,130
画像を更新したら―

310
00:21:37,231 --> 00:21:40,367
最初の交差判定に戻ります

311
00:21:40,634 --> 00:21:44,304
このループを
好きなだけ繰り返すのです

312
00:21:47,107 --> 00:21:49,610
ではカーネルを修正しましょう

313
00:21:51,745 --> 00:21:56,083
各回でレイの始点を
交点に移動させ

314
00:21:57,484 --> 00:22:00,187
ランダムな方向に飛ばします

315
00:21:57,484 --> 00:22:00,187
ランダムな方向に飛ばします

316
00:22:01,288 --> 00:22:05,959
レイの色と補間した頂点色を
掛け合わせて―

317
00:22:06,727 --> 00:22:11,231
跳ね返った表面の色を
反映させるのです

318
00:22:11,698 --> 00:22:16,303
高度なアプリケーションでは
複雑な計算をしますが

319
00:22:16,470 --> 00:22:21,708
慎重にランダムな方向を選ぶことで
計算が楽になります

320
00:22:22,409 --> 00:22:25,345
逆方向のトレースでも―

321
00:22:25,445 --> 00:22:30,484
各交点でレイの色合いを
直接光に付ければよいのです

322
00:22:31,685 --> 00:22:33,921
以上がセカンダリレイです

323
00:22:35,055 --> 00:22:40,828
光が壁で跳ね返り
箱や天井に入射していますね

324
00:22:41,995 --> 00:22:43,931
適用例は以上です

325
00:22:44,765 --> 00:22:49,002
まずプライマリレイと
シェーディング

326
00:22:49,603 --> 00:22:51,271
次に影を加え―

327
00:22:51,371 --> 00:22:55,509
最後にセカンダリレイで
光を跳ね返らせます

328
00:22:56,076 --> 00:23:00,047
デモに切り替えて
見てみましょう

329
00:22:56,076 --> 00:23:00,047
デモに切り替えて
見てみましょう

330
00:23:03,917 --> 00:23:08,956
12.9インチのiPad Proで
動かしています

331
00:23:09,590 --> 00:23:11,692
アプリケーションを拡張し

332
00:23:11,792 --> 00:23:15,896
高度なライティングや
シェーディングなどを支援

333
00:23:16,029 --> 00:23:20,734
これらの機能を使った
複雑なシーンを見ましょう

334
00:23:25,939 --> 00:23:28,041
“State of the Union”で
お見せした―

335
00:23:28,141 --> 00:23:32,279
“Amazon Lumberyard Bistro”の
シーンです

336
00:23:32,646 --> 00:23:35,349
使われている三角形は約100万個

337
00:23:35,449 --> 00:23:37,918
iPad Pro上で―

338
00:23:38,018 --> 00:23:42,356
毎秒2000万本近くのレイを
実現しています

339
00:23:42,456 --> 00:23:46,994
プライマリやシャドウ
セカンダリレイの合計です

340
00:23:48,262 --> 00:23:51,532
このような
アプリケーションの実装に

341
00:23:51,632 --> 00:23:55,002
簡単に使えるAPIを作成しました

342
00:23:55,936 --> 00:23:57,738
ではデモを終わります

343
00:23:59,139 --> 00:24:00,140
ありがとう

344
00:23:59,139 --> 00:24:00,140
ありがとう

345
00:24:00,240 --> 00:24:03,377
(拍手)

346
00:24:03,477 --> 00:24:08,482
このアプリケーションは
サンプルとして提供するので―

347
00:24:09,049 --> 00:24:12,386
お話ししたこと以外も
確認できます

348
00:24:12,553 --> 00:24:15,389
サンプルをダウンロードして―

349
00:24:15,489 --> 00:24:19,126
ご自身でジオメトリなどを
加えてください

350
00:24:19,459 --> 00:24:23,597
まだご説明していないことが
多くあるので―

351
00:24:23,697 --> 00:24:27,334
ドキュメントなどで
ご確認ください

352
00:24:27,734 --> 00:24:30,470
マルチGPUへの拡張については―

353
00:24:30,571 --> 00:24:33,373
ウェインがお話しします

354
00:24:35,542 --> 00:24:36,410
ありがとう

355
00:24:36,510 --> 00:24:41,949
(拍手)

356
00:24:42,049 --> 00:24:43,083
ありがとう

357
00:24:43,584 --> 00:24:44,518
こんにちは

358
00:24:47,921 --> 00:24:52,359
Macには内蔵GPUがありますが―

359
00:24:52,459 --> 00:24:56,497
高性能のeGPUを
複数 外付けできます

360
00:24:57,397 --> 00:25:01,201
これらのGPUをすべて使って―

361
00:24:57,397 --> 00:25:01,201
これらのGPUをすべて使って―

362
00:25:01,301 --> 00:25:04,338
レイトレーシングを
高速化しましょう

363
00:25:05,172 --> 00:25:09,576
そのために検討すべきことが
３つあります

364
00:25:10,210 --> 00:25:14,281
１つ目は
どのように処理を分散するか

365
00:25:15,649 --> 00:25:20,587
２つ目は GPUが
データを交換する時に―

366
00:25:20,687 --> 00:25:22,823
どう対処するか

367
00:25:23,757 --> 00:25:27,027
３つ目は
どのように同期するかです

368
00:25:27,561 --> 00:25:32,065
今週 導入する
Metalイベントを紹介します

369
00:25:32,633 --> 00:25:33,867
始めましょう

370
00:25:35,169 --> 00:25:36,437
処理の分散には―

371
00:25:36,537 --> 00:25:39,306
スプリットフレーム
レンダリングです

372
00:25:39,740 --> 00:25:42,910
まずフレームを領域に分割

373
00:25:43,010 --> 00:25:48,715
次に各領域をGPUに割り当て
並行してレンダリングします

374
00:25:49,850 --> 00:25:53,954
各GPUは完全な
レンダリングパイプラインで

375
00:25:54,054 --> 00:25:59,092
レイの生成や
シェーディングを処理します

376
00:26:00,260 --> 00:26:05,265
すべてのGPUで
処理が終われば取り出し―

377
00:26:05,666 --> 00:26:09,203
領域全体をコピーして合成

378
00:26:10,470 --> 00:26:15,542
合成では 領域をつなげて
１つのフレームバッファに入れます

379
00:26:15,943 --> 00:26:19,046
あるいは 以前の
レンダリング結果と―

380
00:26:19,146 --> 00:26:21,715
合わせてノイズを除去します

381
00:26:23,484 --> 00:26:29,156
レンダリング前に必ず
各GPUにシーンをコピーします

382
00:26:30,057 --> 00:26:35,696
頂点バッファやテクスチャは
全GPUに複製してください

383
00:26:36,463 --> 00:26:40,067
ショーンが紹介した加速構造もです

384
00:26:42,402 --> 00:26:44,638
加速構造については―

385
00:26:44,738 --> 00:26:49,209
各GPUでゼロから
作成するのは避けたいです

386
00:26:49,510 --> 00:26:51,111
そこで追加したのが―

387
00:26:51,211 --> 00:26:57,217
既存の加速構造を
各GPUにコピーできるAPIです

388
00:26:58,085 --> 00:27:00,854
このコピーは非再帰的なので―

389
00:26:58,085 --> 00:27:00,854
このコピーは非再帰的なので―

390
00:27:00,954 --> 00:27:07,027
加速構造にアタッチした頂点と
インデックスのバッファなどは

391
00:27:07,327 --> 00:27:09,029
別々にコピーして―

392
00:27:09,129 --> 00:27:12,766
先ほど作った加速構造に
アタッチします

393
00:27:16,036 --> 00:27:20,574
これで すべてのGPUに
データを複製しました

394
00:27:21,909 --> 00:27:24,778
マルチGPUにしましたが―

395
00:27:24,878 --> 00:27:29,650
この部分のパイプラインは
ほぼ変わりありません

396
00:27:30,117 --> 00:27:32,686
ただしマルチGPUでは―

397
00:27:32,786 --> 00:27:38,058
各GPUが処理する画面に
再生成してはなりません

398
00:27:38,425 --> 00:27:40,027
その他は同じです

399
00:27:40,828 --> 00:27:46,300
次は マルチGPUで
最も気をつけたい段階で―

400
00:27:46,533 --> 00:27:48,902
最終的な合成です

401
00:27:51,305 --> 00:27:57,377
各GPUはプライベートバッファに
レンダリングするのがベストです

402
00:27:58,011 --> 00:27:59,780
レンダリング後には―

403
00:27:59,880 --> 00:28:04,117
合成に使うGPUに
バッファをコピーします

404
00:27:59,880 --> 00:28:04,117
合成に使うGPUに
バッファをコピーします

405
00:28:04,918 --> 00:28:07,187
Metalのリソースは―

406
00:28:07,287 --> 00:28:11,058
それが作られた
デバイスでのみ使えます

407
00:28:11,391 --> 00:28:13,360
従ってバッファを―

408
00:28:13,460 --> 00:28:17,831
別のGPUにアタッチし
blit転送はできません

409
00:28:18,799 --> 00:28:21,735
システムメモリを通じ
コピーします

410
00:28:23,270 --> 00:28:27,908
効率的に行う方法を
お見せしましょう

411
00:28:29,276 --> 00:28:35,115
別のデバイスのMetalバッファに
共通のCPUを割り当てます

412
00:28:35,949 --> 00:28:38,952
バッファは同じメモリをラップ

413
00:28:39,052 --> 00:28:42,156
デバイスAのバッファへの
書き込みは―

414
00:28:42,356 --> 00:28:45,392
デバイスBのバッファからも
見えます

415
00:28:46,860 --> 00:28:50,964
macOSのパフォーマンスを
優先するため―

416
00:28:51,064 --> 00:28:54,635
プライベートバッファで
レンダリングします

417
00:28:55,135 --> 00:29:00,574
システムメモリを通じて領域を
別のGPUにblit転送します

418
00:28:55,135 --> 00:29:00,574
システムメモリを通じて領域を
別のGPUにblit転送します

419
00:29:01,909 --> 00:29:04,211
設定をご説明しましょう

420
00:29:04,945 --> 00:29:09,049
デバイスAのバッファは
共有ストレージモード

421
00:29:09,650 --> 00:29:12,319
内部でシステムメモリを割り当て

422
00:29:12,486 --> 00:29:15,656
.contentsメソッドを使います

423
00:29:18,559 --> 00:29:20,594
デバイスBのバッファは―

424
00:29:20,694 --> 00:29:25,365
NoCopyで バッファAに
割り当てたメモリをラップ

425
00:29:26,900 --> 00:29:32,406
このAPIでバッファは
ページサイズの倍数にします

426
00:29:32,673 --> 00:29:35,642
長さを水増ししてください

427
00:29:38,745 --> 00:29:43,383
メモリを共有したので
同期について考えます

428
00:29:43,817 --> 00:29:49,223
２つのGPUの動きを示した
タイムラインの一例です

429
00:29:49,456 --> 00:29:52,926
黒ボックスは
コマンドバッファで

430
00:29:53,026 --> 00:29:58,832
緑ボックスは バッファに
エンコードした処理です

431
00:29:59,900 --> 00:30:03,237
上のGPUは
レンダリングをして

432
00:29:59,900 --> 00:30:03,237
上のGPUは
レンダリングをして

433
00:30:03,403 --> 00:30:08,642
処理し終えた領域を
共有バッファにblit転送

434
00:30:09,910 --> 00:30:14,047
同時にGPU Bも
レンダリングを行います

435
00:30:15,015 --> 00:30:17,885
合成に用いるGPUです

436
00:30:18,051 --> 00:30:22,456
GPU Aが作ったバッファが
必要になります

437
00:30:23,323 --> 00:30:25,125
ここで問題が発生

438
00:30:25,826 --> 00:30:28,462
この部分は同期しません

439
00:30:28,862 --> 00:30:34,468
GPU Aの書き込み中に
GPU Bが読み出します

440
00:30:35,602 --> 00:30:38,272
ここでMetalイベントを使用

441
00:30:38,939 --> 00:30:42,409
コマンドバッファに
“Wait”を入れます

442
00:30:42,943 --> 00:30:47,548
実行中のGPUは
ここで処理を止めて―

443
00:30:48,649 --> 00:30:51,952
他方のGPUのシグナルを待ちます

444
00:30:53,453 --> 00:30:57,958
GPU Aが書き込みを終えて
シグナルを発すると

445
00:30:58,058 --> 00:31:00,627
GPU Bが読み出せます

446
00:30:58,058 --> 00:31:00,627
GPU Bが読み出せます

447
00:31:02,529 --> 00:31:05,899
これで同期の問題は解決です

448
00:31:06,667 --> 00:31:11,371
しかし高性能なGPUを
遊ばせておくのは―

449
00:31:11,472 --> 00:31:13,173
もったいないです

450
00:31:13,707 --> 00:31:19,479
GPUが待機する時間は
できるだけ短くしたい

451
00:31:20,814 --> 00:31:23,317
ここでロードバランシングです

452
00:31:24,518 --> 00:31:27,955
GPUに対して
均等に画面を分割したことで

453
00:31:28,055 --> 00:31:29,990
問題が発生しました

454
00:31:30,257 --> 00:31:34,828
まずGPUの性能差を
考慮していないのが問題です

455
00:31:35,696 --> 00:31:40,300
一方のGPUが速ければ
先に処理を終えます

456
00:31:41,535 --> 00:31:47,274
また 画面の領域によって
複雑さが違うのも問題です

457
00:31:47,474 --> 00:31:51,011
複雑なジオメトリなどが
あり得ます

458
00:31:52,246 --> 00:31:56,283
つまり領域を
調整する必要があるのです

459
00:31:56,783 --> 00:32:01,255
各GPUがレンダリングに
かかる時間を―

460
00:31:56,783 --> 00:32:01,255
各GPUがレンダリングに
かかる時間を―

461
00:32:01,355 --> 00:32:02,923
同じにするのです

462
00:32:04,191 --> 00:32:09,863
では まず固定された分割を
変えて処理しましょう

463
00:32:10,531 --> 00:32:13,367
GPUの実行時間を計って―

464
00:32:13,467 --> 00:32:17,638
次に割り当てる領域の
広さを判断します

465
00:32:19,873 --> 00:32:22,643
処理中に これを続けます

466
00:32:23,210 --> 00:32:27,047
画面のどの部分であろうと

467
00:32:27,147 --> 00:32:30,317
GPUの性能に合わせられます

468
00:32:32,753 --> 00:32:37,758
コマンドバッファ
完了ハンドラを使いましょう

469
00:32:38,692 --> 00:32:42,563
これは コマンドバッファの
実行後に―

470
00:32:42,663 --> 00:32:45,632
使えるCPUコードの
ブロックです

471
00:32:46,767 --> 00:32:48,936
iOSではコマンドバッファに―

472
00:32:49,036 --> 00:32:54,408
GPUでの実行に必要な時間が
分かるプロパティがあります

473
00:32:55,475 --> 00:32:59,713
しかし macOSでは
近似値を出す必要があります

474
00:33:00,681 --> 00:33:05,919
完了ハンドラが呼び出されると
ホスト時間が残ります

475
00:33:06,353 --> 00:33:08,522
その時間の差から―

476
00:33:08,622 --> 00:33:12,826
GPUの実行時間が分かるのです

477
00:33:13,327 --> 00:33:18,732
例えば これら３つの
コマンドバッファの場合は

478
00:33:18,832 --> 00:33:24,304
３と０で完了ハンドラが
呼び出された時間の差です

479
00:33:26,473 --> 00:33:30,144
ではデモをお見せしましょう

480
00:33:42,055 --> 00:33:47,027
ショーンが先ほど
お見せしたシーンですね

481
00:33:47,427 --> 00:33:49,830
MacBook Pro上です

482
00:33:50,764 --> 00:33:52,633
画面の左上に―

483
00:33:52,733 --> 00:33:57,004
毎秒 放射しているレイの
本数を表示しています

484
00:33:57,104 --> 00:33:59,073
プライマリレイと―

485
00:33:59,173 --> 00:34:03,610
セカンダリレイと
シャドウレイの合計です

486
00:33:59,173 --> 00:34:03,610
セカンダリレイと
シャドウレイの合計です

487
00:34:04,311 --> 00:34:07,247
現在は
毎秒 およそ3000万本で

488
00:34:07,347 --> 00:34:10,317
この数字を上げたいですね

489
00:34:10,417 --> 00:34:14,254
外付けしていたeGPUを
１台 有効にします

490
00:34:16,822 --> 00:34:18,257
画面の表示どおり―

491
00:34:18,358 --> 00:34:22,362
RX 580と内蔵GPUで
動かしています

492
00:34:22,562 --> 00:34:26,266
性能は倍加して
毎秒 約6000万レイです

493
00:34:26,833 --> 00:34:28,202
緑の線で―

494
00:34:28,302 --> 00:34:31,972
GPUごとの作業領域を
分けています

495
00:34:32,072 --> 00:34:34,908
一方のGPUが線の上を

496
00:34:35,007 --> 00:34:37,543
他方が下を担当しています

497
00:34:38,645 --> 00:34:42,549
eGPUで２倍ほど
速くなりましたが―

498
00:34:43,116 --> 00:34:45,619
もっと速くなるはず

499
00:34:45,719 --> 00:34:49,723
問題はeGPUが
待機していることです

500
00:34:50,090 --> 00:34:52,292
分割を固定せずに―

501
00:34:52,592 --> 00:34:55,728
ロードバランシングを変えます

502
00:34:56,096 --> 00:34:59,133
RX 580の担当領域がかなり増え

503
00:34:59,233 --> 00:35:01,902
速度も飛躍的に向上しました

504
00:34:59,233 --> 00:35:01,902
速度も飛躍的に向上しました

505
00:35:04,405 --> 00:35:07,074
使われている三角形は
約100万個

506
00:35:07,174 --> 00:35:09,710
では外のシーンに移ります

507
00:35:09,810 --> 00:35:13,146
同じく
“Amazon Lumberyard Bistro”です

508
00:35:13,247 --> 00:35:16,717
使われている三角形は
約300万個

509
00:35:17,484 --> 00:35:20,888
さらにGPUを有効にします

510
00:35:20,988 --> 00:35:24,157
今回は Vega 64です

511
00:35:24,792 --> 00:35:27,161
担当領域が広いですね

512
00:35:28,762 --> 00:35:33,534
まったく異なる３つのGPUが
動いています

513
00:35:33,634 --> 00:35:36,937
アーキテクチャも性能も
違うGPUが―

514
00:35:37,037 --> 00:35:39,807
見事な描画を実現しています

515
00:35:43,510 --> 00:35:48,582
(拍手)

516
00:35:50,884 --> 00:35:53,887
ご紹介した
MPSRayIntersectorは―

517
00:35:53,987 --> 00:35:58,592
GPUで交差判定を
高速化するAPIです

518
00:35:59,727 --> 00:36:04,531
すべてのiOSとmacOSで
利用できます

519
00:35:59,727 --> 00:36:04,531
すべてのiOSとmacOSで
利用できます

520
00:36:04,631 --> 00:36:08,302
マルチGPUで拡張も可能です

521
00:36:09,670 --> 00:36:13,841
皆さんがどう使うか
楽しみにしています

522
00:36:14,041 --> 00:36:16,977
本日はパストレーシングを
使いました

523
00:36:17,311 --> 00:36:20,814
ハイブリッドレンダリングも
あります

524
00:36:20,914 --> 00:36:24,618
アンビエントオクルージョン
美しい影や反射も

525
00:36:25,285 --> 00:36:27,221
レンダリング以外にも―

526
00:36:27,387 --> 00:36:33,260
音響や物理シミュレーション
人工知能などにも使われます

527
00:36:34,828 --> 00:36:36,630
皆さんのために―

528
00:36:38,632 --> 00:36:43,270
developer.apple.comで
サンプルコードを紹介しています

529
00:36:43,370 --> 00:36:47,307
詳細やご紹介できなかった機能は

530
00:36:47,407 --> 00:36:50,544
ドキュメントでご確認ください

531
00:36:51,311 --> 00:36:54,214
明日のラボでは
ショーンと僕が―

532
00:36:54,515 --> 00:36:59,987
アプリケーションで使えるよう
皆さんをサポートします

533
00:37:00,087 --> 00:37:01,922
どうぞ参加してください

534
00:37:02,556 --> 00:37:04,825
ありがとうございました

535
00:37:04,925 --> 00:37:07,261
WWDCをお楽しみください

536
00:37:07,461 --> 00:37:12,733
(拍手)