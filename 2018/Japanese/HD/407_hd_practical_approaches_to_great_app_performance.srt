
1
00:00:07,508 --> 00:00:16,082
(音楽)

2
00:00:20,587 --> 00:00:25,726
(拍手)

3
00:00:25,826 --> 00:00:27,227
こんにちは

4
00:00:27,327 --> 00:00:28,462
ジョン･ヘスです

5
00:00:28,562 --> 00:00:34,868
Practical Approaches to Great
App Performanceの話をします

6
00:00:35,302 --> 00:00:37,404
私は
Xcodeチームのエンジニアとして

7
00:00:37,504 --> 00:00:42,543
この数年 パフォーマンスの問題に
取り組んできました

8
00:00:42,643 --> 00:00:45,145
まず Project Findと
Open Quickly

9
00:00:45,245 --> 00:00:50,117
パフォーマンスを左右する
主要な機能となる２つの領域です

10
00:00:50,651 --> 00:00:55,522
最近 XcodeのGUIの応答性について
調査する機会がありました

11
00:00:55,622 --> 00:00:59,359
そこでのアプローチを
共有したいと考えています

12
00:00:59,459 --> 00:01:01,862
私が熟知しているコードと

13
00:00:59,459 --> 00:01:01,862
私が熟知しているコードと

14
00:01:01,962 --> 00:01:04,730
初めて経験したコードの
両方で行いました

15
00:01:05,833 --> 00:01:11,138
今日のセッションで
最も大切な教訓を１つ教えます

16
00:01:11,338 --> 00:01:15,042
“測定こそが
パフォーマンスの基盤となる”

17
00:01:15,609 --> 00:01:18,212
パフォーマンスの問題を
解決したければ

18
00:01:18,378 --> 00:01:22,816
まず 測定して現状を知ることです

19
00:01:23,584 --> 00:01:26,186
修正を繰り返し行う場合―

20
00:01:26,286 --> 00:01:32,426
期待どおりの効果が出ているか
毎回測定する必要があります

21
00:01:33,360 --> 00:01:36,897
問題が解決したら
再度測定を行います

22
00:01:37,130 --> 00:01:39,666
最初の段階と比較して―

23
00:01:39,766 --> 00:01:44,972
パフォーマンスの改善状況を
定量化します

24
00:01:45,072 --> 00:01:49,510
それを上司や同僚やユーザと
共有するのです

25
00:01:50,577 --> 00:01:53,847
ユーザ向けに
パフォーマンス改善を行う場合―

26
00:01:54,248 --> 00:01:58,085
“トータルパフォーマンス
インパクト”が大切です

27
00:01:58,552 --> 00:02:04,191
例えば アプリケーションの
１つの分野の機能と性能を―

28
00:01:58,552 --> 00:02:04,191
例えば アプリケーションの
１つの分野の機能と性能を―

29
00:02:05,092 --> 00:02:06,393
50パーセント改善します

30
00:02:06,493 --> 00:02:09,496
でも ユーザの１パーセントしか
使わない機能だったら？

31
00:02:09,596 --> 00:02:14,968
すべてのユーザがよく使う機能を
10パーセント改善する方が

32
00:02:15,068 --> 00:02:17,171
大きなインパクトがあります

33
00:02:17,271 --> 00:02:19,206
エッジケースの最適化ではなく―

34
00:02:19,306 --> 00:02:22,543
トータルなインパクトを
重視してください

35
00:02:24,778 --> 00:02:28,115
性能のバグをどう解決しますか？

36
00:02:28,215 --> 00:02:29,783
通常のバグの場合―

37
00:02:29,883 --> 00:02:33,787
ユーザからの不具合報告で
始まります

38
00:02:33,887 --> 00:02:37,824
アプリケーションの不具合状況が
記されています

39
00:02:38,091 --> 00:02:41,195
問題のある動作を
再現する方法を見つけ―

40
00:02:41,295 --> 00:02:43,197
わざと不具合を起こします

41
00:02:43,530 --> 00:02:46,366
そこで デバッガに接続すれば―

42
00:02:46,466 --> 00:02:49,703
不具合の内容が確認できます

43
00:02:50,804 --> 00:02:53,674
そこで コードの本来の動きと
組み合わせて

44
00:02:53,841 --> 00:02:57,544
必要な修正と
不審な動きの排除を行います

45
00:02:57,811 --> 00:03:00,981
何か副作用が
起きていないか確認して

46
00:02:57,811 --> 00:03:00,981
何か副作用が
起きていないか確認して

47
00:03:01,081 --> 00:03:04,484
バグが完全になくなるまで
検証を続けます

48
00:03:05,652 --> 00:03:09,389
性能のバグもこれと同様です

49
00:03:09,957 --> 00:03:11,992
唯一違うのは
デバッガではなく―

50
00:03:12,092 --> 00:03:16,630
測定に適したツール
“プロファイラ”を使用します

51
00:03:16,897 --> 00:03:21,502
プログラムの動作が遅いのを
再現する方法を見つけます

52
00:03:21,935 --> 00:03:24,571
プロファイラを用いて
そのステップを走らせると

53
00:03:24,671 --> 00:03:28,442
動作が遅い時の
コードの動きが分かります

54
00:03:29,176 --> 00:03:30,611
その知識と―

55
00:03:30,711 --> 00:03:33,947
その時 プログラムが
行うべき動作を統合します

56
00:03:34,047 --> 00:03:37,117
そして 問題となっている
ステップを排除します

57
00:03:37,217 --> 00:03:38,819
基本的に―

58
00:03:38,919 --> 00:03:42,756
ムダなステップを取り除くと
コードが高速化します

59
00:03:42,856 --> 00:03:44,658
どんな場合でも同じです

60
00:03:45,659 --> 00:03:48,328
コードを修正して―

61
00:03:48,428 --> 00:03:52,599
期待した結果が出るまで
修正と測定を繰り返します

62
00:03:54,968 --> 00:03:56,737
このような作業をする際―

63
00:03:56,837 --> 00:04:00,541
いくつかの状況に遭遇します

64
00:03:56,837 --> 00:04:00,541
いくつかの状況に遭遇します

65
00:04:00,807 --> 00:04:04,111
状況によって
バグを再現させるための

66
00:04:04,211 --> 00:04:06,480
コードのテスト方法も異なります

67
00:04:06,847 --> 00:04:10,317
時々起こるのが
性能のリグレッションです

68
00:04:10,617 --> 00:04:15,822
順調に動作していたのが
誰かがチェックすると

69
00:04:15,923 --> 00:04:17,958
性能がひどく落ち込んでいます

70
00:04:18,058 --> 00:04:21,628
その原因を
突き止めなければなりません

71
00:04:21,962 --> 00:04:24,097
リグレッションが明白な場合

72
00:04:24,998 --> 00:04:28,769
あるいは 近い将来に
再現しないと考えた場合

73
00:04:28,869 --> 00:04:33,507
プロファイラを用いたテストで
終わらせるかもしれません

74
00:04:34,408 --> 00:04:38,912
でも パフォーマンスの“勝利”は
簡単にはつかめません

75
00:04:39,446 --> 00:04:43,450
緩やかなリグレッションを
見つけるのは困難です

76
00:04:43,884 --> 00:04:45,552
皆さんにお勧めするのが―

77
00:04:45,652 --> 00:04:47,788
自動化された性能テストを
使うことです

78
00:04:47,888 --> 00:04:49,756
アプリケーションの性能を
把握することで

79
00:04:49,857 --> 00:04:52,726
緩やかなリグレッションに
気付くことができます

80
00:04:55,128 --> 00:04:57,297
もう１つの状況です

81
00:04:57,397 --> 00:05:01,435
アプリケーションの動作が
ずっと同じ場合です

82
00:04:57,397 --> 00:05:01,435
アプリケーションの動作が
ずっと同じ場合です

83
00:05:01,568 --> 00:05:05,005
例えば 描画テストで
45fpsで動いていて

84
00:05:05,105 --> 00:05:06,640
60fpsが目標だとします

85
00:05:06,740 --> 00:05:10,143
わずかに改善する必要がありますが

86
00:05:10,244 --> 00:05:15,849
部分的な修正で解決できると
分かっているケースです

87
00:05:16,250 --> 00:05:20,387
この状況でも 自動化された
性能テストが有効です

88
00:05:20,487 --> 00:05:22,956
これまでの経験から言えます

89
00:05:24,758 --> 00:05:26,460
３番目の状況です

90
00:05:26,560 --> 00:05:29,429
設計不良により
アプリケーションの性能が

91
00:05:29,530 --> 00:05:32,533
目標より大きく低下しています

92
00:05:33,400 --> 00:05:36,103
部分的な修正では改善できません

93
00:05:36,203 --> 00:05:39,806
過去に何度か修正しましたが

94
00:05:39,907 --> 00:05:41,708
まだ性能が劣っています

95
00:05:41,909 --> 00:05:45,479
この場合は
徹底的な修正が必要です

96
00:05:45,579 --> 00:05:49,483
機能のコア部分や
アルゴリズムの再設計を行います

97
00:05:49,583 --> 00:05:52,219
性能に大きな影響を与えるからです

98
00:05:52,352 --> 00:05:55,355
このような場合は
性能テストを行い―

99
00:05:55,455 --> 00:05:58,525
問題が解決したか
測定する必要があります

100
00:05:59,159 --> 00:06:02,162
何をテストすべきでしょう

101
00:05:59,159 --> 00:06:02,162
何をテストすべきでしょう

102
00:06:02,262 --> 00:06:06,967
このような修正を行う時は
“一気にすべてを進めない”

103
00:06:07,067 --> 00:06:09,102
これが大切です

104
00:06:09,203 --> 00:06:10,604
本当はそうしたいのです

105
00:06:10,704 --> 00:06:14,675
何もないところから
すべてを組み立てる

106
00:06:15,042 --> 00:06:16,343
でも それは危険です

107
00:06:16,476 --> 00:06:18,378
改善を成し遂げたくても

108
00:06:18,478 --> 00:06:22,382
すべての機能を手直しするのは
苦難の道です

109
00:06:24,017 --> 00:06:27,321
この時 理解すべきなのは―

110
00:06:27,421 --> 00:06:30,491
コードの機能的な制約だけでは
ありません

111
00:06:30,591 --> 00:06:32,492
性能面における制約

112
00:06:32,593 --> 00:06:37,130
そして 多くのユーザに当てはまる
典型的な使用パターンも含まれます

113
00:06:37,231 --> 00:06:41,068
過去に実施した検証が
それを可能にします

114
00:06:41,502 --> 00:06:46,440
私が Xcodeで経験した状況を
共有しましょう

115
00:06:47,107 --> 00:06:51,812
Xcode 9で Project Findの
修正を行いました

116
00:06:52,412 --> 00:06:56,316
目標は数十ミリ秒で
検索結果を表示することです

117
00:06:56,817 --> 00:07:00,587
それについて同僚と議論した時―

118
00:06:56,817 --> 00:07:00,587
それについて同僚と議論した時―

119
00:07:00,687 --> 00:07:04,758
大きなプロジェクトをまたぐ検索が
課題でした

120
00:07:04,858 --> 00:07:07,327
例えば 文字列や“E”を含む文字は

121
00:07:07,427 --> 00:07:09,763
膨大な結果が出ます

122
00:07:10,097 --> 00:07:14,368
アプリケーションが
検索結果を即座に出せたら

123
00:07:14,468 --> 00:07:16,136
かなり高速です

124
00:07:16,370 --> 00:07:19,106
しかし 通常はどうでしょう

125
00:07:19,306 --> 00:07:22,943
使用しているAPIや
クラスの名前を探します

126
00:07:23,043 --> 00:07:26,113
または 参照している画像の名前

127
00:07:26,213 --> 00:07:28,815
たぶん数十か数百の結果を出します

128
00:07:28,916 --> 00:07:33,353
もちろん 100万件の検索結果が
必要な時もあります

129
00:07:33,453 --> 00:07:36,323
しかし 通常は数百件です

130
00:07:36,690 --> 00:07:39,626
検索で行うことのいくつかは

131
00:07:39,726 --> 00:07:43,430
生の検索結果を出すことです

132
00:07:43,530 --> 00:07:48,035
他には 効率的に
テキストにインデックスを付けて

133
00:07:48,135 --> 00:07:49,970
最初の作業を省くことです

134
00:07:50,070 --> 00:07:54,675
これら２つの状況は
目的がまったく異なるので

135
00:07:54,775 --> 00:07:58,412
どちらを優先するかで
最適化の方法が異なります

136
00:07:58,745 --> 00:08:01,215
ですから大切なのは―

137
00:07:58,745 --> 00:08:01,215
ですから大切なのは―

138
00:08:01,582 --> 00:08:05,853
ユーザの目的を理解して
それに合った最適化を行うことです

139
00:08:07,855 --> 00:08:11,492
テストには
手作業か自動かに関わらず―

140
00:08:11,592 --> 00:08:13,927
ある種のフォームが必要です

141
00:08:16,163 --> 00:08:18,699
２つの性能テストを紹介します

142
00:08:18,799 --> 00:08:21,869
Xcodeの性能を測る
典型的なものです

143
00:08:23,637 --> 00:08:25,072
ユニットテストと―

144
00:08:25,172 --> 00:08:26,673
インテグレーションテスト

145
00:08:27,107 --> 00:08:28,475
２つを比較します

146
00:08:29,243 --> 00:08:30,844
まず ユニットテストです

147
00:08:30,944 --> 00:08:34,715
アプリケーションの
一部の機能を分離して

148
00:08:34,815 --> 00:08:36,650
性能を自動測定します

149
00:08:36,917 --> 00:08:38,652
依存を遮断して―

150
00:08:38,751 --> 00:08:43,056
他の機能と切り離して
テストを実施します

151
00:08:43,390 --> 00:08:47,995
私が Xcodeのコード補完のための
テストを行うなら

152
00:08:48,095 --> 00:08:50,731
３つのテストを１セットにします

153
00:08:50,998 --> 00:08:52,132
まず１つ目

154
00:08:52,232 --> 00:08:55,903
コンパイラを使って
生データの結果を得て―

155
00:08:56,003 --> 00:08:58,305
コード補完の候補を返します

156
00:08:58,839 --> 00:09:00,541
そして２つ目

157
00:08:58,839 --> 00:09:00,541
そして２つ目

158
00:09:00,774 --> 00:09:03,977
結果の相関性 序列 スコアを
測定し―

159
00:09:04,077 --> 00:09:06,113
どれを表示するか判断します

160
00:09:06,813 --> 00:09:10,284
３つ目は それらの結果をもとに

161
00:09:10,384 --> 00:09:13,620
画面のUI要素に入れていきます

162
00:09:13,854 --> 00:09:15,789
この３つのテストにより―

163
00:09:15,889 --> 00:09:20,861
開発環境に必要な
コード補完の要素をカバーできます

164
00:09:23,030 --> 00:09:27,201
ユニットテストには
いくつかのメリットがあります

165
00:09:27,534 --> 00:09:30,971
リグレッションに
重点が置かれているので

166
00:09:31,071 --> 00:09:33,607
問題が起きた時
場所の特定が容易です

167
00:09:33,707 --> 00:09:36,376
コードがすでに調査済みだからです

168
00:09:37,578 --> 00:09:41,448
さらに 再現性の高い結果を
生成します

169
00:09:41,548 --> 00:09:45,152
実施ごとに
大きなばらつきもありません

170
00:09:45,319 --> 00:09:47,487
コードは明確です

171
00:09:48,088 --> 00:09:50,157
次に インテグレーションテスト

172
00:09:50,958 --> 00:09:54,027
ここでは ユーザと同じ状況で―

173
00:09:54,128 --> 00:09:57,698
アプリケーションの性能を
測定します

174
00:09:58,232 --> 00:09:59,433
全体的にです

175
00:09:59,833 --> 00:10:05,272
インテグレーションテストで
コード補完を書いているとします

176
00:09:59,833 --> 00:10:05,272
インテグレーションテストで
コード補完を書いているとします

177
00:10:05,772 --> 00:10:07,908
Xcodeのアプリケーションを
すべて立ち上げ―

178
00:10:08,308 --> 00:10:09,910
ソースファイルを開きます

179
00:10:10,010 --> 00:10:12,913
ファイルを操作し タイプして―

180
00:10:13,080 --> 00:10:15,582
コード補完を何度も繰り返します

181
00:10:15,949 --> 00:10:19,653
この時 Xcodeが何をやっているか
監視すると―

182
00:10:19,753 --> 00:10:23,290
他には何も行っていません

183
00:10:24,024 --> 00:10:27,361
私のタイプどおりに
描画し配置して―

184
00:10:27,461 --> 00:10:30,297
シンタックスカラーリングを
しているのです

185
00:10:30,430 --> 00:10:33,901
裏ではインデックスを作成し
ステータスを取得して

186
00:10:34,001 --> 00:10:37,004
Assistant Editorに
表示するファイルを決めています

187
00:10:37,104 --> 00:10:40,874
これらのすべては
コード補完と連動して

188
00:10:40,974 --> 00:10:42,509
CPUのリソースで競合しています

189
00:10:43,010 --> 00:10:47,714
プロファイラでは 80パーセントを
シンタックスカラーリング

190
00:10:47,815 --> 00:10:50,884
20パーセントをコード補完に
費やしているのが分かります

191
00:10:50,984 --> 00:10:53,987
コード補完の性能を改善する―

192
00:10:54,154 --> 00:10:56,056
ベストな方法が見つかりました

193
00:10:56,156 --> 00:10:58,458
シンタックスカラーリングの
先送りです

194
00:10:58,592 --> 00:11:02,763
これはユニットテストでは
得られなかった知識です

195
00:10:58,592 --> 00:11:02,763
これはユニットテストでは
得られなかった知識です

196
00:11:03,030 --> 00:11:06,433
今日 皆さんに２つの教訓を
与えられるなら―

197
00:11:06,533 --> 00:11:08,068
２つ目は以下です

198
00:11:08,168 --> 00:11:09,670
“性能の検証は―”

199
00:11:09,770 --> 00:11:13,540
“インテグレーションテストから
始める”

200
00:11:13,640 --> 00:11:16,743
そこでユーザ体験を測定します

201
00:11:17,978 --> 00:11:21,281
テストと測定について
説明してきましたが―

202
00:11:21,381 --> 00:11:25,619
今からツールを使った
プロファイリングの紹介をします

203
00:11:25,719 --> 00:11:27,454
デモ機を使用します

204
00:11:34,628 --> 00:11:36,797
パフォーマンスに問題があり―

205
00:11:36,897 --> 00:11:39,800
Xcode 9とXcode 10の間で
修正を行いました

206
00:11:40,234 --> 00:11:41,468
それをお見せします

207
00:11:41,568 --> 00:11:43,504
Xcode 9を立ち上げ―

208
00:11:44,238 --> 00:11:46,139
アプリケーションのソースを
開きます

209
00:11:47,207 --> 00:11:50,110
これから見るのは
タブ作成の問題です

210
00:11:50,344 --> 00:11:53,580
“command + T”を数回押します

211
00:11:53,680 --> 00:11:56,650
この時 画面が黒く点滅して

212
00:11:56,750 --> 00:11:59,253
タブを作成するのに
数秒かかります

213
00:11:59,520 --> 00:12:03,257
明らかに期待していない動作です

214
00:11:59,520 --> 00:12:03,257
明らかに期待していない動作です

215
00:12:03,524 --> 00:12:04,825
修正の必要があります

216
00:12:04,925 --> 00:12:07,060
その方法をご覧ください

217
00:12:08,195 --> 00:12:11,131
Instrumentsを立ち上げます
プロファイリングのツールです

218
00:12:11,298 --> 00:12:13,133
メニューのXcodeから開けます

219
00:12:13,233 --> 00:12:15,769
“Open Developer Tool”の下の
“Instruments”です

220
00:12:15,869 --> 00:12:18,005
これは Xcode 9なので

221
00:12:18,105 --> 00:12:20,474
そこから“Instruments”が
立ち上がります

222
00:12:20,574 --> 00:12:22,543
でも今回は
私の“Dock”にある―

223
00:12:22,643 --> 00:12:24,178
Xcode 10用を使います

224
00:12:24,511 --> 00:12:27,414
Xcodeを隠して持ってきます

225
00:12:29,049 --> 00:12:30,918
Instrumentsが
立ち上がりました

226
00:12:31,685 --> 00:12:35,856
測定に使う
プロファイリングツールの一覧です

227
00:12:36,223 --> 00:12:37,591
さまざまな測定が可能です

228
00:12:37,691 --> 00:12:39,827
グラフィックスの使用率

229
00:12:40,060 --> 00:12:41,528
メモリ消費量

230
00:12:41,728 --> 00:12:42,796
I/O

231
00:12:42,996 --> 00:12:44,298
さまざまな時間

232
00:12:45,632 --> 00:12:49,269
どれから使えばいいのか
戸惑うかもしれません

233
00:12:51,471 --> 00:12:53,140
お勧めがあります

234
00:12:53,640 --> 00:12:56,143
この中の１つを学ぶなら―

235
00:12:56,243 --> 00:12:57,845
Time Profilerです

236
00:12:58,212 --> 00:13:01,515
私は測定の95パーセント以上を
これで行っています

237
00:12:58,212 --> 00:13:01,515
私は測定の95パーセント以上を
これで行っています

238
00:13:01,615 --> 00:13:04,218
アプリケーションが遅いという
問題は―

239
00:13:04,318 --> 00:13:08,155
処理時間が長すぎるのが原因です

240
00:13:08,655 --> 00:13:11,658
I/Oが多すぎて遅いのならば―

241
00:13:11,825 --> 00:13:15,529
時間に関係するので
Time Profilerで検証できます

242
00:13:16,029 --> 00:13:17,831
１つだけ選ぶならば

243
00:13:17,965 --> 00:13:19,566
Time Profilerです

244
00:13:20,467 --> 00:13:22,302
使い方を見ましょう

245
00:13:25,639 --> 00:13:29,243
ダブルクリックするだけで
立ち上がります

246
00:13:30,377 --> 00:13:32,579
“Instruments”を
全画面にします

247
00:13:33,580 --> 00:13:35,682
ここでXcodeを記録します

248
00:13:36,316 --> 00:13:39,353
左上の
“Instruments”ウインドウで

249
00:13:39,453 --> 00:13:42,789
記録プロセスを
コントロールできます

250
00:13:43,023 --> 00:13:45,859
デフォルトでは
この“記録”ボタンを押すと

251
00:13:45,959 --> 00:13:48,095
すべてのプロセスが
“My Mac”に記録されます

252
00:13:48,195 --> 00:13:50,597
今回は Xcodeに絞ります

253
00:13:55,068 --> 00:13:57,638
ターゲットを
Xcodeに切り替えて―

254
00:13:58,238 --> 00:13:59,306
“記録”を押します

255
00:13:59,406 --> 00:14:01,675
ウインドウのこの部分に注目して

256
00:13:59,406 --> 00:14:01,675
ウインドウのこの部分に注目して

257
00:14:01,775 --> 00:14:03,610
トラックしたいと思います

258
00:14:03,710 --> 00:14:05,979
ウインドウを少し小さくします

259
00:14:06,079 --> 00:14:08,048
まだ見えますね

260
00:14:08,148 --> 00:14:11,685
先ほど問題のあった
タブをいくつか作成します

261
00:14:12,986 --> 00:14:16,089
ここのグラフが変わりました

262
00:14:16,190 --> 00:14:17,691
ここで停止して―

263
00:14:18,425 --> 00:14:19,960
Instrumentsに戻ります

264
00:14:21,628 --> 00:14:23,330
何が起きたでしょう？

265
00:14:23,797 --> 00:14:25,566
プロファイラが走っている間―

266
00:14:25,999 --> 00:14:28,435
デバッガのように
プロセスを追跡していました

267
00:14:28,602 --> 00:14:31,738
毎秒数千回 止まっています

268
00:14:32,072 --> 00:14:35,008
それが止まるたびに
バックトレースを収集します

269
00:14:35,108 --> 00:14:36,376
念のため言いますが

270
00:14:36,477 --> 00:14:40,714
バックトレースはプログラムが
たどった経路を記述しています

271
00:14:40,814 --> 00:14:43,550
例えば functionCの
６行目にいるなら―

272
00:14:43,650 --> 00:14:46,019
メインがAを呼び Bを呼び
そしてCを呼んだからです

273
00:14:46,119 --> 00:14:48,455
そして 経路は
“メイン A B C”となります

274
00:14:48,922 --> 00:14:52,025
Instrumentsが
その１つを選んでこう記述します

275
00:14:52,125 --> 00:14:55,062
“functionCで１ミリ秒費やした”

276
00:14:55,362 --> 00:14:57,898
それがサンプリングの間隔で

277
00:14:57,998 --> 00:14:59,867
ミリ秒ごとに記録するからです

278
00:15:00,934 --> 00:15:02,269
メインスレッドでは―

279
00:15:02,369 --> 00:15:04,805
すべてのバックトレースが
main functionから始まります

280
00:15:04,905 --> 00:15:06,640
application mainを呼んで

281
00:15:06,740 --> 00:15:09,776
枝分かれして
すべてのコードに広がっていきます

282
00:15:10,110 --> 00:15:12,646
これらのバックトレースを
折り畳み―

283
00:15:12,746 --> 00:15:15,182
プレフィックス木を展開します

284
00:15:15,282 --> 00:15:17,384
メインから広がっていくのです

285
00:15:17,484 --> 00:15:20,954
ミリ秒ごとのカウンターを
最上位で集めるので

286
00:15:21,054 --> 00:15:26,360
ソースコード各領域の所要時間を
階層的に見られます

287
00:15:26,660 --> 00:15:30,831
これにより 冗長で不必要な
オペレーションを見つけ―

288
00:15:30,931 --> 00:15:32,199
高速化を図れます

289
00:15:32,299 --> 00:15:36,270
アプリケーションの性能を
向上させる基本手段です

290
00:15:36,937 --> 00:15:38,572
ご想像のとおり―

291
00:15:39,106 --> 00:15:41,742
毎秒数千回のバックトレースです

292
00:15:41,842 --> 00:15:45,579
Instrumentsには
膨大なデータがあります

293
00:15:46,046 --> 00:15:48,015
最も重要なのは―

294
00:15:48,115 --> 00:15:50,884
データをできるだけ
フィルタリングすることです

295
00:15:50,984 --> 00:15:53,820
そうすれば 道筋が見えてきます

296
00:15:53,921 --> 00:15:56,790
細かい点にとらわれてはいけません

297
00:15:56,890 --> 00:16:00,427
ここで 強力なフィルタの
使い方をご紹介します

298
00:15:56,890 --> 00:16:00,427
ここで 強力なフィルタの
使い方をご紹介します

299
00:16:04,565 --> 00:16:08,235
先ほどトラックビューを
見えるようにしました

300
00:16:09,236 --> 00:16:12,873
新しいタブを作っている間に
CPUの使用率が―

301
00:16:12,973 --> 00:16:16,710
どこでどのように変化するか
確認したかったからです

302
00:16:17,044 --> 00:16:19,780
この部分だと分かりました

303
00:16:20,080 --> 00:16:25,552
ドラッグして
そのトレースのエリアを選択し―

304
00:16:25,819 --> 00:16:28,755
“Instruments”に
フォーカスさせました

305
00:16:29,189 --> 00:16:32,926
その間の経路だけに
焦点を当てます

306
00:16:33,026 --> 00:16:35,829
この部分はタブを作る前です

307
00:16:35,929 --> 00:16:38,432
こちらがタブを作った後で―

308
00:16:38,532 --> 00:16:39,867
アプリケーションを止めた時です

309
00:16:39,967 --> 00:16:43,604
最適化する部分ではないので
このデータは見ません

310
00:16:45,105 --> 00:16:45,772
さて―

311
00:16:46,974 --> 00:16:51,578
“Instruments”ウインドウの下に
すべてのトレースデータがあります

312
00:16:51,678 --> 00:16:56,517
デフォルトでは スレッドごとに
一列に表示されています

313
00:16:56,617 --> 00:16:59,219
この例で走っているスレッドは
４つです

314
00:16:59,319 --> 00:17:02,789
これは同時に走る
アプリケーションの数で異なります

315
00:16:59,319 --> 00:17:02,789
これは同時に走る
アプリケーションの数で異なります

316
00:17:03,223 --> 00:17:05,858
私はこれらを集約するために
折り畳みます

317
00:17:05,959 --> 00:17:08,829
また 各スレッドを―

318
00:17:08,929 --> 00:17:14,034
スレッドIDではなく
上位の機能に基づいて折り畳みます

319
00:17:14,134 --> 00:17:17,704
これでGrand Central Dispatchが
使いやすくなります

320
00:17:18,472 --> 00:17:20,574
“Instruments”ウインドウの
下にある―

321
00:17:20,674 --> 00:17:23,109
呼び出し木のボタンを
クリックします

322
00:17:23,944 --> 00:17:26,380
よく分かるようにズームします

323
00:17:26,946 --> 00:17:28,715
いくつかのフィルタがあります

324
00:17:28,816 --> 00:17:32,019
これはスレッド別で
デフォルトは“オン”です

325
00:17:32,453 --> 00:17:34,021
これを無効にして―

326
00:17:34,121 --> 00:17:39,359
スレッドをIDではなく
上位機能別にグループ化します

327
00:17:42,262 --> 00:17:44,531
このトレースを見てください

328
00:17:45,399 --> 00:17:47,801
動作中のスレッドが確認できます

329
00:17:47,901 --> 00:17:52,406
メイントレースの下が
CPU使用量の合計で―

330
00:17:52,940 --> 00:17:55,042
スレッドごとの
CPU使用量が分かります

331
00:17:55,142 --> 00:17:59,179
このトレースの間 他のスレッドは
ほとんど動いていません

332
00:17:59,313 --> 00:18:02,749
ここでメインスレッドだけを
選択して―

333
00:17:59,313 --> 00:18:02,749
ここでメインスレッドだけを
選択して―

334
00:18:02,883 --> 00:18:07,254
この間のメインスレッドだけを
トレースします

335
00:18:08,288 --> 00:18:10,824
このコールの階層を掘り下げて

336
00:18:10,924 --> 00:18:12,993
アプリケーションの動きを
確認します

337
00:18:13,527 --> 00:18:15,729
通常 キーボードを使う時は―

338
00:18:15,829 --> 00:18:18,966
右と下の矢印で操作します

339
00:18:19,266 --> 00:18:22,569
でも今回は
Instrumentsが提供する―

340
00:18:22,669 --> 00:18:24,338
高度なインスペクタを紹介します

341
00:18:24,438 --> 00:18:27,741
インスペクタが見えなければ
このボタンで切り替えてください

342
00:18:27,941 --> 00:18:30,144
この“Extended Detail”のタブで

343
00:18:30,244 --> 00:18:32,379
高度なトレースが可能です

344
00:18:32,746 --> 00:18:36,617
ここでトレースするのは
最も頻繁に現れた経路です

345
00:18:36,717 --> 00:18:38,786
現在の選択範囲の中で―

346
00:18:38,886 --> 00:18:41,688
最も頻繁にたどった経路です

347
00:18:42,089 --> 00:18:45,692
ここで一度に
多くのフレームを操作できます

348
00:18:46,393 --> 00:18:49,463
通常 自分のAPIを探す時に
ここを見ます

349
00:18:49,563 --> 00:18:52,533
驚くほど時間が
かかっている場所

350
00:18:52,633 --> 00:18:57,638
または 多くの分岐点がある場所を
探します

351
00:18:58,238 --> 00:19:03,544
ここにある“IDE Navigator”の
コールを見ましょう

352
00:18:58,238 --> 00:19:03,544
ここにある“IDE Navigator”の
コールを見ましょう

353
00:19:03,710 --> 00:19:05,779
ビューコントローラを
インストールしてあります

354
00:19:05,879 --> 00:19:09,316
これは 私が熟知している
Xcodeの内部APIです

355
00:19:10,184 --> 00:19:14,288
このトレースの
左端の部分を見ると

356
00:19:14,388 --> 00:19:18,358
1.19秒で返していることが
分かります

357
00:19:18,458 --> 00:19:21,862
記録した時間の
45パーセントを占めています

358
00:19:22,062 --> 00:19:26,433
これは 私の予想を
はるかに上回る時間です

359
00:19:27,834 --> 00:19:30,704
その要因を知るのは困難です

360
00:19:30,804 --> 00:19:33,974
この下にすべての経路が
出ていますが

361
00:19:34,107 --> 00:19:37,844
スタックの深さが
30から40はありそうです

362
00:19:37,945 --> 00:19:41,048
ここでどう絞り込むか
見せましょう

363
00:19:41,181 --> 00:19:44,952
最初のやり方は
呼び出し木に戻ります

364
00:19:47,154 --> 00:19:48,789
このポップオーバーを使って

365
00:19:48,922 --> 00:19:50,757
“Flattened Recursion”を
選択します

366
00:19:51,658 --> 00:19:52,893
やってみます

367
00:19:55,229 --> 00:19:58,565
ここにメソッド呼び出しの
繰り返しが見えます

368
00:19:59,299 --> 00:20:01,401
畳み込んでしまいました

369
00:19:59,299 --> 00:20:01,401
畳み込んでしまいました

370
00:20:02,436 --> 00:20:03,604
スクロールします

371
00:20:05,572 --> 00:20:06,607
この部分を見てください

372
00:20:06,707 --> 00:20:10,377
実は IDE Navigator内部の
API呼び出しに―

373
00:20:10,477 --> 00:20:14,081
問題の要因があると
確信しています

374
00:20:14,181 --> 00:20:16,750
呼び出し木全体を
再度フォーカスします

375
00:20:17,117 --> 00:20:18,685
ここをクリックして―

376
00:20:19,152 --> 00:20:21,088
“Focus on Subtree”を
選択します

377
00:20:21,488 --> 00:20:24,725
“Instruments”が
コールグラフのトップに移動して

378
00:20:24,825 --> 00:20:25,959
すべて削除します

379
00:20:26,059 --> 00:20:28,529
パーセンテージを
100パーセントに再設定するので

380
00:20:28,629 --> 00:20:30,497
ここにフォーカスできます

381
00:20:30,731 --> 00:20:33,901
検証を続けましょう

382
00:20:34,067 --> 00:20:36,737
この矢印キーで操作できます

383
00:20:37,037 --> 00:20:38,739
私はこのAPIを熟知しています

384
00:20:38,839 --> 00:20:41,375
ここでは
復元作業をしているようです

385
00:20:41,708 --> 00:20:43,811
さらに展開します

386
00:20:44,778 --> 00:20:47,548
テーブルビューの奥深くです

387
00:20:47,714 --> 00:20:54,221
ここでは 最新のコールパスが
全体の大きな割合を占めています

388
00:20:54,321 --> 00:20:56,823
さらに付随するサンプルもあります

389
00:20:58,492 --> 00:21:00,527
ここにすべて集約されています

390
00:20:58,492 --> 00:21:00,527
ここにすべて集約されています

391
00:21:01,328 --> 00:21:04,364
その１つが
objc messageSendです

392
00:21:04,531 --> 00:21:08,435
これは Objective-Cで
書いていると起こります

393
00:21:08,535 --> 00:21:10,003
Swiftコードでも―

394
00:21:10,104 --> 00:21:12,406
システムライブラリを使っていると
これが起こります

395
00:21:12,506 --> 00:21:14,208
対応する機能も目にします

396
00:21:14,308 --> 00:21:15,509
“objc”や“load strong”

397
00:21:15,609 --> 00:21:17,711
“load weak”や“retain”など

398
00:21:17,811 --> 00:21:21,782
これらを呼び出し木から
すべて取り除くことができます

399
00:21:22,816 --> 00:21:25,485
コンテキストをクリックして
以下を選択します

400
00:21:26,787 --> 00:21:29,122
“Charge libobjc.A.dylib to
callers”

401
00:21:29,256 --> 00:21:33,026
“libobjc”からのサンプルを
すべて拾い取り除くよう―

402
00:21:33,126 --> 00:21:34,795
Instrumentsに命令しています

403
00:21:34,895 --> 00:21:37,965
しかし 親フレームが呼んだ時間は
保持したままです

404
00:21:38,065 --> 00:21:40,601
私はこれらの実行時間を―

405
00:21:40,701 --> 00:21:43,504
Objective-Cを書く時に
必要なものと捉えています

406
00:21:43,604 --> 00:21:46,740
それを最適化することは
ほとんどないので

407
00:21:46,874 --> 00:21:52,212
データから取り除いて
必要な部分にフォーカスしています

408
00:21:53,046 --> 00:21:56,250
フィルタの適用方法を
もう１つ紹介します

409
00:21:56,350 --> 00:22:00,387
それが このセットフレーム間に
生じた―

410
00:21:56,350 --> 00:22:00,387
それが このセットフレーム間に
生じた―

411
00:22:00,487 --> 00:22:02,890
細かいサンプルの削除です

412
00:22:03,590 --> 00:22:05,826
“Call Tree Constraints”の中に
あります

413
00:22:07,060 --> 00:22:08,028
見てください

414
00:22:11,365 --> 00:22:14,301
Instrumentsにこう言います

415
00:22:14,401 --> 00:22:19,072
“トレースの中の20ミリ秒以上の
サンプルが見たい”

416
00:22:19,172 --> 00:22:23,777
すでに２秒間隔は選んだので
20ミリ秒にしました

417
00:22:23,877 --> 00:22:26,380
それは全体の
約１パーセントに当たり―

418
00:22:26,480 --> 00:22:29,516
必要な精度に合致しています

419
00:22:31,552 --> 00:22:33,187
Call Tree Constraintsを
呼んで―

420
00:22:33,887 --> 00:22:36,156
“最低20”と設定します

421
00:22:36,757 --> 00:22:39,793
この部分をさらにフォーカスします

422
00:22:40,360 --> 00:22:43,130
ビューアイテムを展開しています

423
00:22:43,230 --> 00:22:46,366
実際には
NSOutlineViewを呼んで―

424
00:22:46,467 --> 00:22:48,235
アイテムと子を増やしています

425
00:22:48,402 --> 00:22:52,339
多くの人がコールグラフで
立ち止まるかもしれません

426
00:22:52,439 --> 00:22:54,875
システムフレームワークに

427
00:22:54,975 --> 00:22:56,543
多くの時間がかかると
思っています

428
00:22:56,643 --> 00:22:58,712
どうしたらよいでしょう？

429
00:22:58,812 --> 00:23:02,249
NSOutlineViewは
最適化できません

430
00:22:58,812 --> 00:23:02,249
NSOutlineViewは
最適化できません

431
00:23:03,016 --> 00:23:06,019
この状況の打開策があります

432
00:23:06,253 --> 00:23:09,523
システムフレームワークに
時間がかかる理由

433
00:23:10,490 --> 00:23:12,893
それは データ作業を
行っているためです

434
00:23:13,260 --> 00:23:17,831
このメソッドを
何千や何百万回も呼んでいます

435
00:23:18,265 --> 00:23:22,636
あるいは コードを
呼び戻しているかもしれません

436
00:23:22,836 --> 00:23:23,937
重要なのは―

437
00:23:24,037 --> 00:23:27,508
フレームワークの動きを
読むことです

438
00:23:27,608 --> 00:23:29,376
Instrumentsの階層を
展開することで

439
00:23:29,476 --> 00:23:31,979
呼び出している機能が分かるのです

440
00:23:32,079 --> 00:23:35,015
これこそバグ修正の方法です

441
00:23:37,084 --> 00:23:40,187
トレースをアウトラインビューに
展開すると―

442
00:23:40,654 --> 00:23:43,357
２つのメソッドを呼んでいるのが
分かります

443
00:23:44,925 --> 00:23:48,729
“Batch expand items with
item entries expand children”

444
00:23:48,829 --> 00:23:50,998
“Do work after end updates”

445
00:23:51,765 --> 00:23:53,867
これらをまとめることで

446
00:23:53,967 --> 00:23:56,570
効率アップが実現しそうです

447
00:23:56,770 --> 00:23:59,439
ご想像のとおり
アウトラインビューは―

448
00:24:00,007 --> 00:24:01,775
一式のアイテムからスタートします

449
00:24:01,875 --> 00:24:05,779
そして コードの領域で
展開を復元しようとします

450
00:24:05,879 --> 00:24:08,348
例えば
一番上のアイテムを開きます

451
00:24:08,448 --> 00:24:10,350
その指示を出した時―

452
00:24:10,450 --> 00:24:13,487
内部では
他のアイテムを下げているのです

453
00:24:13,954 --> 00:24:15,889
２番目のアイテムを開く時は―

454
00:24:15,989 --> 00:24:17,691
すべてを再度下げています

455
00:24:17,791 --> 00:24:19,293
３番目も同じです

456
00:24:19,393 --> 00:24:20,828
それを行うごとに―

457
00:24:20,928 --> 00:24:24,598
アイテムを何千回も
動かしているのです

458
00:24:25,032 --> 00:24:29,102
パフォーマンスの改善をする上で
まさに取り除きたい―

459
00:24:29,203 --> 00:24:31,104
ムダな作業です

460
00:24:31,405 --> 00:24:34,408
これらのメソッド呼び出しが
バッチを実行している事実から―

461
00:24:34,908 --> 00:24:36,243
こう考えました

462
00:24:36,343 --> 00:24:40,380
“アウトラインビューに大量の
作業を要求できるAPIがある”

463
00:24:40,480 --> 00:24:42,182
コールを呼び出すと―

464
00:24:42,282 --> 00:24:45,352
それがすべての配置を
１度で計算するのです

465
00:24:46,153 --> 00:24:47,955
このようなコールもあります

466
00:24:48,055 --> 00:24:50,224
“更新完了後に作業する”

467
00:24:50,324 --> 00:24:55,028
時々 APIが配列計算する
大量のメソッドを処理します

468
00:24:55,129 --> 00:24:58,932
また別の時には
トランザクションのAPIを提供し

469
00:24:59,032 --> 00:25:00,901
変更を加えようとします

470
00:24:59,032 --> 00:25:00,901
変更を加えようとします

471
00:25:01,001 --> 00:25:03,370
そして それが終わったと伝えると

472
00:25:03,470 --> 00:25:06,807
その変更に対して発生した
すべての計算を行います

473
00:25:06,907 --> 00:25:10,344
すべて１つ１つやるより
効率的です

474
00:25:11,111 --> 00:25:15,649
ここで NSOutlineViewや
NSTableView APIに進み―

475
00:25:15,749 --> 00:25:17,518
いくつかのメソッドを探します

476
00:25:17,618 --> 00:25:19,453
NSTableViewには―

477
00:25:19,553 --> 00:25:22,656
開始と更新の完了のための
複数のメソッドがあります

478
00:25:22,756 --> 00:25:26,860
これはテーブルビューを統合し
作業を効率化します

479
00:25:27,427 --> 00:25:29,963
Xcode 10に搭載しています

480
00:25:30,130 --> 00:25:31,198
お見せしましょう

481
00:25:33,167 --> 00:25:34,735
Xcode 10を起動します

482
00:25:38,071 --> 00:25:40,107
アプリケーションとして
ソースを開きます

483
00:25:42,676 --> 00:25:44,444
タブを作成します

484
00:25:44,678 --> 00:25:46,947
先ほどのような点滅はなく―

485
00:25:47,047 --> 00:25:49,049
タブがすぐに開きます

486
00:25:49,383 --> 00:25:50,050
さて―

487
00:25:51,351 --> 00:25:53,821
もっと早く開きたいと思います

488
00:25:54,521 --> 00:25:56,256
どうしたらよいでしょう？

489
00:25:56,490 --> 00:26:03,130
幸運にもトレースを検証していて
サンプルの半分を占める―

490
00:25:56,490 --> 00:26:03,130
幸運にもトレースを検証していて
サンプルの半分を占める―

491
00:26:03,230 --> 00:26:06,433
明らかな問題を見つけることが
できました

492
00:26:07,601 --> 00:26:11,138
こんな大きな手掛かりは
めったに見つかりません

493
00:26:11,572 --> 00:26:13,340
通常しなければならないことは

494
00:26:13,674 --> 00:26:16,877
フィルタを使った
サンプル全体の調査です

495
00:26:17,044 --> 00:26:20,547
そして全体の１パーセントの
処理について調べます

496
00:26:20,647 --> 00:26:23,016
そうやって
１つ１つの原因を探して―

497
00:26:23,116 --> 00:26:26,920
ほんの少し速くする解決法を
見つけるのです

498
00:26:27,955 --> 00:26:31,725
それを紙切れか
テキストに書き出して―

499
00:26:31,925 --> 00:26:35,495
解決する順番を決めていきます

500
00:26:35,596 --> 00:26:38,065
時々 ５番目の修正が―

501
00:26:38,165 --> 00:26:41,568
２番目の問題に
役立つこともあります

502
00:26:41,768 --> 00:26:45,072
余計な仕事をして
作業の順番を変えるのは

503
00:26:45,172 --> 00:26:48,408
本末転倒で気分が悪いものです

504
00:26:48,642 --> 00:26:51,912
しかし
すべてを予測するのは困難です

505
00:26:52,012 --> 00:26:54,615
作業が終わるまで分かりません

506
00:26:54,715 --> 00:26:58,919
まず始めてみることです

507
00:26:59,019 --> 00:27:01,522
３パーセントの改善を
10回積み重ねることが

508
00:26:59,019 --> 00:27:01,522
３パーセントの改善を
10回積み重ねることが

509
00:27:01,622 --> 00:27:04,525
２番目の30パーセントの改善に
つながります

510
00:27:05,626 --> 00:27:06,460
いいですね？

511
00:27:07,227 --> 00:27:11,665
では スライドに戻ります

512
00:27:11,899 --> 00:27:16,236
継続的な改善に役立つ
テクニックを紹介します

513
00:27:21,241 --> 00:27:23,510
最も頻繁に起こる問題は―

514
00:27:23,610 --> 00:27:26,280
アウトラインビューと
同じテクニックを使っています

515
00:27:26,380 --> 00:27:28,148
“バッチ”と“延期”です

516
00:27:28,248 --> 00:27:32,085
APIが呼ばれた時に
副作用が起こると―

517
00:27:32,186 --> 00:27:34,354
APIをループする
コードを受け取ります

518
00:27:34,454 --> 00:27:37,224
要求された最初の命令を実行して

519
00:27:37,324 --> 00:27:38,892
副作用が起こったのです

520
00:27:39,126 --> 00:27:42,196
副作用の結果を
誰も理解していなければ

521
00:27:42,296 --> 00:27:45,199
その仕事を何度も繰り返します

522
00:27:45,632 --> 00:27:48,068
もっと効率的なインターフェイスを
得られます

523
00:27:48,168 --> 00:27:51,104
クライアントが提供する
配列やコレクションの―

524
00:27:51,538 --> 00:27:53,807
バッチインターフェイスを
使用するのです

525
00:27:53,907 --> 00:27:56,276
それで副作用の計算が
１度で完了します

526
00:27:57,077 --> 00:27:59,346
クライアントが
複数の場合もあります

527
00:27:59,446 --> 00:28:04,618
一括にまとめることができず
作業を延期しているため

528
00:27:59,446 --> 00:28:04,618
一括にまとめることができず
作業を延期しているため

529
00:28:04,718 --> 00:28:07,054
まだ 性能が同じ状態です

530
00:28:09,389 --> 00:28:13,327
３つ目はInstrumentsの
トレースを調べて―

531
00:28:13,694 --> 00:28:17,865
同じ計算を何度もしている領域を
見つけることです

532
00:28:18,165 --> 00:28:21,502
例えば テキストサイズを計算する
メソッドがあります

533
00:28:21,602 --> 00:28:23,337
そして その数フレーム後―

534
00:28:23,437 --> 00:28:27,241
同じ計算を何度もしている部分が
あったとします

535
00:28:27,341 --> 00:28:31,311
このような場合は
１回で計算したいはずです

536
00:28:31,979 --> 00:28:35,015
最上位で計算し
下位に渡すかキャッシュします

537
00:28:36,683 --> 00:28:39,987
UIアプリケーションにおける
もう１つのテクニックは

538
00:28:40,287 --> 00:28:43,490
UI表示に使用するビュー数を
考えることです

539
00:28:43,824 --> 00:28:45,659
ビュー数が少ないことは

540
00:28:45,893 --> 00:28:49,263
ソースコードの構造において
大変有効です

541
00:28:49,363 --> 00:28:53,300
小さな機能のセットを
大きな塊に組み立てるのです

542
00:28:53,400 --> 00:28:54,935
ビューが増えると―

543
00:28:55,035 --> 00:28:58,705
表示やレイアウトのシステムへの
負担がその分重くなります

544
00:28:59,206 --> 00:29:01,141
双方向の関係性です

545
00:28:59,206 --> 00:29:01,141
双方向の関係性です

546
00:29:01,241 --> 00:29:04,578
ビューが少なければ
より細かいキャッシュが得られ―

547
00:29:04,678 --> 00:29:06,513
パフォーマンスも向上します

548
00:29:07,181 --> 00:29:10,250
通常はビューの数を調整できます

549
00:29:10,350 --> 00:29:12,886
パフォーマンスに
大きな影響を与えるためです

550
00:29:12,986 --> 00:29:15,522
ビューが少ないことが
常にベストではありません

551
00:29:15,622 --> 00:29:19,459
さもないと 巨大なビュー１つで
すべてをやることになります

552
00:29:21,161 --> 00:29:23,197
もう１つ よく使うテクニックに

553
00:29:23,297 --> 00:29:25,132
“ダイレクトオブザベーション”が
あります

554
00:29:25,265 --> 00:29:27,768
ソースコードの２つの領域が

555
00:29:27,868 --> 00:29:30,104
緩やかに連動していることが
よくあります

556
00:29:30,204 --> 00:29:32,406
一方が他方を分かっていて―

557
00:29:32,506 --> 00:29:36,276
間接的な方法によって
互いに交信しているのです

558
00:29:36,376 --> 00:29:39,379
使用しているのは
NSNotificationCenter

559
00:29:39,580 --> 00:29:41,315
あとは ブロック単位の
コールバック

560
00:29:41,415 --> 00:29:43,884
“委譲”や“キー値監視”です

561
00:29:44,918 --> 00:29:48,322
いくつかのモデルコードを
目にすることがあります

562
00:29:48,422 --> 00:29:52,092
ループに入って変更されるたびに
そのループに入っていき―

563
00:29:52,192 --> 00:29:55,195
“KVO Notifications”を
数多く出しています

564
00:29:55,295 --> 00:29:57,431
もちろん直接は見えません

565
00:29:57,531 --> 00:29:59,299
しかし コントローラの中では

566
00:29:59,399 --> 00:30:02,870
モデルコードの変更に
必死に応答しているのです

567
00:29:59,399 --> 00:30:02,870
モデルコードの変更に
必死に応答しているのです

568
00:30:02,970 --> 00:30:05,505
これに CPUが多くの時間を
費やしていて

569
00:30:05,606 --> 00:30:09,042
変更全体で考えた時に
不要な処理となっているのです

570
00:30:09,443 --> 00:30:13,480
これが モデルコードからの
呼び出しだったら？

571
00:30:13,580 --> 00:30:15,983
通知や委譲を経由していたり―

572
00:30:16,083 --> 00:30:17,684
手動のブロックベース
コールバックだったら？

573
00:30:17,785 --> 00:30:21,221
何が起こっているかが
ずっと明らかです

574
00:30:21,321 --> 00:30:23,657
そして適切な処理をするでしょう

575
00:30:23,757 --> 00:30:28,161
いくつかの通知を
ループの中から外に出して―

576
00:30:28,262 --> 00:30:29,963
パフォーマンス向上を図るのです

577
00:30:30,430 --> 00:30:32,833
コントローラサイドの
やり方もあります

578
00:30:32,933 --> 00:30:36,203
ここでは 延期とバッチの
テクニックを使って

579
00:30:36,303 --> 00:30:39,606
ムダな仕事を省いて
同期応答を回避できます

580
00:30:40,874 --> 00:30:42,509
最後は簡単です

581
00:30:42,709 --> 00:30:46,413
コードが
すでに適切に動いていれば―

582
00:30:46,513 --> 00:30:49,183
すでにリニアということで
理想的です

583
00:30:49,283 --> 00:30:53,020
ある意味 パフォーマンスの
向上の余地も限られます

584
00:30:53,520 --> 00:30:56,290
その場合は
定期的な改善を続けることです

585
00:30:57,157 --> 00:31:00,994
オブジェクト指向の
ディクショナリを使っているなら

586
00:30:57,157 --> 00:31:00,994
オブジェクト指向の
ディクショナリを使っているなら

587
00:31:01,094 --> 00:31:02,896
お気付きでしょう

588
00:31:03,063 --> 00:31:05,833
すべてのキーに
大量の文字列定数があるなら

589
00:31:05,933 --> 00:31:07,301
大きな改善が可能です

590
00:31:07,401 --> 00:31:09,903
コードの明瞭化や補完

591
00:31:10,003 --> 00:31:11,138
リファクタリング

592
00:31:11,238 --> 00:31:14,875
特定の型を使った
ソースコードの検証

593
00:31:14,975 --> 00:31:17,244
structを使うのが
一番簡単でしょう

594
00:31:17,344 --> 00:31:21,181
暗黙のイニシャライザや
ハッシュ値との適合も使えます

595
00:31:21,281 --> 00:31:24,618
これでソースコードが改善します

596
00:31:24,718 --> 00:31:28,889
文字列ハッシュや文字列方程式に
費やしていた時間に―

597
00:31:28,989 --> 00:31:30,390
驚くことでしょう

598
00:31:30,490 --> 00:31:33,660
すべては
小さな改善の積み重ねです

599
00:31:34,561 --> 00:31:36,730
次はマシューに引き継ぎます

600
00:31:36,830 --> 00:31:38,866
これらのテクニックの―

601
00:31:38,966 --> 00:31:41,034
写真 Appへの
適用方法を紹介します

602
00:31:42,536 --> 00:31:48,242
(拍手)

603
00:31:48,375 --> 00:31:49,776
ありがとう

604
00:31:49,877 --> 00:31:50,677
こんにちは

605
00:31:50,777 --> 00:31:54,781
私はマシュー･ルーカス
写真チームのエンジニアです

606
00:31:54,915 --> 00:31:58,352
今日は 写真 Appの
パフォーマンスに関する―

607
00:31:58,452 --> 00:32:00,654
実例をいくつか紹介します

608
00:31:58,452 --> 00:32:00,654
実例をいくつか紹介します

609
00:32:01,255 --> 00:32:03,891
まず 写真 Appについて
少し話します

610
00:32:04,024 --> 00:32:05,826
よくご存知の
アプリケーションですね

611
00:32:05,926 --> 00:32:10,164
お気に入りの瞬間を
保存して閲覧できます

612
00:32:10,397 --> 00:32:13,500
この“モーメント”から閲覧します

613
00:32:13,600 --> 00:32:15,903
今見ているのがデフォルトです

614
00:32:16,136 --> 00:32:20,374
それ以外に“コレクション”
“年別”の表示もあります

615
00:32:21,008 --> 00:32:23,110
後ほど説明します

616
00:32:23,343 --> 00:32:26,914
ライブラリには 1000枚から
10万枚の写真が保存できます

617
00:32:27,347 --> 00:32:31,051
どれほど写真が好きかで変わります

618
00:32:31,251 --> 00:32:35,389
私たちは毎日の楽しい瞬間を
記録するのが大好きです

619
00:32:36,256 --> 00:32:38,125
記録することには寛容な一方―

620
00:32:38,225 --> 00:32:41,061
こんな画面は我慢できません

621
00:32:41,161 --> 00:32:42,963
アプリケーションを起動して―

622
00:32:43,063 --> 00:32:46,366
このような画面が出たら
どう思いますか？

623
00:32:47,267 --> 00:32:49,736
このような画面を
目にすることもあるでしょう

624
00:32:50,337 --> 00:32:52,339
多数のプレースホルダが
表示されていますが―

625
00:32:52,439 --> 00:32:54,041
問題があります

626
00:32:54,141 --> 00:32:58,145
スクロールしていると
このようにグレーになり―

627
00:32:58,245 --> 00:33:00,080
サムネイルがロードを始めます

628
00:32:58,245 --> 00:33:00,080
サムネイルがロードを始めます

629
00:33:00,180 --> 00:33:02,716
スクロールを続けると
フレーム落ちしてしまいます

630
00:33:02,816 --> 00:33:04,585
ビューが更新されているからです

631
00:33:05,452 --> 00:33:08,055
目標はこのような表示を
なくすことです

632
00:33:08,589 --> 00:33:11,425
望ましいユーザ体験ではありません

633
00:33:11,758 --> 00:33:14,361
避けられない場合もありますが

634
00:33:14,461 --> 00:33:17,064
頻繁に起こるのは困ります

635
00:33:18,432 --> 00:33:22,703
アプリケーションにとって
反応の速さは重要です

636
00:33:23,470 --> 00:33:27,007
アニメーションが
スムーズなことも大切です

637
00:33:28,876 --> 00:33:33,013
この２つは
ユーザ体験の基本です

638
00:33:33,347 --> 00:33:36,950
ユーザがアプリケーションに
信頼が持てなければ

639
00:33:37,050 --> 00:33:38,685
使用をやめるかもしれません

640
00:33:39,419 --> 00:33:41,422
この２つ問題について

641
00:33:41,588 --> 00:33:43,924
２つの事例をご紹介します

642
00:33:44,057 --> 00:33:48,395
最初が モーメントを
立ち上げる時の最適化

643
00:33:48,762 --> 00:33:51,932
次が コレクションと年別の
スクロールを―

644
00:33:52,032 --> 00:33:54,201
スムーズにする方法です

645
00:33:56,937 --> 00:34:00,407
最初に モーメントを起動します

646
00:33:56,937 --> 00:34:00,407
最初に モーメントを起動します

647
00:34:02,643 --> 00:34:05,779
起動には３種類あります

648
00:34:06,580 --> 00:34:09,716
最も時間がかかるのが
“コールド”と呼ばれるもの

649
00:34:09,817 --> 00:34:13,587
リブート後にアプリケーションを
再起動させます

650
00:34:14,188 --> 00:34:16,389
キャッシュに
何も保存されていません

651
00:34:16,489 --> 00:34:18,492
そのため バックグラウンドで
プロセスが走ったり―

652
00:34:18,592 --> 00:34:20,360
ライブラリのロードが
必要かもしれません

653
00:34:21,027 --> 00:34:23,530
また システムがメモリ不足で

654
00:34:23,630 --> 00:34:27,501
メモリの再要求をしている時にも
起こります

655
00:34:29,168 --> 00:34:32,773
アプリケーションを中止しても
コールドにはなりません

656
00:34:32,873 --> 00:34:36,409
リソースがページアウトされる時を
システムが決めるからです

657
00:34:38,411 --> 00:34:42,315
アプリケーションを中止して
数秒後に再度立ち上げると

658
00:34:42,416 --> 00:34:45,886
問題なく速やかに起動します

659
00:34:45,985 --> 00:34:47,454
これが“ウォーム”です

660
00:34:47,554 --> 00:34:51,625
リソースが すでにキャッシュに
保存されているので

661
00:34:51,824 --> 00:34:53,327
早く立ち上がります

662
00:34:54,395 --> 00:34:56,730
最後が“ホット”と
呼ばれるもので―

663
00:34:56,830 --> 00:34:59,833
基本的にレジュームを指します

664
00:34:59,933 --> 00:35:03,904
起動しているアプリケーションを
復帰させる状態です

665
00:34:59,933 --> 00:35:03,904
起動しているアプリケーションを
復帰させる状態です

666
00:35:04,905 --> 00:35:06,874
起動の評価をする場合は

667
00:35:06,974 --> 00:35:09,309
ウォームから始めます

668
00:35:09,409 --> 00:35:14,781
ウォームからの起動時間は
コールドに比べて―

669
00:35:15,349 --> 00:35:17,151
変動が少なくなります

670
00:35:17,251 --> 00:35:20,988
デバイスのリブートが不要で
テストのイテレーションも高速です

671
00:35:21,755 --> 00:35:26,627
起動の評価はアプリケーションの
アイコンを押してから

672
00:35:26,727 --> 00:35:30,230
やりとりを始めるまでの
所要時間を測定します

673
00:35:30,898 --> 00:35:32,833
ここで言う“やりとり”は

674
00:35:32,933 --> 00:35:36,069
実際にアプリケーションを
使い始めることです

675
00:35:37,371 --> 00:35:41,441
通常 立ち上がってすぐは
スピナーが表示され―

676
00:35:41,542 --> 00:35:45,612
アプリケーションが使えないので
その時間は省きます

677
00:35:47,314 --> 00:35:50,250
ここでは３つの目標があります

678
00:35:50,584 --> 00:35:53,420
最初の目標は“瞬時”です

679
00:35:53,921 --> 00:35:58,792
スピナーやプレースホルダも
表示したくありません

680
00:36:01,195 --> 00:36:02,830
灰色のサムネイルも同様です

681
00:36:03,230 --> 00:36:04,965
正直に言うと―

682
00:36:05,332 --> 00:36:08,802
初めて iCloudに同期する時は
プレースホルダが現れます

683
00:36:08,902 --> 00:36:12,439
でも データがローカルにある時は
表示しないようにしています

684
00:36:13,874 --> 00:36:15,742
さて“瞬時”とは何でしょう？

685
00:36:16,310 --> 00:36:17,811
起動までの時間は―

686
00:36:17,911 --> 00:36:20,881
ズームアニメーションの表示と
同時でなくてはいけません

687
00:36:20,981 --> 00:36:23,951
通常 500から600ミリ秒の間です

688
00:36:24,051 --> 00:36:29,022
それならホーム画面から
アプリケーションへの移行が円滑で

689
00:36:29,123 --> 00:36:33,060
アニメーションが終わり次第
使い始めることができます

690
00:36:33,727 --> 00:36:36,396
これは写真 Appに限らず―

691
00:36:36,497 --> 00:36:39,032
どんなアプリケーションでも
有効です

692
00:36:40,234 --> 00:36:42,569
次に 写真 Appの起動方法です

693
00:36:43,337 --> 00:36:46,106
より詳しく見ると
アニメーションが終わる前に

694
00:36:46,206 --> 00:36:50,844
写真がすべて配置されるのが
分かります

695
00:36:53,414 --> 00:36:55,949
起動分析を見ると―

696
00:36:56,049 --> 00:36:58,585
大きく２つのパートに分かれます

697
00:36:58,685 --> 00:37:00,988
最初のパートは“dyld”です

698
00:36:58,685 --> 00:37:00,988
最初のパートは“dyld”です

699
00:37:01,088 --> 00:37:05,058
必要なすべてのライブラリの
読み込みをするローダで

700
00:37:05,192 --> 00:37:08,095
staticイニシャライザも作動します

701
00:37:08,662 --> 00:37:12,266
このパートの制御は限定的ですが
不可能ではありません

702
00:37:12,833 --> 00:37:17,771
詳しくは 昨年のdyldに関する
セッションをご覧ください

703
00:37:19,773 --> 00:37:22,276
理解を深めるのに役立ちます

704
00:37:23,477 --> 00:37:26,813
dyldはオブジェクトテーブルの
mainを呼び出し―

705
00:37:26,947 --> 00:37:30,951
多くの制御が可能な
２番目のパートに移ります

706
00:37:31,218 --> 00:37:35,389
このパートは
500ミリ秒未満となります

707
00:37:35,856 --> 00:37:40,060
“didFinishLaunching”のあとの
“First layout”が

708
00:37:40,160 --> 00:37:41,829
起動終了のサインになります

709
00:37:41,929 --> 00:37:44,164
これがアプリケーションが使える
時間です

710
00:37:46,199 --> 00:37:50,003
このセッションで伝えたい
いくつかの原則があります

711
00:37:50,104 --> 00:37:54,274
それらは パフォーマンス改善の
共通の柱となります

712
00:37:55,042 --> 00:37:57,878
１つ目は“怠け者”になる

713
00:37:57,978 --> 00:38:00,480
必要のない仕事は延期します

714
00:37:57,978 --> 00:38:00,480
必要のない仕事は延期します

715
00:38:01,281 --> 00:38:03,684
２番目は“先回り”する

716
00:38:03,917 --> 00:38:06,253
これは２つの意味で有効です

717
00:38:06,520 --> 00:38:11,325
まずは
“後回しする作業を予測する”

718
00:38:11,658 --> 00:38:14,895
次に“リグレッションを
いち早く見つける”

719
00:38:14,995 --> 00:38:18,999
インテグレーションテストの
継続的な実施が重要です

720
00:38:21,635 --> 00:38:23,804
最後は“一定”

721
00:38:23,904 --> 00:38:26,940
ロードするデータ量に
関わらずです

722
00:38:29,710 --> 00:38:32,079
アプローチ方法を間違えて―

723
00:38:32,179 --> 00:38:34,448
起動に必要な
すべてをロードするとします

724
00:38:34,548 --> 00:38:38,885
それは ３万アイテムにも
及ぶことになります

725
00:38:39,953 --> 00:38:41,889
まず データベースを初期化して

726
00:38:41,989 --> 00:38:44,157
ビューコントローラを用意します

727
00:38:44,258 --> 00:38:46,260
そして データソースを構成し―

728
00:38:46,360 --> 00:38:49,429
ライブラリ画像をロードして
クラウドのステータスを定義します

729
00:38:50,931 --> 00:38:54,101
これはデータの増え方によって
変わります

730
00:38:54,201 --> 00:38:56,503
ユーザは日々写真を撮っているので

731
00:38:56,603 --> 00:38:59,039
データは永遠に増え続けます

732
00:38:59,940 --> 00:39:04,111
私たちが扱っている写真は
結び付きのないデータの塊です

733
00:38:59,940 --> 00:39:04,111
私たちが扱っている写真は
結び付きのないデータの塊です

734
00:39:05,646 --> 00:39:09,016
次に各ステップを
最適化する方法を紹介し―

735
00:39:09,116 --> 00:39:11,385
データベースを初期設定します

736
00:39:13,520 --> 00:39:16,290
通常 最初のクエリが
要求された時に―

737
00:39:16,390 --> 00:39:18,458
データベースが
初期化されてロードされます

738
00:39:18,625 --> 00:39:23,530
バックグラウンドスレッドでは
即座に最適化が行われます

739
00:39:23,730 --> 00:39:26,033
そのため
クエリの要求が完了した時―

740
00:39:26,133 --> 00:39:28,068
初期化は必要ありません

741
00:39:28,936 --> 00:39:30,738
これは 最初のクエリが―

742
00:39:30,838 --> 00:39:33,374
メインスレッドから
行われた場合のことです

743
00:39:34,708 --> 00:39:38,645
私たちは
多くの時間を費やして―

744
00:39:39,413 --> 00:39:43,384
起動の時に
すべてのクエリを見ています

745
00:39:43,550 --> 00:39:46,019
今している作業が必要なことか

746
00:39:46,120 --> 00:39:49,590
ムダがないか確認してください

747
00:39:53,494 --> 00:39:56,196
最後に確認したいのは

748
00:39:56,296 --> 00:39:59,399
すべてのクエリが
最大限に効率化されているか

749
00:39:59,500 --> 00:40:03,570
そして 複雑なクエリが
極力回避されているかです

750
00:39:59,500 --> 00:40:03,570
そして 複雑なクエリが
極力回避されているかです

751
00:40:05,506 --> 00:40:09,276
有効な方法として
インデックスを作成し―

752
00:40:09,376 --> 00:40:12,479
スピードアップを
図ることができます

753
00:40:15,582 --> 00:40:20,654
これで初期設定の時間は
最大30ミリ秒に短縮できます

754
00:40:21,188 --> 00:40:24,157
次に ビューコントローラの
起動設定に移ります

755
00:40:25,025 --> 00:40:28,795
主要な機能として
４つのタブがあります

756
00:40:29,630 --> 00:40:32,332
最初に注意すべき点です

757
00:40:32,432 --> 00:40:34,535
これら３つの不可視ビューに
おいて―

758
00:40:34,635 --> 00:40:37,771
初期設定時の作業を
最小限にしたいです

759
00:40:38,672 --> 00:40:40,908
ここでのルールは―

760
00:40:41,008 --> 00:40:44,077
イニシャライザの作業を
最小化することです

761
00:40:44,278 --> 00:40:48,649
必要最小限にした上で
ビューの全データを記録します

762
00:40:50,384 --> 00:40:55,556
さらに コントローラの初期化も
一定時間の中で行います

763
00:40:58,392 --> 00:41:02,663
最後に可視ビューだけが
ロードされたことを確認します

764
00:40:58,392 --> 00:41:02,663
最後に可視ビューだけが
ロードされたことを確認します

765
00:41:02,796 --> 00:41:07,034
この部分で
退行することがよくあるので

766
00:41:07,134 --> 00:41:09,436
十分な注意が必要です

767
00:41:11,939 --> 00:41:16,110
ビューコントローラの起動目標は
120ミリ秒です

768
00:41:16,877 --> 00:41:20,547
しかし ここで
データソースの設計を行うので

769
00:41:20,647 --> 00:41:22,382
そのチャンクを見ていきます

770
00:41:25,586 --> 00:41:29,189
モーメントには
人生の出来事が記録されています

771
00:41:29,389 --> 00:41:33,594
UIはそれをグループに分類して
表示しています

772
00:41:34,094 --> 00:41:38,098
例えば このライブラリには
500モーメントくらいあり―

773
00:41:38,198 --> 00:41:41,735
ビューを作成するため
事前にそれらの読み込みが必要です

774
00:41:43,670 --> 00:41:46,206
モーメントに本当に必要なのは

775
00:41:46,306 --> 00:41:49,309
ビューを作成するための
メタデータだけです

776
00:41:49,576 --> 00:41:50,978
コンテンツは不要です

777
00:41:51,245 --> 00:41:53,580
そこで最初に行うのは

778
00:41:53,680 --> 00:41:57,184
超高速なクエリを投げることです

779
00:41:57,618 --> 00:42:01,521
次に 必要なコンテンツだけを
読み込みます

780
00:41:57,618 --> 00:42:01,521
次に 必要なコンテンツだけを
読み込みます

781
00:42:02,189 --> 00:42:05,859
この場合 可視コンテンツだけを
ロードします

782
00:42:05,959 --> 00:42:09,863
このケースでは
７から10までのモーメントです

783
00:42:10,898 --> 00:42:13,767
不足分は限られているので―

784
00:42:13,867 --> 00:42:17,137
メインスレッドで
同期することができます

785
00:42:18,605 --> 00:42:22,943
さらに 残りのデータを
同期してロードできるように

786
00:42:23,043 --> 00:42:26,847
作業の予測と計画を
立てたいと思います

787
00:42:27,214 --> 00:42:29,650
バックグラウンドスレッドで
行い―

788
00:42:29,750 --> 00:42:34,154
メインスレッドの動作に
影響を与えないようにします

789
00:42:38,659 --> 00:42:41,729
ここでの目標は100ミリ秒です

790
00:42:44,731 --> 00:42:46,767
そして 最後に―

791
00:42:47,034 --> 00:42:49,837
データソースが画像を提供します

792
00:42:49,937 --> 00:42:52,206
このパートを最適化しましょう

793
00:42:53,574 --> 00:42:56,677
ここは飛びぬけて
大きなチャンクだったので

794
00:42:56,944 --> 00:43:01,648
画像のロードに
多くの時間を要していました

795
00:42:56,944 --> 00:43:01,648
画像のロードに
多くの時間を要していました

796
00:43:01,749 --> 00:43:04,952
ここでの作業が多すぎるようです

797
00:43:05,052 --> 00:43:07,121
まず最初に―

798
00:43:07,488 --> 00:43:11,125
起動時に必要な
画像数の検討を行います

799
00:43:11,425 --> 00:43:14,161
そして それだけを
最初にロードします

800
00:43:15,796 --> 00:43:20,200
この場合
最大60枚くらいになりそうです

801
00:43:21,769 --> 00:43:24,338
次に それらを
最初にロードするため―

802
00:43:24,438 --> 00:43:28,375
低解像度の画像だけ
読み込む必要があります

803
00:43:28,709 --> 00:43:32,913
ピクセル数が小さい画像の方が
ずっと効率的です

804
00:43:35,215 --> 00:43:37,951
今 このチャンクは
200ミリ秒になっています

805
00:43:39,520 --> 00:43:41,989
以前に比べると大きな進歩です

806
00:43:42,189 --> 00:43:46,060
この時間を維持できれば
すばらしいことです

807
00:43:47,694 --> 00:43:50,164
時々 こう自問自答してください

808
00:43:50,264 --> 00:43:52,099
“これは起動時に必要なことか？”

809
00:43:52,199 --> 00:43:55,302
ここで挙げる例はフッタビューです

810
00:43:55,436 --> 00:43:58,872
ネットワークやデータベースから
情報を引き出し―

811
00:44:00,007 --> 00:44:03,911
起動時にデザインを
表示しないようにします

812
00:44:04,011 --> 00:44:09,149
可能な限り表示しようとした
画像の優先順位を決めるためです

813
00:44:09,249 --> 00:44:10,450
これで単純化されます

814
00:44:11,351 --> 00:44:13,887
起動後の作業予定を立て―

815
00:44:13,987 --> 00:44:19,126
あとで呼び出すプロセス情報を
キャッシュに格納します

816
00:44:20,594 --> 00:44:23,697
この情報の表示要求を
受け取っていたとしたら？

817
00:44:23,797 --> 00:44:28,802
Background App Refresh APIを
UIKitから利用できるでしょう

818
00:44:28,936 --> 00:44:30,938
アプリケーションがクリアされて

819
00:44:31,038 --> 00:44:35,142
起動時に コンテンツを
立ち上げることができます

820
00:44:37,444 --> 00:44:42,416
その部分が消えて CPUの時間が
400ミリ秒節約できました

821
00:44:43,384 --> 00:44:46,253
この内訳を見ると―

822
00:44:46,353 --> 00:44:50,657
ここまで 450ミリ秒しか
使ってないことが分かります

823
00:44:52,159 --> 00:44:55,762
これを 500ミリ秒の
タイムウインドウに収めていきます

824
00:44:55,863 --> 00:44:59,299
ここでは
表示の仕方に関わらず―

825
00:44:59,399 --> 00:45:04,972
コンテンツの準備時間を
考えることが最も重要です

826
00:44:59,399 --> 00:45:04,972
コンテンツの準備時間を
考えることが最も重要です

827
00:45:05,472 --> 00:45:08,742
つまり それを測定することです

828
00:45:10,510 --> 00:45:13,547
ロードするデータ量に関係なく―

829
00:45:13,647 --> 00:45:16,283
一定時間で
処理しなければなりません

830
00:45:16,583 --> 00:45:20,721
関連性のないデータですが
一定を保つ必要があります

831
00:45:24,658 --> 00:45:27,528
アプリケーションを立ち上げて
使い始めます

832
00:45:27,628 --> 00:45:31,632
コレクションと年別の
整理方法を紹介します

833
00:45:32,733 --> 00:45:39,339
ユーザはモーメントから
コレクション 年別まで

834
00:45:39,439 --> 00:45:41,942
アニメーションで
シームレスに移動できます

835
00:45:44,511 --> 00:45:46,647
これは複雑な階層です

836
00:45:46,847 --> 00:45:49,183
写真が何千枚も表示されています

837
00:45:49,516 --> 00:45:51,518
この階層を行き来しながら―

838
00:45:51,618 --> 00:45:57,724
最新更新やアニメーション
ジェスチャまでサポートします

839
00:46:00,360 --> 00:46:02,429
ここでも目標があります

840
00:46:02,930 --> 00:46:05,732
ユーザ体験に関する目標です

841
00:46:06,300 --> 00:46:07,935
１つ目は前と同じで―

842
00:46:08,035 --> 00:46:11,705
“スピナーやプレースホルダを
表示しない”

843
00:46:11,805 --> 00:46:13,841
さらに
“スムーズなアニメーション”

844
00:46:13,941 --> 00:46:15,709
ここで言う“スムーズ”とは―

845
00:46:15,809 --> 00:46:21,381
スクリーンに応じて
60fpsや120fpsを指します

846
00:46:23,183 --> 00:46:27,387
先ほどの原則が
ここでも当てはまります

847
00:46:27,488 --> 00:46:30,490
“怠け者”になって
必要のない仕事は延期する

848
00:46:30,657 --> 00:46:33,360
“先回り”して
リグレッションを早く見つける

849
00:46:34,094 --> 00:46:37,297
そして レイアウトパスで
“一定”を保つ

850
00:46:37,397 --> 00:46:40,067
ロードするデータ量に
関わらずです

851
00:46:41,435 --> 00:46:43,704
ここでは“タイムリー”な―

852
00:46:43,804 --> 00:46:46,473
レンダリングの
ループサイクルも大切です

853
00:46:46,974 --> 00:46:49,376
忘れないでください

854
00:46:49,476 --> 00:46:52,913
フレームの描画時間は
８か16ミリ秒しかありません

855
00:46:53,013 --> 00:46:57,551
そのタイミングを逃したら
フレーム落ちしてしまうのです

856
00:46:59,253 --> 00:47:03,524
ここで達成したいことを
見ていきましょう

857
00:46:59,253 --> 00:47:03,524
ここで達成したいことを
見ていきましょう

858
00:47:03,724 --> 00:47:07,895
セクションの中に小さなセルのある
このビューを見てください

859
00:47:09,897 --> 00:47:13,400
“UICollectionView”の画面です

860
00:47:13,500 --> 00:47:15,269
極端な例を除いて―

861
00:47:15,369 --> 00:47:18,939
通常のアプローチで
可能な限度を制限しています

862
00:47:19,173 --> 00:47:22,109
ビューとレイヤが
増えすぎたからです

863
00:47:24,011 --> 00:47:27,214
さらにレイヤの複雑性が増し―

864
00:47:27,314 --> 00:47:30,484
多くのメモリが必要になりました

865
00:47:31,652 --> 00:47:33,454
イノベーションが必要でした

866
00:47:33,720 --> 00:47:36,290
そこで コレクションビューを
使いながら―

867
00:47:36,390 --> 00:47:38,358
ビューの数を
制限することにしました

868
00:47:40,694 --> 00:47:44,898
ビデオゲームでよく使われる
“atlasing”を使いました

869
00:47:45,132 --> 00:47:49,670
簡単に言うと 画像一式を
１つに結合するテクニックです

870
00:47:50,504 --> 00:47:54,741
まず 小さなサムネイルで
それを効率的に使い―

871
00:47:54,908 --> 00:47:57,277
次に デザインカンバスに―

872
00:47:57,377 --> 00:48:00,047
すべてのRaw画像データを
スタンプします

873
00:47:57,377 --> 00:48:00,047
すべてのRaw画像データを
スタンプします

874
00:48:01,081 --> 00:48:02,983
Raw画像データを使用しているので

875
00:48:03,083 --> 00:48:06,220
それぞれのサムネイルの
デコードを省けます

876
00:48:08,288 --> 00:48:11,191
基本的にランダムな画像列を
表示しています

877
00:48:12,326 --> 00:48:14,695
生成とキャッシュが
オンザフライなので―

878
00:48:14,795 --> 00:48:16,463
より柔軟です

879
00:48:18,365 --> 00:48:21,401
複数の画像を
１つにまとめて表示するので

880
00:48:21,702 --> 00:48:24,538
セル レイヤ オブジェクトの数が
大幅に減ります

881
00:48:24,638 --> 00:48:27,741
レイアウトが簡素化され
時間も短縮します

882
00:48:29,543 --> 00:48:33,580
それと交換に
考えるべきことがあります

883
00:48:33,747 --> 00:48:35,315
これがその１つです

884
00:48:36,817 --> 00:48:41,655
ここにある画像を“長押し”や
“早押し”した場合―

885
00:48:41,822 --> 00:48:45,726
その場所を特定して
正確に表示する必要があります

886
00:48:46,860 --> 00:48:48,962
そのため
１つの画像を表示する時ー

887
00:48:49,897 --> 00:48:55,102
個々の画像と表示列の位置を
維持する必要があります

888
00:48:55,969 --> 00:48:58,972
これらをオンザフライで
生成するのはなぜでしょう？

889
00:49:00,440 --> 00:49:04,044
最新情報を
サポートするためです

890
00:49:04,311 --> 00:49:06,947
多様なビューサイズの
サポートも必要です

891
00:49:07,347 --> 00:49:09,316
これは横長です

892
00:49:09,416 --> 00:49:12,186
こちらは縦長です

893
00:49:13,153 --> 00:49:16,723
これには他にも理由があります

894
00:49:16,823 --> 00:49:21,495
ライブラリの画像は
有機的に増えていくものなので

895
00:49:21,595 --> 00:49:25,432
数千のライブラリを作成するのは
非常にまれだからです

896
00:49:27,601 --> 00:49:31,271
セクション全体を
生成しないのはなぜでしょう？

897
00:49:32,573 --> 00:49:36,243
このアニメーションを行うためです

898
00:49:36,343 --> 00:49:39,379
コレクションが
セクションに展開したり―

899
00:49:39,479 --> 00:49:42,683
逆にグループに
折り畳まれたりします

900
00:49:45,853 --> 00:49:49,289
２番目のパートで
もう１つ大切なこと

901
00:49:49,389 --> 00:49:52,459
それはビュー階層の
レイアウトコストを考え―

902
00:49:52,860 --> 00:49:54,228
それを測定することです

903
00:49:56,530 --> 00:49:59,433
最後は 常にパフォーマンスを
考えること

904
00:49:59,533 --> 00:50:03,270
私たちは日々
そのことを考え改善を重ねています

905
00:49:59,533 --> 00:50:03,270
私たちは日々
そのことを考え改善を重ねています

906
00:50:04,838 --> 00:50:06,273
より詳しい情報は―

907
00:50:06,373 --> 00:50:10,544
ここに映っている
３つのラボで紹介します

908
00:50:11,211 --> 00:50:13,247
引き続き WWDCをお楽しみください

909
00:50:13,447 --> 00:50:14,415
ありがとう

910
00:50:14,515 --> 00:50:20,521
(拍手)