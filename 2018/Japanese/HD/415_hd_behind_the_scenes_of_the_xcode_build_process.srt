
1
00:00:07,040 --> 00:00:16,149
(音楽)

2
00:00:30,631 --> 00:00:36,236
(拍手)

3
00:00:36,336 --> 00:00:37,704
こんにちは

4
00:00:38,071 --> 00:00:41,608
今日はXcodeの
ビルドプロセスを解説します

5
00:00:41,808 --> 00:00:45,712
私はビルドシステム部門の
ジェイクです

6
00:00:45,846 --> 00:00:49,416
これから交代で
解説していきます

7
00:00:51,118 --> 00:00:55,689
まずXcode 10の新たな
ビルドシステムを説明します

8
00:00:55,789 --> 00:00:58,559
全面的に再構築され
進化しました

9
00:00:58,892 --> 00:01:02,362
Command + Bを押すと
何が起きるのでしょう？

10
00:00:58,892 --> 00:01:02,362
Command + Bを押すと
何が起きるのでしょう？

11
00:01:02,462 --> 00:01:06,733
どんな順番で どうやって
プロジェクトの情報を使い―

12
00:01:06,834 --> 00:01:10,337
ビルドプロセスを
決定するのでしょうか？

13
00:01:11,371 --> 00:01:14,007
次にコンパイラの領域です

14
00:01:14,541 --> 00:01:18,879
オブジェクトファイルへと
コンパイルされる過程や―

15
00:01:19,146 --> 00:01:21,315
ヘッダとモジュールの
動きを説明します

16
00:01:21,415 --> 00:01:24,151
コンパイラが
宣言を見つける方法とは？

17
00:01:24,251 --> 00:01:29,523
Swiftのコンパイルは
他の言語とは大きく異なります

18
00:01:30,557 --> 00:01:36,029
プロセスの最終段階である
リンカーも解説します

19
00:01:36,296 --> 00:01:39,399
シンボルの役割を
確認しましょう

20
00:01:39,500 --> 00:01:42,436
また コンパイラで生成した
オブジェクトファイルが―

21
00:01:42,536 --> 00:01:46,707
実行可能ファイルとなる
過程を説明します

22
00:01:48,242 --> 00:01:52,880
アプリケーションの
サンプルを用意しました

23
00:01:52,980 --> 00:01:56,049
ペットの写真を表示する
PetWallです

24
00:01:59,052 --> 00:02:02,055
では ビルドプロセスの
解説を始めます

25
00:01:59,052 --> 00:02:02,055
では ビルドプロセスの
解説を始めます

26
00:02:02,155 --> 00:02:05,592
Xcodeがアプリケーションを
ビルドする方法とは？

27
00:02:06,093 --> 00:02:11,732
アプリケーションは 多数の
ソースコードで成り立っており―

28
00:02:11,832 --> 00:02:14,168
記述言語も異なります

29
00:02:15,536 --> 00:02:16,236
さて…

30
00:02:17,271 --> 00:02:18,505
ビルドとは―

31
00:02:19,039 --> 00:02:23,677
ソースコードやリソースを
パッケージ化することです

32
00:02:23,777 --> 00:02:28,382
ユーザに配信するまでには
多くのステップがあります

33
00:02:29,016 --> 00:02:31,718
コンパイルや
リンク作業の他に―

34
00:02:31,818 --> 00:02:37,024
ヘッダを始めとした
リソースの管理も必要です

35
00:02:37,157 --> 00:02:38,559
そしてコード署名します

36
00:02:38,659 --> 00:02:41,595
場合によっては
シェルスクリプトや―

37
00:02:41,795 --> 00:02:47,267
APIドキュメントや
検証ツールの準備もするでしょう

38
00:02:48,368 --> 00:02:52,406
こうした処理には
コマンドラインツールが必要です

39
00:02:52,506 --> 00:02:56,944
例えば ClangやLD
ACツールなどです

40
00:02:57,477 --> 00:03:01,048
正常に実行させるには
プロジェクト内の引数を―

41
00:02:57,477 --> 00:03:01,048
正常に実行させるには
プロジェクト内の引数を―

42
00:03:01,148 --> 00:03:05,118
正しい順序で
構成する必要があります

43
00:03:06,520 --> 00:03:11,225
ビルドシステムは
指示されたタスクを―

44
00:03:11,325 --> 00:03:12,926
自動的に処理します

45
00:03:13,427 --> 00:03:16,230
タスクは何万にも及びます

46
00:03:16,330 --> 00:03:20,467
しかも 互いが複雑に
依存しているのです

47
00:03:20,567 --> 00:03:24,371
ビルドのたびに
手動で処理していられません

48
00:03:25,439 --> 00:03:27,641
ビルドシステムに
任せましょう

49
00:03:29,376 --> 00:03:34,248
ビルドシステムの実行に際し
大事なのは順序です

50
00:03:34,348 --> 00:03:37,718
順序の決定方法と
その理由を説明します

51
00:03:38,752 --> 00:03:43,123
タスクの実行順序は
依存関係によって決まります

52
00:03:43,223 --> 00:03:48,462
タスクはインプットを受け
アウトプットを生成します

53
00:03:49,263 --> 00:03:55,269
例えば PetViewController.mを
コンパイルすると―

54
00:03:55,369 --> 00:03:59,439
PetViewController.oが
生成されます

55
00:04:00,240 --> 00:04:06,246
コンパイラが生成したものを
リンカーにインプットすると―

56
00:04:06,346 --> 00:04:08,815
実行可能ファイルや
ライブラリが生成されます

57
00:04:08,916 --> 00:04:11,919
そして 実行可能ファイルは
Appバンドルへ収めます

58
00:04:12,186 --> 00:04:15,322
パターンが見えてきましたね

59
00:04:15,956 --> 00:04:19,625
依存関係に従った
流れになっています

60
00:04:19,726 --> 00:04:22,596
これが実行順序にも
なるわけです

61
00:04:22,896 --> 00:04:28,435
この図を交通に見立て
コンパイルを考えてみます

62
00:04:28,535 --> 00:04:32,439
各コンパイル過程は
独立した道路です

63
00:04:32,539 --> 00:04:34,508
並列処理が可能です

64
00:04:35,309 --> 00:04:39,713
全インプットの終着点
リンクタスクは最後ですね

65
00:04:41,215 --> 00:04:46,553
依存関係を定義することで
タスクの実行順序が決まります

66
00:04:46,653 --> 00:04:49,022
並列化も可能です

67
00:04:49,122 --> 00:04:51,091
これが依存性順序です

68
00:04:51,625 --> 00:04:53,861
以上が
ビルドプロセスの概要です

69
00:04:53,961 --> 00:04:57,097
続いて詳しく見ていきます

70
00:04:57,364 --> 00:04:59,733
ビルドを開始したら
何が起こるか？

71
00:05:00,367 --> 00:05:05,105
ビルドシステムは まず
プロジェクトファイルを参照します

72
00:05:05,205 --> 00:05:08,909
プロジェクトに記述してある
ターゲットや依存関係―

73
00:05:09,009 --> 00:05:12,446
さらにビルド設定などを
解析します

74
00:05:12,746 --> 00:05:15,949
続いて その結果を
有向グラフにします

75
00:05:16,283 --> 00:05:20,754
全ファイルの依存関係を
表しています

76
00:05:20,854 --> 00:05:24,124
実行すべきタスクも
表示されています

77
00:05:26,126 --> 00:05:29,496
下層処理エンジンが
グラフを整理します

78
00:05:29,596 --> 00:05:34,434
タスクの実行順序は
依存関係により決定されます

79
00:05:34,568 --> 00:05:39,206
並列処理するタスクも
この時に判断されます

80
00:05:39,339 --> 00:05:41,708
そして実行に移します

81
00:05:42,543 --> 00:05:46,346
ところで Xcode 10の
下層処理エンジンllbuildは―

82
00:05:46,446 --> 00:05:48,582
オープンソースです

83
00:05:48,682 --> 00:05:52,686
興味があれば
実物を確認できます

84
00:05:52,786 --> 00:05:57,357
セッションの最後に
URLを紹介します

85
00:05:58,192 --> 00:06:01,328
次に依存関係の発見について
説明します

86
00:05:58,192 --> 00:06:01,328
次に依存関係の発見について
説明します

87
00:06:01,461 --> 00:06:04,398
依存関係の定義は
多い方がいいので―

88
00:06:04,498 --> 00:06:09,369
システムが新情報を
発見することがあります

89
00:06:09,636 --> 00:06:15,409
すると コンパイル時に
オブジェクトファイルと共に―

90
00:06:15,576 --> 00:06:17,878
別のファイルも生成されます

91
00:06:18,445 --> 00:06:22,549
ヘッダファイルの
リストなどが含まれます

92
00:06:22,649 --> 00:06:26,887
このリストは
再度ビルドする時に使います

93
00:06:26,987 --> 00:06:32,392
これでヘッダを変更しても
コンパイルが可能になります

94
00:06:32,492 --> 00:06:35,529
ご覧のとおり
PetController.hから

95
00:06:35,629 --> 00:06:39,099
.oファイルまで
つながっています

96
00:06:40,267 --> 00:06:42,936
さて 説明してきたとおり―

97
00:06:43,103 --> 00:06:47,374
ビルドシステムの主な役割は
タスク処理です

98
00:06:47,875 --> 00:06:51,778
プロジェクトが大きければ
処理も長くなります

99
00:06:51,879 --> 00:06:55,549
毎回 全タスクを
実行するのは大変です

100
00:06:56,016 --> 00:07:01,088
代わりに
サブセットだけ実行します

101
00:06:56,016 --> 00:07:01,088
代わりに
サブセットだけ実行します

102
00:07:02,656 --> 00:07:06,627
前回のビルドからの
更新部分だけ処理するのです

103
00:07:07,127 --> 00:07:09,763
増分ビルドといいます

104
00:07:09,863 --> 00:07:11,832
正常に処理するためには―

105
00:07:11,932 --> 00:07:16,069
依存情報の正確性が
非常に重要です

106
00:07:17,938 --> 00:07:22,009
更新の影響と増分ビルドの
話をしましたが―

107
00:07:22,142 --> 00:07:24,978
更新部分を検知する仕組みとは？

108
00:07:25,946 --> 00:07:28,982
各タスクには
関連する情報に基づいて―

109
00:07:29,082 --> 00:07:33,420
ハッシュ値のような署名が
ひも付いています

110
00:07:34,721 --> 00:07:37,524
インプットのstat情報が
含まれます

111
00:07:37,624 --> 00:07:40,394
具体的にはファイルのパスや
更新日時―

112
00:07:40,494 --> 00:07:43,664
コマンドラインによる
指示などです

113
00:07:43,764 --> 00:07:48,068
さらに コンパイラの
バージョン情報も入ります

114
00:07:49,436 --> 00:07:53,874
前回 ビルドした時の署名と
合わせて追跡することで―

115
00:07:53,974 --> 00:07:58,011
タスクの再実行が必要か
判断します

116
00:07:59,012 --> 00:08:03,283
現在の署名が
前回と異なる場合には―

117
00:07:59,012 --> 00:08:03,283
現在の署名が
前回と異なる場合には―

118
00:08:03,383 --> 00:08:05,719
再びタスクを実行します

119
00:08:05,953 --> 00:08:08,455
署名が同じなら
スキップします

120
00:08:08,856 --> 00:08:11,625
これが増分ビルドの基本です

121
00:08:12,826 --> 00:08:17,297
ビルドの流れと仕組みが
分かってきましたね

122
00:08:17,397 --> 00:08:19,666
次にシステムの負担を
軽減しましょう

123
00:08:21,101 --> 00:08:22,769
振り返ってみます

124
00:08:22,970 --> 00:08:27,441
ビルドとは順序に沿った
一連のタスク処理です

125
00:08:27,674 --> 00:08:30,944
でも 有向グラフの話を
思い出しましょう

126
00:08:31,812 --> 00:08:35,249
人間は順序を
考える必要はありません

127
00:08:35,349 --> 00:08:37,217
ビルドシステムの仕事です

128
00:08:37,683 --> 00:08:42,256
私たちはタスクの依存関係を
考えればいいのです

129
00:08:42,356 --> 00:08:46,527
システムに順序良く
正常に処理させましょう

130
00:08:46,827 --> 00:08:50,764
可能な場合には
並列処理もしてくれます

131
00:08:50,864 --> 00:08:53,800
マルチコアを
フル活用してください

132
00:08:54,835 --> 00:08:57,070
依存関係の出どころは？

133
00:08:57,237 --> 00:09:01,675
ビルドシステムが
作る場合もあります

134
00:08:57,237 --> 00:09:01,675
ビルドシステムが
作る場合もあります

135
00:09:01,775 --> 00:09:05,078
コンパイラやリンカー用の
ルールが―

136
00:09:05,179 --> 00:09:08,382
あらかじめ
備わっているのです

137
00:09:08,482 --> 00:09:13,854
ルールに従ってインプットや
アウトプットが決定されます

138
00:09:15,389 --> 00:09:19,826
ターゲットの生成順序を決める
依存関係もあります

139
00:09:20,160 --> 00:09:24,631
別ターゲットのソースの
並列コンパイルも可能です

140
00:09:24,731 --> 00:09:26,934
Xcode 9での
ターゲットのビルドは―

141
00:09:27,034 --> 00:09:31,705
依存する別ターゲットの
処理完了後のみ可能でした

142
00:09:32,039 --> 00:09:35,642
Xcode 10では
ビルド開始が早くなりました

143
00:09:35,742 --> 00:09:40,881
コンパイル開始も早くなり
並列処理も可能です

144
00:09:41,081 --> 00:09:43,984
ただし
並列処理させたい場合―

145
00:09:44,084 --> 00:09:48,255
Run Script Phaseは
先に終了してください

146
00:09:49,289 --> 00:09:52,993
ターゲット関連の依存は
暗黙の依存関係です

147
00:09:53,193 --> 00:09:56,864
例えばLink Binary With Libraryに
ターゲットを入れた時です

148
00:09:57,231 --> 00:10:01,468
Find Implicit Dependenciesを
有効にしておけば―

149
00:09:57,231 --> 00:10:01,468
Find Implicit Dependenciesを
有効にしておけば―

150
00:10:01,568 --> 00:10:06,940
Target Dependenciesにない
依存関係が発見できます

151
00:10:08,475 --> 00:10:10,744
続いて ビルドフェーズによる
依存関係です

152
00:10:10,844 --> 00:10:13,814
エディタ内には
多数のフェーズがあります

153
00:10:13,914 --> 00:10:18,752
内容はヘッダのコピーや
ソースのコンパイルなどです

154
00:10:19,086 --> 00:10:24,858
タスクは基本的には
リストの順に実行されます

155
00:10:24,958 --> 00:10:29,029
Link Binary With Libraryが
コンパイルソースの前にあるなど

156
00:10:29,129 --> 00:10:32,799
場合によっては
順序は入れ替わります

157
00:10:32,966 --> 00:10:37,004
この順序が不正な場合
ビルドの失敗もあり得ます

158
00:10:37,104 --> 00:10:41,675
依存関係を理解し
正しい順序で組んでください

159
00:10:42,876 --> 00:10:45,179
スキームの順序による
依存関係もあります

160
00:10:45,279 --> 00:10:48,482
Parallelize Buildを
スキーム設定で有効にすると―

161
00:10:48,582 --> 00:10:52,853
並列処理できるので
順序は関係なくなります

162
00:10:52,953 --> 00:10:57,724
しかし Prallelize Buildを
無効にすると―

163
00:10:57,825 --> 00:11:01,461
リスト順に
１つずつ処理されます

164
00:10:57,825 --> 00:11:01,461
リスト順に
１つずつ処理されます

165
00:11:01,929 --> 00:11:05,732
ターゲットの依存関係は
優先度が高いですが―

166
00:11:05,833 --> 00:11:08,268
それ以外は
リスト順が優先されます

167
00:11:08,535 --> 00:11:12,139
それなら人間が
依存関係を定義せず―

168
00:11:12,239 --> 00:11:14,575
任せてしまえばいいのか？

169
00:11:14,675 --> 00:11:18,912
１つずつの処理では
時間が掛かりすぎます

170
00:11:19,012 --> 00:11:22,015
よって Parallelize Buildは
有効にしつつ―

171
00:11:22,115 --> 00:11:25,252
自分でも依存関係を
正確に定義しましょう

172
00:11:27,454 --> 00:11:31,325
依存関係を生み出す
最後の要素は あなたです

173
00:11:32,693 --> 00:11:35,762
シェルスクリプトのビルドや
ビルドルールを作成する場合―

174
00:11:35,863 --> 00:11:38,866
インプットとアウトプットを
明確に定義しましょう

175
00:11:38,966 --> 00:11:42,402
タスクの不要な再実行を
予防でき―

176
00:11:42,503 --> 00:11:45,539
正しい順序での実行に
役立ちます

177
00:11:45,706 --> 00:11:48,842
定義はRun Script Phaseの
エディタで行います

178
00:11:48,942 --> 00:11:53,146
パスを作れば 環境変化にも
対応しやすくなります

179
00:11:54,681 --> 00:11:58,352
依存関係を自動リンクに
頼ってはいけません

180
00:11:58,652 --> 00:12:00,587
自動リンク機能は―

181
00:11:58,652 --> 00:12:00,587
自動リンク機能は―

182
00:12:00,687 --> 00:12:04,191
Link Frameworks Automaticallyの
設定で有効にできます

183
00:12:04,491 --> 00:12:09,263
Link Binary With Libraryで
リンクしていなくても―

184
00:12:09,363 --> 00:12:13,167
モジュールに対応し
フレームワークにリンクします

185
00:12:13,267 --> 00:12:18,739
ただ ビルドシステムのように
依存関係は定義されず―

186
00:12:18,839 --> 00:12:24,111
依存するターゲットがリンク前に
ビルドされていない場合があります

187
00:12:25,212 --> 00:12:29,216
自動リンクに頼っていいのは
SDKフレームワーク使用時だけです

188
00:12:29,316 --> 00:12:34,555
UIKitなどが 依存関係を
付加してくれるからです

189
00:12:34,688 --> 00:12:38,759
Xcodeプロジェクトには
依存関係を明示してください

190
00:12:40,394 --> 00:12:44,298
依存関係を明示したい
別プロジェクトがあれば―

191
00:12:44,398 --> 00:12:46,333
ファイルナビゲータに
ドロップしてください

192
00:12:46,633 --> 00:12:49,736
リファレンスを作成できます

193
00:12:51,738 --> 00:12:56,944
繰り返しますが 重要なのは
正確な依存関係です

194
00:12:57,044 --> 00:12:59,780
並列処理と安定した結果に
つながります

195
00:12:59,880 --> 00:13:03,450
ビルドを短縮し
開発に時間を割きましょう

196
00:12:59,880 --> 00:13:03,450
ビルドを短縮し
開発に時間を割きましょう

197
00:13:04,184 --> 00:13:08,856
ビルドをより高速化し
iMac Proの性能を生かすには―

198
00:13:08,956 --> 00:13:12,259
Building Faster in Xcodeを
ご覧ください

199
00:13:12,492 --> 00:13:17,097
次はユルゲンが
コンパイラを解説します

200
00:13:17,965 --> 00:13:23,170
(拍手)

201
00:13:23,270 --> 00:13:24,138
ありがとう

202
00:13:26,240 --> 00:13:29,576
これから お話しするのは―

203
00:13:29,676 --> 00:13:32,779
XcodeがClangを
呼び出す時の挙動です

204
00:13:34,181 --> 00:13:35,148
こんにちは

205
00:13:35,282 --> 00:13:39,286
私はユルゲン
Clangのエンジニアです

206
00:13:39,987 --> 00:13:43,924
主に２つの内容を
お話しします

207
00:13:44,224 --> 00:13:47,127
１つ目はヘッダマップです

208
00:13:47,394 --> 00:13:53,100
XcodeからClangへの
情報の伝達方法を説明します

209
00:13:54,034 --> 00:13:57,004
２つ目はClang Modulesです

210
00:13:57,104 --> 00:13:59,873
ビルドの高速化に関わります

211
00:14:00,974 --> 00:14:04,244
Swiftしか触らない人も
いるでしょう

212
00:14:04,645 --> 00:14:08,682
でも実際には
Clangも関わりがあります

213
00:14:08,815 --> 00:14:11,084
ぜひ お聞きください

214
00:14:14,521 --> 00:14:15,823
Clangとは？

215
00:14:16,990 --> 00:14:19,693
AppleのC言語コンパイラです

216
00:14:19,927 --> 00:14:23,931
Cだけでなく
すべてのC言語ファミリーです

217
00:14:24,097 --> 00:14:25,799
C++や―

218
00:14:25,899 --> 00:14:30,871
よく使用される
Objective-Cも含みます

219
00:14:32,439 --> 00:14:34,174
ジェイクの話の確認です

220
00:14:35,342 --> 00:14:40,447
１つのインプットファイルごとに
コンパイラが呼び出され―

221
00:14:40,547 --> 00:14:42,449
アウトプットを
リンカーに渡します

222
00:14:43,383 --> 00:14:47,654
例えば
OSからAPIへアクセス―

223
00:14:47,855 --> 00:14:53,293
または自分のコードの実装に
アクセスするとします

224
00:14:53,393 --> 00:14:56,330
すると通常 ヘッダファイルも
インクルードされます

225
00:14:57,531 --> 00:14:59,967
ヘッダファイルとは約束です

226
00:15:00,400 --> 00:15:04,671
つまり 実装ファイルが
存在するとの約束です

227
00:15:04,771 --> 00:15:06,273
普通は約束どおりです

228
00:15:07,174 --> 00:15:10,744
実装ファイルだけ更新し
ヘッダを忘れると―

229
00:15:10,944 --> 00:15:13,647
約束を破ることになります

230
00:15:14,348 --> 00:15:20,154
コンパイラは約束を信じ
処理を完了しますが―

231
00:15:20,354 --> 00:15:23,323
リンク時に問題が起きます

232
00:15:24,758 --> 00:15:29,897
コンパイラは大抵
複数のヘッダをインクルードします

233
00:15:29,997 --> 00:15:31,865
これを いくつも処理します

234
00:15:32,232 --> 00:15:36,637
アプリケーションの
サンプルを使って―

235
00:15:36,737 --> 00:15:38,605
ヘッダの扱いを確認します

236
00:15:40,507 --> 00:15:44,344
PetWallは複数の言語で
記述されています

237
00:15:44,878 --> 00:15:47,915
アプリケーション自体は
Swiftで書かれています

238
00:15:48,549 --> 00:15:52,719
フレームワークの言語は
Objective-Cです

239
00:15:52,853 --> 00:15:58,458
サポートライブラリは
C++での記述です

240
00:16:00,127 --> 00:16:03,864
近頃 ファイルが
多くなってきたので―

241
00:16:03,964 --> 00:16:07,968
探し物を楽にするため
整理してみます

242
00:16:08,068 --> 00:16:12,906
Catの関連ファイルを
サブフォルダに移します

243
00:16:16,210 --> 00:16:20,280
実装ファイルを
更新していないのに―

244
00:16:20,581 --> 00:16:22,583
動作は正常です

245
00:16:22,950 --> 00:16:25,252
ここで疑問が生じます

246
00:16:26,253 --> 00:16:29,623
Clangはどうやって
ヘッダを見つけるのか？

247
00:16:32,492 --> 00:16:34,161
例で確認します

248
00:16:34,595 --> 00:16:36,830
これが私たちが使っている―

249
00:16:37,531 --> 00:16:38,899
実装ファイルです

250
00:16:38,999 --> 00:16:42,002
ヘッダファイルCat.hを
インクルードしています

251
00:16:43,003 --> 00:16:46,473
Clangの動きを
知る方法とは？

252
00:16:46,840 --> 00:16:49,710
ビルドログからも
確認できます

253
00:16:50,677 --> 00:16:56,116
ビルドシステムの
コンパイル時の動作ログです

254
00:16:56,216 --> 00:16:58,252
呼び出しのログを
コピーします

255
00:16:59,052 --> 00:17:03,090
ターミナルに貼り付けて
-vを付けます

256
00:16:59,052 --> 00:17:03,090
ターミナルに貼り付けて
-vを付けます

257
00:17:03,757 --> 00:17:05,692
詳細を表示するコマンドです

258
00:17:05,858 --> 00:17:08,896
多くの情報を教えてくれます

259
00:17:09,363 --> 00:17:13,767
今はパスの検索だけに
しておきましょう

260
00:17:15,234 --> 00:17:19,873
パスの検索と聞くと
ソースまでのパスが―

261
00:17:19,973 --> 00:17:23,710
表示されると思うでしょう

262
00:17:24,877 --> 00:17:26,980
でも そうではありません

263
00:17:27,314 --> 00:17:30,951
これで表示されるのは
ヘッダマップです

264
00:17:32,319 --> 00:17:36,557
Xcodeのビルドシステムは
ヘッダマップによって―

265
00:17:36,657 --> 00:17:39,593
ヘッダファイルを見つけます

266
00:17:40,360 --> 00:17:41,595
では続きです

267
00:17:41,728 --> 00:17:45,699
確認するのは
２つのヘッダマップファイルです

268
00:17:47,834 --> 00:17:50,871
上の２つのヘッダは―

269
00:17:51,572 --> 00:17:55,909
フレームワーク名と
ヘッダ名だけですね

270
00:17:56,176 --> 00:17:59,346
これでパブリックヘッダだと
分かります

271
00:18:02,316 --> 00:18:06,453
ただ この機能に
頼ってはいけません

272
00:18:07,421 --> 00:18:11,058
動作させ続けるために
必要な機能ですが―

273
00:18:11,625 --> 00:18:15,329
これに頼るとClangModules使用時に
問題が起こる場合があります

274
00:18:15,429 --> 00:18:20,834
このようなヘッダファイルを
インクルードする場合は―

275
00:18:20,934 --> 00:18:25,739
フレームワーク名を
記述しておきましょう

276
00:18:27,374 --> 00:18:29,943
３つ目は
プロジェクトのヘッダです

277
00:18:30,110 --> 00:18:32,379
今回は触れません

278
00:18:32,713 --> 00:18:38,685
ヘッダマップの役割とは
ソースコードへの案内です

279
00:18:39,853 --> 00:18:43,690
パブリックだけでなく
プライベートヘッダでも―

280
00:18:44,157 --> 00:18:46,693
必ずソースコードが
見つかります

281
00:18:46,827 --> 00:18:50,664
Clangはソースディレクトリの
ファイルに関して―

282
00:18:50,764 --> 00:18:55,802
役立つエラーや警告を
出してくれます

283
00:18:55,903 --> 00:19:00,240
一方 ビルドディレクトリの
ファイルは対象外です

284
00:18:55,903 --> 00:19:00,240
一方 ビルドディレクトリの
ファイルは対象外です

285
00:19:03,143 --> 00:19:06,613
ヘッダマップの存在を
意識しておかないと―

286
00:19:06,747 --> 00:19:08,182
問題が起きます

287
00:19:08,282 --> 00:19:14,221
よくあるのがプロジェクトに
ヘッダを付け忘れることです

288
00:19:15,055 --> 00:19:19,193
ソースディレクトリには
存在するのにです

289
00:19:19,293 --> 00:19:22,329
プロジェクトには
必ずヘッダを付けましょう

290
00:19:22,963 --> 00:19:25,099
こんな問題もあります

291
00:19:26,366 --> 00:19:30,204
同名のヘッダが
影響し合うトラブルです

292
00:19:31,104 --> 00:19:34,308
必ずユニークな名前を
付けましょう

293
00:19:34,708 --> 00:19:37,644
システムのヘッダにも
言えることです

294
00:19:37,744 --> 00:19:42,049
ローカルヘッダと
同じ名前になっていると―

295
00:19:42,149 --> 00:19:46,320
やはり影響が出るので
避けてください

296
00:19:46,987 --> 00:19:50,057
ところでシステムヘッダを
見つけるには？

297
00:19:52,993 --> 00:19:55,162
PetWallで確認します

298
00:19:55,963 --> 00:20:00,801
SDKのヘッダ Foundation.hを
インクルードしています

299
00:19:55,963 --> 00:20:00,801
SDKのヘッダ Foundation.hを
インクルードしています

300
00:20:01,835 --> 00:20:03,904
先ほどの手順では―

301
00:20:04,338 --> 00:20:08,075
システムヘッダは
見つけられません

302
00:20:08,776 --> 00:20:13,747
ヘッダマップは
自分のヘッダ用なので―

303
00:20:13,847 --> 00:20:15,382
今は必要ありません

304
00:20:16,016 --> 00:20:19,419
インクルードのパスを
見ていきます

305
00:20:19,853 --> 00:20:23,791
デフォルト状態なら
ディレクトリは２つです

306
00:20:23,891 --> 00:20:26,260
１つ目は/usr/includeです

307
00:20:26,427 --> 00:20:29,496
２つ目は
/System/Library/Frameworksです

308
00:20:30,230 --> 00:20:31,798
１つ目を確認します

309
00:20:33,400 --> 00:20:35,102
普通のインクルード
ディレクトリなので―

310
00:20:35,202 --> 00:20:38,605
検索したい対象を
付けるだけです

311
00:20:38,705 --> 00:20:41,642
この場合は
Foundation/Faoudation.hです

312
00:20:42,209 --> 00:20:44,845
ヘッダはないようですね

313
00:20:45,479 --> 00:20:47,714
では２つ目を確認します

314
00:20:48,515 --> 00:20:51,018
/System/Library/Frameworksです

315
00:20:52,085 --> 00:20:54,688
こちらはフレームワーク
ディレクトリですから―

316
00:20:54,788 --> 00:20:57,257
Clangの挙動が異なります

317
00:20:57,357 --> 00:21:01,762
まずフレームワーク名を
特定し―

318
00:20:57,357 --> 00:21:01,762
まずフレームワーク名を
特定し―

319
00:21:01,962 --> 00:21:03,964
存在の有無を確認します

320
00:21:05,432 --> 00:21:10,170
その後 ヘッダディレクトリを
調べに行きます

321
00:21:10,537 --> 00:21:12,940
無事にヘッダが見つかりました

322
00:21:13,607 --> 00:21:16,844
もしもヘッダがない場合は？

323
00:21:16,944 --> 00:21:20,581
存在しないヘッダ名で
探させてみます

324
00:21:21,648 --> 00:21:24,551
ディレクトリ内では
見つかりません

325
00:21:25,786 --> 00:21:29,122
次はプライベートヘッダの
ディレクトリを探しています

326
00:21:30,490 --> 00:21:34,528
プライベートヘッダは
SDKにはありませんが―

327
00:21:34,928 --> 00:21:39,600
他のフレームワークには
含まれる場合があるからです

328
00:21:39,700 --> 00:21:41,702
必ず探しに行きます

329
00:21:42,369 --> 00:21:45,072
でも やっぱり
見つかりません

330
00:21:46,673 --> 00:21:50,144
すると検索が中断されました

331
00:21:50,344 --> 00:21:53,280
延々と
検索するわけではないのです

332
00:21:53,380 --> 00:21:58,585
すでにフレームワークが
見つかっているからです

333
00:21:58,952 --> 00:22:03,156
次はフレームワークの
ディレクトリで検索します

334
00:21:58,952 --> 00:22:03,156
次はフレームワークの
ディレクトリで検索します

335
00:22:03,423 --> 00:22:05,792
それでも見つからなければ
検索終了です

336
00:22:07,928 --> 00:22:11,331
ヘッダのインポートと
プリプロセスが終わってから―

337
00:22:11,632 --> 00:22:14,935
実装ファイルを見る方法を
紹介します

338
00:22:15,135 --> 00:22:17,070
Xcodeで確認します

339
00:22:17,204 --> 00:22:22,443
プリプロセス済みの
実装ファイルを出力しましょう

340
00:22:24,878 --> 00:22:27,347
たくさん表示されました

341
00:22:28,549 --> 00:22:30,851
どのくらい あるのか？

342
00:22:32,819 --> 00:22:35,055
分かりやすい例です

343
00:22:35,889 --> 00:22:38,425
Foundation.hは―

344
00:22:38,759 --> 00:22:42,396
このシステムの
基本的なヘッダです

345
00:22:42,629 --> 00:22:45,732
そのため
直接あるいは間接的に―

346
00:22:45,833 --> 00:22:49,169
他のヘッダに
インポートされやすいのです

347
00:22:49,436 --> 00:22:54,675
コンパイラの呼び出しごとに
かなりの確率で参照されます

348
00:22:55,709 --> 00:22:57,177
すると どうなるか？

349
00:22:57,778 --> 00:23:02,149
一度のインクルードで
約800個ものヘッダファイルを―

350
00:22:57,778 --> 00:23:02,149
一度のインクルードで
約800個ものヘッダファイルを―

351
00:23:02,249 --> 00:23:04,451
処理することになります

352
00:23:05,485 --> 00:23:11,024
実に９MB以上のソースコードを
解析し検証するのです

353
00:23:11,758 --> 00:23:15,229
コンパイラを
呼び出すたびにですよ

354
00:23:15,462 --> 00:23:18,298
あまりに冗長な処理です

355
00:23:18,966 --> 00:23:19,933
では―

356
00:23:20,868 --> 00:23:21,835
改善策は？

357
00:23:23,937 --> 00:23:27,908
プリコンパイル済みヘッダも
１つの手です

358
00:23:28,075 --> 00:23:30,110
改善できるでしょう

359
00:23:30,510 --> 00:23:31,845
もっといいのは―

360
00:23:32,079 --> 00:23:35,249
数年前に導入した
Clang Modulesです

361
00:23:36,250 --> 00:23:38,786
これを使うと
フレームワークごとに―

362
00:23:39,019 --> 00:23:42,222
１度しかヘッダを参照しません

363
00:23:42,322 --> 00:23:47,728
ディスク上にキャッシュし
再利用するからです

364
00:23:48,262 --> 00:23:51,165
ビルド時間が短縮できます

365
00:23:53,801 --> 00:23:55,202
これを実現するため―

366
00:23:55,335 --> 00:23:58,238
いくつか必要な要素を
開発しました

367
00:23:59,339 --> 00:24:02,943
中でも重要なのが
コンテキストフリーです

368
00:23:59,339 --> 00:24:02,943
中でも重要なのが
コンテキストフリーです

369
00:24:03,477 --> 00:24:05,145
詳しく説明します

370
00:24:06,914 --> 00:24:09,049
これはコードの一部です

371
00:24:09,149 --> 00:24:13,086
どちらもPetKitモジュールを
インポートします

372
00:24:13,887 --> 00:24:18,258
しかし その前の
マクロ定義が異なります

373
00:24:19,660 --> 00:24:22,830
従来のやり方で
インポートすると―

374
00:24:22,930 --> 00:24:25,099
このまま
インクルードされます

375
00:24:25,265 --> 00:24:30,337
プリプロセッサは定義どおり
ヘッダを処理します

376
00:24:31,171 --> 00:24:35,642
そのため ヘッダごとに
モジュールが生成され―

377
00:24:35,742 --> 00:24:37,277
再利用できません

378
00:24:37,611 --> 00:24:38,445
つまり―

379
00:24:38,979 --> 00:24:41,648
使い回すには
別の方法が必要でした

380
00:24:41,782 --> 00:24:46,987
どの実装ファイルにも
再利用できるように―

381
00:24:47,120 --> 00:24:51,925
コンテキストに関する情報を
無視させるのです

382
00:24:54,027 --> 00:24:55,629
他にも 必要だったのが―

383
00:24:56,597 --> 00:24:58,665
モジュールの自己完結力です

384
00:24:58,899 --> 00:25:03,270
モジュールに依存関係を
記述させるのです

385
00:24:58,899 --> 00:25:03,270
モジュールに依存関係を
記述させるのです

386
00:25:04,104 --> 00:25:06,673
便利な機能ですよね

387
00:25:06,840 --> 00:25:10,110
一度 モジュールを
インポートしてしまえば―

388
00:25:10,477 --> 00:25:15,983
ヘッダの追加を
意識する必要がなくなります

389
00:25:19,152 --> 00:25:24,792
モジュールが必要か
どうやって判断するのでしょう？

390
00:25:25,959 --> 00:25:29,630
サンプルで確認します
NSString.hです

391
00:25:30,497 --> 00:25:34,735
Clangはフレームワーク内で
このヘッダを探します

392
00:25:37,037 --> 00:25:38,539
先ほどと同じです

393
00:25:38,639 --> 00:25:41,408
Foundation.frameworkの
ディレクトリへ

394
00:25:42,042 --> 00:25:44,278
ここでClangが探すのは―

395
00:25:44,411 --> 00:25:47,047
モジュールディレクトリの
モジュールマップです

396
00:25:47,147 --> 00:25:49,149
ひも付き先が
ヘッダディレクトリです

397
00:25:49,550 --> 00:25:50,284
ありました

398
00:25:51,485 --> 00:25:53,253
モジュールマップとは？

399
00:25:53,353 --> 00:25:57,591
一連のヘッダファイルが
モジュールに変換される過程を―

400
00:25:57,691 --> 00:25:59,860
記述したマップです

401
00:26:00,894 --> 00:26:02,196
ご覧ください

402
00:26:03,764 --> 00:26:05,999
モジュールマップは簡単です

403
00:26:06,099 --> 00:26:09,369
Foundationのマップは
これで全部です

404
00:26:10,370 --> 00:26:14,241
まずは モジュール名の
Foundationです

405
00:26:14,875 --> 00:26:19,913
その下に モジュールの
ヘッダ名があります

406
00:26:20,614 --> 00:26:25,319
これは いつも必ず
Foundation.hです

407
00:26:25,719 --> 00:26:27,387
特別なヘッダです

408
00:26:27,488 --> 00:26:31,859
これは
umbrellaヘッダといいます

409
00:26:32,392 --> 00:26:37,030
Clangは
このヘッダファイルを参照し―

410
00:26:37,130 --> 00:26:41,101
NSString.hがあるかを確認します

411
00:26:42,236 --> 00:26:43,971
ありましたね

412
00:26:44,338 --> 00:26:50,177
NSString.hは
Foundationモジュールの一部です

413
00:26:50,577 --> 00:26:52,780
Clangは このヘッダを―

414
00:26:52,880 --> 00:26:55,949
言語からモジュール形式に
変換します

415
00:26:56,250 --> 00:26:59,353
Foundationモジュールの
ビルドが必要ですね

416
00:27:01,021 --> 00:27:03,290
Foundationモジュールの
ビルド方法は？

417
00:27:03,924 --> 00:27:07,661
Clangは まず
別の領域を作成します

418
00:27:08,495 --> 00:27:13,100
Foundationモジュールの
全ヘッダを収める場所です

419
00:27:15,135 --> 00:27:18,939
最初のコンパイルで残っている
コンテキストを―

420
00:27:19,072 --> 00:27:21,375
変更する必要はありません

421
00:27:21,508 --> 00:27:23,143
コンテキストフリーですからね

422
00:27:24,011 --> 00:27:28,248
変更するのは Clangに渡した
コマンドライン引数です

423
00:27:28,348 --> 00:27:29,783
Clangが持っています

424
00:27:32,119 --> 00:27:34,388
Foundationモジュールを
ビルドしました

425
00:27:35,422 --> 00:27:39,026
しかし
このフレームワークは―

426
00:27:39,293 --> 00:27:41,862
別のフレームワークを
インクルードします

427
00:27:41,962 --> 00:27:45,132
そのモジュールも
ビルドする必要があります

428
00:27:46,633 --> 00:27:51,672
さらなるインクルードに備え
これを繰り返していきます

429
00:27:52,239 --> 00:27:54,608
これにはメリットがあります

430
00:27:55,142 --> 00:27:57,478
同様のインポートが
ある場合に―

431
00:27:57,578 --> 00:28:00,581
再利用できますよね

432
00:27:57,578 --> 00:28:00,581
再利用できますよね

433
00:28:02,783 --> 00:28:07,187
モジュールキャッシュとして
ディスク上に格納されます

434
00:28:09,323 --> 00:28:10,490
先に言ったとおり―

435
00:28:11,391 --> 00:28:15,295
コマンドライン引数が
Clangに渡されたままです

436
00:28:15,696 --> 00:28:16,830
このままでは―

437
00:28:17,364 --> 00:28:22,236
モジュールの中身にも
引数が影響してしまいます

438
00:28:22,703 --> 00:28:26,473
そのため 引数は
ハッシュ化しておきます

439
00:28:26,573 --> 00:28:30,644
また 作成したモジュールは
ハッシュ値と一致する―

440
00:28:30,744 --> 00:28:33,013
ディレクトリに格納します

441
00:28:34,481 --> 00:28:37,284
異なる制限の
ファイルのために―

442
00:28:37,417 --> 00:28:39,019
引数を変更したら？

443
00:28:39,119 --> 00:28:41,922
ここではENABLE CATです

444
00:28:42,823 --> 00:28:44,358
ハッシュ値が変わります

445
00:28:44,458 --> 00:28:48,862
新たなハッシュ値と一致する
ディレクトリに―

446
00:28:48,962 --> 00:28:52,466
全インプットを
再ビルドする必要があります

447
00:28:53,267 --> 00:28:57,504
モジュールのキャッシュを
最大限活用したいなら―

448
00:28:57,604 --> 00:29:02,409
引数の変更は できるだけ
避けた方がいいですね

449
00:28:57,604 --> 00:29:02,409
引数の変更は できるだけ
避けた方がいいですね

450
00:29:05,112 --> 00:29:09,783
システムフレームワークの
モジュールの話でしたが―

451
00:29:10,317 --> 00:29:14,988
自分のフレームワークで
同じことをするには？

452
00:29:16,924 --> 00:29:21,361
サンプルのCatで
確認しましょう

453
00:29:23,363 --> 00:29:25,632
再びヘッダマップを使い―

454
00:29:25,966 --> 00:29:30,204
ソースディレクトリへ
行きます

455
00:29:31,805 --> 00:29:34,608
ここで問題が発覚します

456
00:29:35,409 --> 00:29:37,277
モジュールディレクトリが
ありません

457
00:29:38,111 --> 00:29:40,247
フレームワークらしくないですね

458
00:29:41,215 --> 00:29:45,018
Clangも
対処に困ってしまいます

459
00:29:45,419 --> 00:29:48,789
解決手段をご紹介しましょう

460
00:29:49,289 --> 00:29:52,025
Clangの
仮想ファイルシステムです

461
00:29:52,526 --> 00:29:56,196
仮想フレームワークを
作成するものです

462
00:29:56,797 --> 00:29:59,533
Clangは ここで
モジュールを作成します

463
00:29:59,867 --> 00:30:00,534
ただし―

464
00:29:59,867 --> 00:30:00,534
ただし―

465
00:30:00,901 --> 00:30:04,972
対象は自分のディレクトリ内の
ファイルだけです

466
00:30:05,239 --> 00:30:10,377
Clangが教えてくれるエラーも
自分のソースコードだけでしたね

467
00:30:11,812 --> 00:30:15,749
以上 自分のフレームワークの
モジュールビルド方法でした

468
00:30:18,352 --> 00:30:20,521
初めに言ったように―

469
00:30:20,687 --> 00:30:25,159
フレームワーク名がないと
問題が起こり得ます

470
00:30:25,893 --> 00:30:28,762
失敗例を見てみましょう

471
00:30:30,531 --> 00:30:33,834
インポートが２つだけの
簡単な例です

472
00:30:33,934 --> 00:30:37,738
１行目は
PetKitのモジュールです

473
00:30:39,139 --> 00:30:44,645
次もモジュールの一部だと
私たちは知っています

474
00:30:45,012 --> 00:30:47,748
Clangには判断できません

475
00:30:47,981 --> 00:30:50,417
フレームワーク名が
ないからです

476
00:30:51,718 --> 00:30:57,658
この場合 定義の重複による
エラーが起こり得ます

477
00:30:57,758 --> 00:31:01,361
主に 同一のヘッダを
再インポートする時です

478
00:30:57,758 --> 00:31:01,361
主に 同一のヘッダを
再インポートする時です

479
00:31:03,130 --> 00:31:09,503
Clangは こうしたエラーを
懸命に修復してくれます

480
00:31:10,537 --> 00:31:12,406
でも すべては無理です

481
00:31:13,240 --> 00:31:15,008
例で見てみます

482
00:31:15,409 --> 00:31:17,077
少しだけ変更しましょう

483
00:31:18,512 --> 00:31:20,380
コンテキストを変えます

484
00:31:21,348 --> 00:31:25,385
モジュールのインポートには
影響しません

485
00:31:25,485 --> 00:31:28,388
先ほど見たとおり
コンテキストは無視されます

486
00:31:29,556 --> 00:31:33,760
でも Cat.hは
モジュール化されていないのに―

487
00:31:33,861 --> 00:31:36,029
変更に反応しません

488
00:31:36,263 --> 00:31:39,800
これでは
定義の重複以前の問題です

489
00:31:39,900 --> 00:31:44,304
定義の矛盾が
発生してしまいます

490
00:31:44,671 --> 00:31:46,440
これは修復不可能です

491
00:31:46,907 --> 00:31:52,379
パブリックやプライベートの
ヘッダをインポートするなら―

492
00:31:52,479 --> 00:31:55,716
必ずフレームワーク名を
付けましょう

493
00:31:56,650 --> 00:32:00,387
続いて デヴィンが話すのは
Swiftと―

494
00:31:56,650 --> 00:32:00,387
続いて デヴィンが話すのは
Swiftと―

495
00:32:00,621 --> 00:32:02,489
Clang Modulesの関係です

496
00:32:02,589 --> 00:32:08,962
(拍手)

497
00:32:09,062 --> 00:32:10,130
ありがとう

498
00:32:11,331 --> 00:32:13,300
これから ご説明するのは―

499
00:32:13,634 --> 00:32:19,506
Swiftとビルドシステムが協力して
宣言を見つける方法です

500
00:32:21,408 --> 00:32:23,710
ユルゲンの話を
振り返りましょう

501
00:32:23,811 --> 00:32:27,214
Objective-Cファイルは
個別にコンパイルされます

502
00:32:27,781 --> 00:32:31,919
別のファイルを探すのに
クラスを参照したい場合―

503
00:32:32,386 --> 00:32:36,256
クラスを宣言したヘッダを
インポートします

504
00:32:37,424 --> 00:32:41,328
でも Swiftではヘッダを
記述する必要がありません

505
00:32:41,528 --> 00:32:44,798
初めて開発言語を学ぶ人に
親切ですね

506
00:32:44,898 --> 00:32:49,036
別々のファイルで
宣言を繰り返す必要もありません

507
00:32:50,337 --> 00:32:54,541
ただ コンパイラにとっては
記録管理の手間が増えます

508
00:32:54,942 --> 00:32:57,444
どうやって記録するのか
説明します

509
00:32:59,713 --> 00:33:02,282
PetWallで見てみましょう

510
00:32:59,713 --> 00:33:02,282
PetWallで見てみましょう

511
00:33:02,850 --> 00:33:06,286
ViewControllerに
view変数を持っています

512
00:33:07,054 --> 00:33:08,889
続いて Objective-Cの
AppDelegateと―

513
00:33:08,989 --> 00:33:10,791
Swiftのユニットテストです

514
00:33:11,558 --> 00:33:15,963
PetViewControllerを
コンパイルするだけでも―

515
00:33:16,396 --> 00:33:19,533
４つの処理が必要になります

516
00:33:20,367 --> 00:33:23,136
まずは宣言の参照です

517
00:33:23,303 --> 00:33:25,372
Swiftのターゲット内と―

518
00:33:25,472 --> 00:33:27,841
Objective-Cからも受け取ります

519
00:33:29,176 --> 00:33:33,280
次に ファイルの内容を記述する
インターフェイスを生成します

520
00:33:33,380 --> 00:33:36,183
そのインターフェイスの宣言を
今度は―

521
00:33:36,283 --> 00:33:39,887
Objective-Cや
別のターゲットが参照します

522
00:33:40,721 --> 00:33:43,690
このスライドの
例を使って―

523
00:33:43,791 --> 00:33:47,127
４つのタスクを
説明していきます

524
00:33:47,694 --> 00:33:51,098
初めに ターゲット自身の
宣言を見つけます

525
00:33:55,502 --> 00:33:58,305
PetViewController.swiftを
コンパイルするには―

526
00:33:58,739 --> 00:34:02,543
イニシャライザの
タイプを調べます

527
00:33:58,739 --> 00:34:02,543
イニシャライザの
タイプを調べます

528
00:34:02,676 --> 00:34:04,511
呼び出せるかの確認です

529
00:34:05,412 --> 00:34:09,983
しかし その前に
PetView.swiftを解析します

530
00:34:10,150 --> 00:34:15,155
イニシャライザの宣言が適切か
検証するためです

531
00:34:15,755 --> 00:34:21,562
イニシャライザのボディを
確認する必要はありません

532
00:34:22,029 --> 00:34:26,867
でも インターフェイス用に
情報は必要です

533
00:34:29,803 --> 00:34:35,141
つまり １つのSwiftファイルを
コンパイルするために―

534
00:34:35,576 --> 00:34:39,246
ターゲットのSwiftファイルを
すべて解析するのです

535
00:34:39,346 --> 00:34:42,983
インターフェイスとの関連部分を
検証するためです

536
00:34:48,222 --> 00:34:51,291
Xcode 9では
増分デバッグビルドが―

537
00:34:51,391 --> 00:34:53,893
繰り返し行われていました

538
00:34:53,994 --> 00:34:57,731
ファイルを個別に
コンパイルしていたからです

539
00:34:58,298 --> 00:35:01,034
これは並列処理を
可能にする一方―

540
00:34:58,298 --> 00:35:01,034
これは並列処理を
可能にする一方―

541
00:35:01,135 --> 00:35:04,638
各ファイルを何度も
解析する必要があります

542
00:35:05,272 --> 00:35:08,108
１つの実装が
.oを生成するごとに―

543
00:35:08,208 --> 00:35:12,780
インターフェイスは何度も
宣言を参照します

544
00:35:14,147 --> 00:35:16,984
Xcode 10では
オーバーヘッドが軽減されました

545
00:35:17,451 --> 00:35:20,688
ファイルは
グループ化され―

546
00:35:20,788 --> 00:35:23,424
可能な限りの処理を
共有します

547
00:35:24,591 --> 00:35:27,261
しかも並列処理も可能です

548
00:35:27,861 --> 00:35:30,497
グループ内で
解析結果を共有すれば―

549
00:35:31,131 --> 00:35:33,967
繰り返し行うのは
グループ間の処理のみです

550
00:35:34,501 --> 00:35:38,238
個別コンパイルよりも
処理が少なくて済みます

551
00:35:38,338 --> 00:35:42,910
増分デバッグビルド時間は
かなり短縮されました

552
00:35:46,113 --> 00:35:49,950
Swiftコードが呼び出すのは
Swiftコードだけでなく―

553
00:35:50,050 --> 00:35:51,985
Objective-Cも呼び出します

554
00:35:53,554 --> 00:35:58,425
PetWallで確認すると
その必要性が分かります

555
00:35:58,525 --> 00:36:03,063
システムのフレームワークは
Objective-Cだからです

556
00:35:58,525 --> 00:36:03,063
システムのフレームワークは
Objective-Cだからです

557
00:36:06,567 --> 00:36:10,137
Swiftは
他の開発言語と違い―

558
00:36:10,237 --> 00:36:14,341
他言語の関数型インターフェイスを
用意する必要がありません

559
00:36:15,776 --> 00:36:19,379
つまり
Objective-CのAPIごとに―

560
00:36:19,479 --> 00:36:22,149
Swiftで
宣言を書かずに済みます

561
00:36:22,950 --> 00:36:27,988
コンパイラにClangの大部分が
埋め込まれており―

562
00:36:28,188 --> 00:36:29,923
ライブラリとして
使用されます

563
00:36:30,457 --> 00:36:34,528
私たちはフレームワークを
インポートするだけです

564
00:36:37,131 --> 00:36:39,633
続いて
Objective-Cの宣言です

565
00:36:40,300 --> 00:36:44,505
ターゲットのタイプに基づき
ヘッダを確認します

566
00:36:45,806 --> 00:36:49,409
Objective-Cのフレームワークを
インポートする場合―

567
00:36:49,943 --> 00:36:52,346
インポータが
ヘッダの宣言を参照します

568
00:36:52,446 --> 00:36:55,616
モジュールマップを
使うのです

569
00:36:56,917 --> 00:37:00,254
SwiftとObjective-Cが
混在するフレームワークでは―

570
00:36:56,917 --> 00:37:00,254
SwiftとObjective-Cが
混在するフレームワークでは―

571
00:37:00,420 --> 00:37:03,490
umbrellaヘッダ内で
宣言を見つけます

572
00:37:04,525 --> 00:37:07,427
パブリックインターフェイスを
定義するヘッダです

573
00:37:08,228 --> 00:37:10,864
これでフレームワーク内の
Swiftコードが―

574
00:37:10,964 --> 00:37:14,902
パブリックのObjective-Cコードを
呼び出せます

575
00:37:16,837 --> 00:37:19,339
最後にアプリケーションと
ユニットテスト内で―

576
00:37:19,439 --> 00:37:22,042
ターゲットのブリッジングヘッダに
importを付加します

577
00:37:22,142 --> 00:37:25,812
これで Swiftから
宣言が呼び出せますね

578
00:37:28,348 --> 00:37:29,016
さて…

579
00:37:29,616 --> 00:37:31,752
インポータが
取り込んだ宣言は―

580
00:37:31,852 --> 00:37:35,155
よりSwiftらしい形に
変換されます

581
00:37:35,556 --> 00:37:39,893
例えば NSErrorを使う
Objective-Cのメソッドが―

582
00:37:40,027 --> 00:37:44,998
throwを使用した Swiftらしい
エラー処理になります

583
00:37:47,801 --> 00:37:50,671
Objective-Cでは
タイプ名のパラメータが―

584
00:37:50,771 --> 00:37:52,906
動詞や前置詞の後に続きます

585
00:37:53,874 --> 00:37:56,643
例は drawPetと
atPointメソッドです

586
00:37:56,743 --> 00:37:58,345
Petという単語があります

587
00:37:58,545 --> 00:38:02,416
タイプのパラメータ Petが
動詞drawの後にあります

588
00:37:58,545 --> 00:38:02,416
タイプのパラメータ Petが
動詞drawの後にあります

589
00:38:03,016 --> 00:38:08,555
同じく タイプのパラメータである
CGPointのPointも―

590
00:38:08,655 --> 00:38:10,457
前置詞atの後にありますね

591
00:38:11,925 --> 00:38:15,462
しかし Swiftに
インポートされると―

592
00:38:15,562 --> 00:38:18,098
単にdrawとatになります

593
00:38:19,333 --> 00:38:23,036
その仕組みは
意外に思うかもしれません

594
00:38:23,771 --> 00:38:28,142
英語の動詞と前置詞の
リストがあるのです

595
00:38:29,610 --> 00:38:33,313
しかし 人間の言語は
あまりに複雑です

596
00:38:33,414 --> 00:38:35,315
リストにない単語もあります

597
00:38:35,682 --> 00:38:38,819
そして Swiftの慣例に
合わせるために―

598
00:38:38,919 --> 00:38:44,291
インポータは品詞によって
不要な単語を判断しています

599
00:38:45,125 --> 00:38:47,828
例えば feedは
単語リストにありません

600
00:38:47,928 --> 00:38:52,532
このため feedPetは
例外的な形に変換されます

601
00:38:53,467 --> 00:38:57,237
任意の名前で
インポートさせるには―

602
00:38:57,337 --> 00:39:01,775
NS SWIFT NAMEの注釈を
使いましょう

603
00:38:57,337 --> 00:39:01,775
NS SWIFT NAMEの注釈を
使いましょう

604
00:39:05,746 --> 00:39:10,083
どうインポートされるのか
確認したい場合には―

605
00:39:10,284 --> 00:39:13,354
XcodeのRelated Itemsを
開いてください

606
00:39:13,454 --> 00:39:16,190
ソースエディタの
左上にあります

607
00:39:16,557 --> 00:39:18,659
Generated Interfaceを
選択してください

608
00:39:18,759 --> 00:39:23,197
インターフェイスが Swiftで
どう表示されるか確認できます

609
00:39:25,432 --> 00:39:27,901
これが SwiftがObjective-Cを
インポートする場合です

610
00:39:28,268 --> 00:39:33,140
では逆に Objective-Cが
Swiftをインポートする場合は？

611
00:39:35,309 --> 00:39:39,513
インポート可能なヘッダを
Swiftが生成します

612
00:39:39,880 --> 00:39:42,516
つまり
Swiftでクラスを記述し―

613
00:39:42,616 --> 00:39:44,718
Objective-Cから
呼び出すことが可能です

614
00:39:45,586 --> 00:39:47,087
挙動を見てみましょう

615
00:39:48,355 --> 00:39:51,225
コンパイラはObjective-Cの
宣言を生成します

616
00:39:51,325 --> 00:39:53,994
Swift側のNSObjectと
@objcが付いたメソッドを―

617
00:39:54,094 --> 00:39:56,296
拡張するためです

618
00:39:57,364 --> 00:39:58,732
このヘッダは―

619
00:39:58,832 --> 00:40:02,870
パブリックとインターナル両方の
宣言を含んでいます

620
00:39:58,832 --> 00:40:02,870
パブリックとインターナル両方の
宣言を含んでいます

621
00:40:02,970 --> 00:40:05,005
これで
インターナルのSwiftを―

622
00:40:05,105 --> 00:40:07,441
Objective-Cが使用できます

623
00:40:08,609 --> 00:40:09,977
ただし
フレームワーク用には―

624
00:40:10,077 --> 00:40:13,213
ヘッダはパブリックの宣言しか
提供しません

625
00:40:13,313 --> 00:40:15,449
これ自体が
ビルド結果に含まれる―

626
00:40:15,549 --> 00:40:18,285
パブリックインターフェイスの
一部だからです

627
00:40:20,521 --> 00:40:24,758
さて Objective-Cクラスが
ひも付く先は―

628
00:40:24,858 --> 00:40:27,594
Swiftクラスの
マングル名になっています

629
00:40:27,694 --> 00:40:30,698
一部はモジュールの名前
PetWallです

630
00:40:31,865 --> 00:40:34,368
モジュールについて
少し説明した後―

631
00:40:34,635 --> 00:40:36,703
ルイスが この現象を解説します

632
00:40:36,870 --> 00:40:41,208
同じ名前で定義すると
実行時に競合が発生します

633
00:40:41,308 --> 00:40:44,711
それを防ぐための
マングル名です

634
00:40:46,180 --> 00:40:50,184
Objective-Cの  attribute  に
識別子を持たせれば―

635
00:40:50,284 --> 00:40:53,821
任意の名前を
指定することも可能です

636
00:40:54,154 --> 00:40:59,026
ただし 競合が起きないよう
注意してください

637
00:40:59,893 --> 00:41:05,265
私自身はPWLと付けることで
競合を回避しています

638
00:40:59,893 --> 00:41:05,265
私自身はPWLと付けることで
競合を回避しています

639
00:41:05,599 --> 00:41:07,901
これでObjective-C側で―

640
00:41:08,001 --> 00:41:11,572
PWLPetCollarとして
クラスを参照できます

641
00:41:14,074 --> 00:41:17,411
他のSwiftターゲットが
参照できるように―

642
00:41:17,511 --> 00:41:19,413
同様の手法で
インターフェイスを生成します

643
00:41:21,215 --> 00:41:25,219
Swiftでのビルドは
Clangのモジュールと似ています

644
00:41:25,319 --> 00:41:27,087
ユルゲンが説明しましたね

645
00:41:27,287 --> 00:41:29,923
そして より深く
言語に溶け込みます

646
00:41:30,657 --> 00:41:34,728
Swiftのモジュールは
配信可能な宣言の集合です

647
00:41:34,828 --> 00:41:37,264
この宣言を
使用可能にするには―

648
00:41:37,364 --> 00:41:39,633
モジュールの
インポートが必要です

649
00:41:40,300 --> 00:41:44,771
この例ではObjective-Cの
XCTestをインポートしました

650
00:41:45,272 --> 00:41:49,810
XcodeではSwiftのターゲットは
独立したモジュールを作ります

651
00:41:50,043 --> 00:41:51,712
アプリケーションもです

652
00:41:52,446 --> 00:41:55,048
アプリケーション本体の
モジュールも―

653
00:41:55,148 --> 00:41:57,851
ユニットテストをするには
インポートが必要です

654
00:42:00,621 --> 00:42:03,891
インポート時 コンパイラは
Swiftモジュールを―

655
00:42:03,991 --> 00:42:06,160
デシリアライズします

656
00:42:06,360 --> 00:42:08,295
タイプを確認するためです

657
00:42:09,096 --> 00:42:13,667
この例でも コンパイラは
PetWall.swiftmoduleの―

658
00:42:14,001 --> 00:42:15,969
PetViewControllerを
読み込みます

659
00:42:16,070 --> 00:42:18,839
整合性を確認するためです

660
00:42:19,740 --> 00:42:23,610
コンパイラがターゲット内の
宣言を見つける方法と―

661
00:42:23,710 --> 00:42:25,279
似ていますよね

662
00:42:25,913 --> 00:42:30,150
今回はSwiftファイルを
直接 解析するのではなく―

663
00:42:30,350 --> 00:42:33,420
モジュールの要約を
読み込みます

664
00:42:36,323 --> 00:42:38,825
コンパイラが作る
Swiftのモジュールは―

665
00:42:38,926 --> 00:42:41,962
Objective-Cのヘッダに
よく似ています

666
00:42:42,296 --> 00:42:45,499
ただし 言語ではなく
バイナリ形式です

667
00:42:45,966 --> 00:42:48,368
また インライナブル関数の
ボディをインクルードします

668
00:42:48,469 --> 00:42:51,104
Objective-Cでの
スタティックインライン関数や―

669
00:42:51,205 --> 00:42:53,974
C++でのヘッダ内の実装と
似ています

670
00:42:54,808 --> 00:42:56,810
特徴としては―

671
00:42:56,910 --> 00:43:01,715
プライベート宣言の名前とタイプも
インクルードすることです

672
00:42:56,910 --> 00:43:01,715
プライベート宣言の名前とタイプも
インクルードすることです

673
00:43:02,082 --> 00:43:05,886
デバッガで
参照するのに便利です

674
00:43:06,186 --> 00:43:08,288
ここで注意です

675
00:43:08,388 --> 00:43:12,559
見られて恥ずかしい
適当な名前を付けないこと

676
00:43:15,796 --> 00:43:20,267
増分ビルドを行うため ファイルは
まず部分ごとに生成され―

677
00:43:20,367 --> 00:43:26,173
その後 モジュール全体を表す
１つのファイルになります

678
00:43:26,940 --> 00:43:32,946
この時 Objective-Cのヘッダも
１つ生成されます

679
00:43:34,448 --> 00:43:37,151
似たような働きをするのが
リンカーで―

680
00:43:37,251 --> 00:43:41,855
オブジェクトファイルを
１つの実行ファイルにします

681
00:43:42,222 --> 00:43:46,527
次は このリンカーを
ルイスが解説します

682
00:43:46,827 --> 00:43:47,628
ルイス

683
00:43:48,295 --> 00:43:49,363
ありがとう

684
00:43:49,463 --> 00:43:54,735
(拍手)

685
00:43:54,835 --> 00:43:57,504
リンカー担当のルイスです

686
00:43:57,838 --> 00:44:00,440
これがビルドの最終段階です

687
00:43:57,838 --> 00:44:00,440
これがビルドの最終段階です

688
00:44:00,541 --> 00:44:01,842
さっそく始めましょう

689
00:44:03,043 --> 00:44:06,046
今から話す内容は
こちらです

690
00:44:06,713 --> 00:44:09,116
リンカーの役割を説明します

691
00:44:09,616 --> 00:44:14,121
次にインプットとなる
ファイルの種類を確認します

692
00:44:14,655 --> 00:44:18,292
その一部であるシンボルも
説明します

693
00:44:18,859 --> 00:44:23,263
最後に サンプルを使って
話をまとめます

694
00:44:23,364 --> 00:44:24,598
難解ですからね

695
00:44:25,065 --> 00:44:29,236
最後まで聞けば
分かってくるはずです

696
00:44:31,405 --> 00:44:33,740
まず リンカーとは何か？

697
00:44:33,841 --> 00:44:37,544
ビルドプロセスの
最終段階ですね

698
00:44:38,078 --> 00:44:41,148
２つのコンパイラが
構築した―

699
00:44:41,248 --> 00:44:46,086
.oファイルをまとめ上げ
実行可能ファイルにします

700
00:44:47,054 --> 00:44:50,457
リンカーはコードを
作ることはできません

701
00:44:50,557 --> 00:44:54,261
重要なポイントなので
サンプルで確認します

702
00:44:55,629 --> 00:44:58,132
インプットファイルは
２種類です

703
00:44:58,232 --> 00:45:02,536
.dylibなどは
ライブラリの拡張子です

704
00:44:58,232 --> 00:45:02,536
.dylibなどは
ライブラリの拡張子です

705
00:45:03,003 --> 00:45:06,840
オブジェクトファイルは
ビルドの過程で生成されましたね

706
00:45:06,940 --> 00:45:10,344
ライブラリには
いくつか種類があります

707
00:45:10,444 --> 00:45:14,882
.dylibや.tbdなどに加え
スタティックライブラリもあります

708
00:45:15,983 --> 00:45:18,218
シンボルとは？

709
00:45:18,452 --> 00:45:22,523
コードやデータを
参照するための名前です

710
00:45:24,625 --> 00:45:27,828
別の関数を呼び出すための
関数を書くと―

711
00:45:27,928 --> 00:45:31,298
他のシンボルを参照する
フラグメントも出てきます

712
00:45:33,600 --> 00:45:38,272
シンボルの特性は
リンカーの挙動に大きく影響します

713
00:45:38,372 --> 00:45:41,975
ウィークシンボルの例を
お話しします

714
00:45:42,242 --> 00:45:45,279
ウィークシンボルは
別のシンボル上の注釈です

715
00:45:45,746 --> 00:45:49,750
実行可能ファイルの実行時に
そのシンボルが―

716
00:45:49,850 --> 00:45:53,120
そこにない方が
いいという注釈です

717
00:45:53,287 --> 00:45:56,156
これが 可用性の
マークアップの正体です

718
00:45:56,256 --> 00:46:01,028
特定のAPIがiOS 12で
使用可能かなどを表します

719
00:45:56,256 --> 00:46:01,028
特定のAPIがiOS 12で
使用可能かなどを表します

720
00:46:01,562 --> 00:46:05,165
内容はリンカーに着くまでに
固まっています

721
00:46:05,265 --> 00:46:08,502
リンカーはどのシンボルを
付けるべきで―

722
00:46:08,602 --> 00:46:13,106
実行に必要なシンボルは何か
決定できます

723
00:46:14,975 --> 00:46:18,245
言語もマングリングにより
データをエンコードし―

724
00:46:18,345 --> 00:46:20,114
シンボルを作ります

725
00:46:21,148 --> 00:46:25,319
それはC++でもSwiftでも
起こります

726
00:46:27,221 --> 00:46:30,023
今 言ったように
シンボルとは―

727
00:46:30,357 --> 00:46:32,960
コードやデータの名前です

728
00:46:33,360 --> 00:46:38,632
そして コンパイラが生成する
オブジェクトファイルは―

729
00:46:38,765 --> 00:46:41,769
コードやデータの集合です

730
00:46:42,369 --> 00:46:45,839
コンパイルされただけでは
実行はできません

731
00:46:45,939 --> 00:46:47,574
不完全なのです

732
00:46:47,674 --> 00:46:51,779
リンカーが結び付けて
整えていきます

733
00:46:54,081 --> 00:46:58,152
ファイルの各フラグメントに
シンボルが付きます

734
00:46:58,318 --> 00:47:00,921
例えば printf関数も―

735
00:46:58,318 --> 00:47:00,921
例えば printf関数も―

736
00:47:01,321 --> 00:47:03,323
シンボル付きの
コードになります

737
00:47:03,424 --> 00:47:08,028
これから見るPetKitの
どの関数でも同じことが起きます

738
00:47:09,830 --> 00:47:14,935
フラグメントが未定義シンボルを
参照する場合もあります

739
00:47:15,702 --> 00:47:20,808
未定義の.oファイルの関数を
参照する場合は―

740
00:47:20,908 --> 00:47:24,144
リンカーが未定義シンボルを見つけ
リンクします

741
00:47:26,280 --> 00:47:30,484
.oファイルはコンパイルの
アウトプットでしたね

742
00:47:30,584 --> 00:47:32,052
では ライブラリは？

743
00:47:32,553 --> 00:47:34,822
シンボルを
定義するファイルで―

744
00:47:34,922 --> 00:47:37,791
ターゲットの一部では
ありません

745
00:47:38,425 --> 00:47:41,228
まずは
ダイナミックライブラリです

746
00:47:41,595 --> 00:47:44,031
これはMach-Oファイルで―

747
00:47:44,131 --> 00:47:48,869
実行可能ファイルが使用する
フラグメントが入っています

748
00:47:49,436 --> 00:47:52,473
これは
私たちのシステムの一部です

749
00:47:52,573 --> 00:47:56,343
他のフレームワークを
併用している人もいるでしょう

750
00:47:58,178 --> 00:48:00,013
次にTBDファイル

751
00:47:58,178 --> 00:48:00,013
次にTBDファイル

752
00:48:00,114 --> 00:48:03,350
つまり
Text Based Dylib Stubsです

753
00:48:03,951 --> 00:48:04,751
ここで―

754
00:48:05,953 --> 00:48:09,523
SDKを開発した時の
話をします

755
00:48:09,623 --> 00:48:12,125
MapKitやWebKitといった
機能と共に―

756
00:48:12,226 --> 00:48:14,595
ダイナミックライブラリも
開発しました

757
00:48:14,728 --> 00:48:19,533
しかし サイズが大きく
全部は組み込めませんでした

758
00:48:19,900 --> 00:48:23,003
しかも 実行時にしか
必要ありません

759
00:48:23,103 --> 00:48:25,172
そこでシンボルのボディは
省略し―

760
00:48:25,272 --> 00:48:28,942
シンボル名だけの
スタブを作成したのです

761
00:48:29,343 --> 00:48:30,677
その後―

762
00:48:30,778 --> 00:48:33,680
使いやすい言語形式へと
改良しました

763
00:48:33,781 --> 00:48:35,516
現在 TBDの役割は―

764
00:48:35,682 --> 00:48:39,286
SDK配信時の
サイズ削減だけです

765
00:48:40,120 --> 00:48:43,524
プロジェクト内にあっても
気にしないでください

766
00:48:43,724 --> 00:48:45,292
シンボルが
入っているだけです

767
00:48:46,093 --> 00:48:49,396
最後は
スタティックライブラリです

768
00:48:50,030 --> 00:48:52,232
スタティックライブラリには―

769
00:48:52,466 --> 00:48:55,168
.oファイルばかりが
入っています

770
00:48:55,269 --> 00:49:00,641
arツールやlibtoolで
ビルドされたものです

771
00:48:55,269 --> 00:49:00,641
arツールやlibtoolで
ビルドされたものです

772
00:49:00,908 --> 00:49:03,310
arのmanページに従って―

773
00:49:03,410 --> 00:49:08,549
arユーティリティが
ファイルを作成し 保守しています

774
00:49:09,283 --> 00:49:12,820
TARやZIPに似ていますよね

775
00:49:12,920 --> 00:49:14,822
それもそのはず

776
00:49:14,922 --> 00:49:18,058
.aはUNIXの初期の
アーカイブフォーマットです

777
00:49:18,158 --> 00:49:20,561
より強力なツールが
登場した時には―

778
00:49:21,628 --> 00:49:26,800
コンパイラなどは
すでに.aに適応していたのです

779
00:49:26,900 --> 00:49:29,136
.aはアーカイブファイルです

780
00:49:31,839 --> 00:49:35,142
特徴としては
ダイナミックリンクです

781
00:49:35,242 --> 00:49:39,580
昔は全コードがアーカイブで
配信されていました

782
00:49:39,747 --> 00:49:41,081
そのため―

783
00:49:41,181 --> 00:49:45,886
C言語のライブラリ全体を
インクルードしたくなかったのです

784
00:49:45,986 --> 00:49:47,788
対処はこうです

785
00:49:48,388 --> 00:49:52,993
シンボル付きの.oファイルだけ
アーカイブから抜き取ります

786
00:49:53,093 --> 00:49:55,529
他のファイルは そのままです

787
00:49:55,863 --> 00:49:59,733
参照は可能で
必要なものは手に入ります

788
00:49:59,833 --> 00:50:03,871
シンボルに関係なく動く
スタティックイニシャライザなどは

789
00:49:59,833 --> 00:50:03,871
シンボルに関係なく動く
スタティックイニシャライザなどは

790
00:50:03,971 --> 00:50:08,575
使用や再エクスポートの時に
注意が必要です

791
00:50:09,076 --> 00:50:13,046
-force loadや-all loadで
対象に入れてください

792
00:50:13,146 --> 00:50:15,382
リンクを行わなくてもです

793
00:50:17,217 --> 00:50:21,054
では サンプルを使って
復習します

794
00:50:23,424 --> 00:50:26,026
スライドをご覧ください

795
00:50:26,126 --> 00:50:30,964
playSound関数の事例です
音は欠かせませんね

796
00:50:32,166 --> 00:50:33,300
さて…

797
00:50:33,667 --> 00:50:37,704
playSoundを呼び出す関数が
Cat内にあります

798
00:50:37,804 --> 00:50:39,273
シンプルな例ですね

799
00:50:39,540 --> 00:50:41,708
生成されたアセンブリを
見てみましょう

800
00:50:42,876 --> 00:50:46,180
Cat.oが生成されました

801
00:50:46,813 --> 00:50:50,450
こちらにある
purr.aacというのが―

802
00:50:50,784 --> 00:50:55,155
私たちが用意した
AACサウンドファイルです

803
00:50:55,656 --> 00:50:57,724
Cat.oにもコピーされました

804
00:50:57,824 --> 00:51:00,961
でも purrFileという名前は
ありませんね

805
00:50:57,824 --> 00:51:00,961
でも purrFileという名前は
ありませんね

806
00:51:01,094 --> 00:51:02,963
静的だからです

807
00:51:03,063 --> 00:51:07,668
C言語を扱う皆さんなら
もう お分かりですよね

808
00:51:07,768 --> 00:51:11,171
他者は参照できないものです
必要ありません

809
00:51:14,208 --> 00:51:15,609
では 次へ

810
00:51:15,943 --> 00:51:21,648
これがシンボルです
-[Cat purr]

811
00:51:23,517 --> 00:51:25,085
想像どおりでしょう

812
00:51:26,286 --> 00:51:31,058
その下の変数を
今からplaySoundに渡します

813
00:51:31,225 --> 00:51:33,760
命令が２つ付いています

814
00:51:33,861 --> 00:51:39,199
この文字列が 実行可能ファイルの
どこに入るか不明だからです

815
00:51:39,299 --> 00:51:41,501
決まった場所はありません

816
00:51:41,602 --> 00:51:45,138
このアセンブリ arm64には―

817
00:51:45,472 --> 00:51:49,209
コンパイラは最大で
２つの命令を残せます

818
00:51:49,343 --> 00:51:53,113
オフセットのPAGEとPAGEOFFが
付いています

819
00:51:53,213 --> 00:51:55,482
リンカーが後で補完します

820
00:51:56,083 --> 00:52:00,954
こうして 文字列が
x0に読み込まれました

821
00:51:56,083 --> 00:52:00,954
こうして 文字列が
x0に読み込まれました

822
00:52:01,722 --> 00:52:04,591
これで
playSoundを呼び出せます

823
00:52:04,691 --> 00:52:10,597
ただし その名前は
  Z9playSoundPKcです

824
00:52:11,265 --> 00:52:14,935
これは マングリングで
生成されたシンボルです

825
00:52:15,035 --> 00:52:18,205
Cat.mmの記述言語は
Objective-C++です

826
00:52:18,372 --> 00:52:21,642
しかし playSoundは
C++関数なのです

827
00:52:22,042 --> 00:52:24,511
判断できない場合―

828
00:52:25,512 --> 00:52:28,615
実際にターミナルで
ツールを使ってみましょう

829
00:52:28,716 --> 00:52:33,587
swift-demangleの後に
シンボルを付けて実行します

830
00:52:33,687 --> 00:52:36,090
Swiftのシンボルでは
ありませんね

831
00:52:36,490 --> 00:52:40,894
では C++のデマングラ
c++filtではどうでしょう？

832
00:52:41,195 --> 00:52:43,831
playSoundのシンボルだと
分かるだけでなく―

833
00:52:43,931 --> 00:52:47,501
引数も分かりました
const char *です

834
00:52:47,601 --> 00:52:52,206
C++はマングル名に情報も
エンコードしているのです

835
00:52:53,640 --> 00:52:58,011
プロジェクトのビルド時には
.oファイルが多数できます

836
00:52:58,846 --> 00:53:01,215
これを どうするのか？

837
00:52:58,846 --> 00:53:01,215
これを どうするのか？

838
00:53:02,049 --> 00:53:06,587
システムは そのすべてを
リンカーに渡します

839
00:53:06,687 --> 00:53:09,490
リンカーは受け入れ用の
ファイルを作ります

840
00:53:09,757 --> 00:53:13,394
PetWallのフレームワーク
PetKitをビルドしてみます

841
00:53:14,962 --> 00:53:18,899
TEXTセグメントを作り
コピーしていきます

842
00:53:19,266 --> 00:53:22,135
すべてのコードを
保管する場所です

843
00:53:22,703 --> 00:53:26,773
まず Cat.oのコピーですが
上下に分かれました

844
00:53:26,874 --> 00:53:29,610
先ほどの文字列と
実行可能コードです

845
00:53:30,377 --> 00:53:35,148
絶対アドレスが分かったので
リンカーは参照しに行きます

846
00:53:35,249 --> 00:53:37,351
Cat.oを書き換え―

847
00:53:37,518 --> 00:53:40,287
具体的なオフセットにします

848
00:53:40,688 --> 00:53:43,624
２つ目の命令が消えましたね

849
00:53:43,724 --> 00:53:47,194
null値の命令に置き換えます

850
00:53:47,794 --> 00:53:53,300
リンカーはコードを作ったり
消したりはしません

851
00:53:53,400 --> 00:53:56,336
ファイルのサイズが変わるからです

852
00:53:56,437 --> 00:53:58,972
だから この場合にも―

853
00:53:59,239 --> 00:54:02,343
何もしない値に
置き換えるだけです

854
00:53:59,239 --> 00:54:02,343
何もしない値に
置き換えるだけです

855
00:54:02,576 --> 00:54:03,944
最後にブランチです

856
00:54:04,812 --> 00:54:06,613
そう ブランチ

857
00:54:07,548 --> 00:54:08,615
しかし…

858
00:54:09,783 --> 00:54:13,020
未定義シンボルは
どうするのでしょう？

859
00:54:13,120 --> 00:54:17,291
この時点で.oファイルは
全部インクルード済みです

860
00:54:18,292 --> 00:54:22,663
スタティックライブラリ
PetSupport.aを見てみましょう

861
00:54:22,963 --> 00:54:24,765
PetSupport.aの中には―

862
00:54:25,499 --> 00:54:28,702
PetSounds.oなど
いくつかファイルがあります

863
00:54:29,503 --> 00:54:33,740
playSoundのシンボルも
あります

864
00:54:34,708 --> 00:54:35,876
取り込みましょう

865
00:54:38,312 --> 00:54:41,248
PetCare.oは取り込みません

866
00:54:41,348 --> 00:54:47,254
他から参照されるシンボルが
付いていないからです

867
00:54:48,522 --> 00:54:50,824
取り込んだはいいものの―

868
00:54:51,859 --> 00:54:55,262
openとあるのは
未定義のシンボルです

869
00:54:56,030 --> 00:54:59,633
open$stubはコピーした時に
付いたものです

870
00:54:59,767 --> 00:55:01,068
なぜでしょう？

871
00:54:59,767 --> 00:55:01,068
なぜでしょう？

872
00:55:01,735 --> 00:55:04,705
openがどこにあるか調べます

873
00:55:05,772 --> 00:55:10,110
ありました
libSystem.tbdファイルです

874
00:55:11,145 --> 00:55:14,214
これは
システムライブラリの一部で―

875
00:55:14,314 --> 00:55:17,384
アプリケーションには
含まれません

876
00:55:17,751 --> 00:55:21,288
呼び出せるように
情報を与える必要があります

877
00:55:21,388 --> 00:55:23,357
そこで仮の関数を作ります

878
00:55:23,490 --> 00:55:25,058
これはテンプレートで―

879
00:55:25,225 --> 00:55:29,363
ライブラリから呼び出す
どの関数にも適用できます

880
00:55:29,630 --> 00:55:31,298
関数を見てみましょう

881
00:55:31,632 --> 00:55:35,369
ポインタから読み込むのですね
open$pointerです

882
00:55:36,036 --> 00:55:37,137
そこへ飛びます

883
00:55:37,237 --> 00:55:40,941
つまり 他のC言語と同様の
関数ポインタが必要です

884
00:55:42,576 --> 00:55:45,446
DATAセグメントに
作りましょう

885
00:55:45,546 --> 00:55:48,649
グローバル変数が入る
セグメントです

886
00:55:49,316 --> 00:55:51,251
ゼロになっています

887
00:55:51,351 --> 00:55:54,788
nullに飛ぶと
クラッシュしてしまいます

888
00:55:55,923 --> 00:56:00,561
LINKEDITを追加します
メタデータのセグメントです

889
00:55:55,923 --> 00:56:00,561
LINKEDITを追加します
メタデータのセグメントです

890
00:56:00,661 --> 00:56:06,467
リンカーツールは
ここにOS用の情報を入れます

891
00:56:06,567 --> 00:56:10,003
これでダイナミックリンカーが
実行時に補完できます

892
00:56:10,104 --> 00:56:11,772
詳しく知りたい方は―

893
00:56:11,905 --> 00:56:16,610
Optimizing App Startup Timeを
ご覧ください

894
00:56:19,279 --> 00:56:20,013
では―

895
00:56:21,014 --> 00:56:23,417
今日の復習をしましょう

896
00:56:23,550 --> 00:56:27,554
ジェイクは ビルドシステムと
依存関係を説明しました

897
00:56:27,654 --> 00:56:30,758
ビルドをマルチコアに
最適化できますね

898
00:56:32,960 --> 00:56:34,995
ユルゲンはClangや―

899
00:56:35,095 --> 00:56:39,500
ビルドを最適化する
モジュールを紹介しました

900
00:56:40,834 --> 00:56:44,905
デヴィンはSwiftの
モジュールを解説し―

901
00:56:45,005 --> 00:56:49,643
高速処理を実現する新機能を
お見せしました

902
00:56:49,743 --> 00:56:53,013
そのアウトプットを受けた
リンカーが―

903
00:56:53,113 --> 00:56:55,149
アプリケーションを
完成させました

904
00:56:55,249 --> 00:56:59,720
あとはコード署名をし
必要なものを付け加え―

905
00:57:00,387 --> 00:57:03,056
アプリケーションを
配信するだけです

906
00:57:03,891 --> 00:57:04,958
そして―

907
00:57:05,893 --> 00:57:09,062
こちらはオープンソースです

908
00:57:09,163 --> 00:57:13,667
SwiftやClangやllbuildに
興味があれば―

909
00:57:14,802 --> 00:57:16,370
こちらのURLへ

910
00:57:16,904 --> 00:57:18,972
ご参加に感謝します

911
00:57:19,173 --> 00:57:22,343
WWDCを楽しめたでしょうか

912
00:57:22,443 --> 00:57:24,144
ありがとうございました

913
00:57:24,411 --> 00:57:26,813
(拍手)