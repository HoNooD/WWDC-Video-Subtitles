
1
00:00:07,508 --> 00:00:15,582
(音楽)

2
00:00:19,520 --> 00:00:25,559
(拍手)

3
00:00:25,659 --> 00:00:26,960
こんにちは

4
00:00:27,060 --> 00:00:29,062
私の名前はケン･フェリーです

5
00:00:29,463 --> 00:00:33,100
本日はAuto Layoutの
パフォーマンスについて説明します

6
00:00:33,534 --> 00:00:37,804
私が前回 Auto Layoutについて
お話ししたのは2011年でした

7
00:00:37,938 --> 00:00:39,640
初めて紹介した時です

8
00:00:39,740 --> 00:00:44,011
また皆さんにお会いできて光栄です

9
00:00:44,845 --> 00:00:47,314
では 始めます

10
00:00:48,248 --> 00:00:49,249
“Auto Layout”は―

11
00:00:49,683 --> 00:00:53,287
MacでiOSの
コンテンツを的確に配置します

12
00:00:53,387 --> 00:00:57,758
ここで重要な要素となるのが
“ビュー”と“制約”です

13
00:00:58,125 --> 00:01:00,827
制約がビューに
条件付けをします

14
00:00:58,125 --> 00:01:00,827
制約がビューに
条件付けをします

15
00:01:01,061 --> 00:01:05,999
コンテンツ配置を行う際
次のような課題があります

16
00:01:06,099 --> 00:01:08,702
“２つのボタンの間隔を
20ポイントにしたい”

17
00:01:08,802 --> 00:01:10,404
“でも そのための―”

18
00:01:10,504 --> 00:01:14,107
“実行プロセスが分かりづらい”

19
00:01:14,208 --> 00:01:18,378
これでは アプリケーションの
パフォーマンスや

20
00:01:18,478 --> 00:01:22,382
速度や動作状況も把握できません

21
00:01:22,983 --> 00:01:25,252
そこで このセッションでは

22
00:01:25,352 --> 00:01:29,957
コンテンツ配置のプロセスを
明確にします

23
00:01:30,357 --> 00:01:31,558
では まず―

24
00:01:31,658 --> 00:01:36,230
iOS 12のリリースにおける
改善点をご紹介します

25
00:01:36,330 --> 00:01:39,433
とても多くの改良を加えました

26
00:01:41,134 --> 00:01:43,504
それが終わったら―

27
00:01:43,604 --> 00:01:48,442
理解を深めるために
１つ１つ詳しく説明します

28
00:01:48,542 --> 00:01:52,246
パフォーマンスを上げる
直感力が身に着きます

29
00:01:52,346 --> 00:01:55,315
今日は特別な試みとして

30
00:01:55,682 --> 00:01:57,518
iOS内部の動作を説明します

31
00:01:57,618 --> 00:01:59,086
楽しんでください

32
00:02:02,456 --> 00:02:06,360
一方で直感に頼っているだけでは

33
00:02:06,460 --> 00:02:08,262
パフォーマンスは向上しません

34
00:02:08,362 --> 00:02:13,066
そこで カシアが説明する
コード解析により―

35
00:02:13,167 --> 00:02:18,005
皆さんの“直感”と“実践”を
結び付けていきます

36
00:02:18,872 --> 00:02:20,340
では 始めましょう

37
00:02:20,440 --> 00:02:25,045
まず Apple伝統の
多くのデータと自慢です

38
00:02:25,512 --> 00:02:29,116
(笑い声)

39
00:02:29,216 --> 00:02:33,220
今見ているのはベンチマークです

40
00:02:33,320 --> 00:02:36,924
これを行う上で
第三者のものも含め

41
00:02:37,024 --> 00:02:39,927
数多くのアプリケーションを
検証しました

42
00:02:40,027 --> 00:02:43,597
テストケースごとに
発生した問題を切り分け

43
00:02:43,697 --> 00:02:45,799
測定したものになります

44
00:02:45,899 --> 00:02:50,337
これは セルフサイジングセルの
UICollectionViewです

45
00:02:50,437 --> 00:02:54,808
左右で動きが悪い方が
iOS 11です

46
00:02:57,144 --> 00:03:00,113
違いがお分かりですよね

47
00:02:57,144 --> 00:03:00,113
違いがお分かりですよね

48
00:03:00,214 --> 00:03:03,083
一方 iOS 12は完ぺきです

49
00:03:03,183 --> 00:03:04,484
フルフレームレートの動きです

50
00:03:05,052 --> 00:03:07,754
これがテストケースの１つです

51
00:03:07,855 --> 00:03:11,959
他にもいくつか事例を
お見せします

52
00:03:12,059 --> 00:03:14,561
これらはすべて時間を表しています

53
00:03:14,661 --> 00:03:18,165
灰色のグラフがiOS 11です

54
00:03:18,265 --> 00:03:19,867
多くの時間がかかっています

55
00:03:19,967 --> 00:03:21,869
水色がiOS 12です

56
00:03:22,936 --> 00:03:27,774
以上からも 多くの改良点を
理解いただけるでしょう

57
00:03:28,008 --> 00:03:31,578
皆さんのアプリケーションも
同様です

58
00:03:31,678 --> 00:03:33,981
大幅な改善が可能です

59
00:03:35,249 --> 00:03:37,551
スタックに
さまざまな手を加えます

60
00:03:37,651 --> 00:03:41,989
一部は アプリケーションの
心臓部に及びます

61
00:03:42,089 --> 00:03:45,926
また UIKitや
クライアントレイヤにも及びます

62
00:03:46,026 --> 00:03:48,529
Auto Layoutの活用次第です

63
00:03:48,629 --> 00:03:51,498
UICollectionViewで見た例では

64
00:03:51,598 --> 00:03:53,834
あらゆる点を改良しました

65
00:03:53,934 --> 00:03:56,537
アプリケーションの心臓部

66
00:03:56,637 --> 00:04:02,543
さらに Auto Layoutを使った
多くの変更により―

67
00:03:56,637 --> 00:04:02,543
さらに Auto Layoutを使った
多くの変更により―

68
00:04:02,643 --> 00:04:05,179
高いパフォーマンスを実現しました

69
00:04:05,279 --> 00:04:08,148
これからの時間で―

70
00:04:08,248 --> 00:04:12,219
Auto Layoutの
適切な使い方を説明します

71
00:04:13,120 --> 00:04:14,555
私たちが―

72
00:04:14,955 --> 00:04:18,926
これら多くの改善を実現できた理由

73
00:04:19,026 --> 00:04:23,564
それは 物事をどう統合して
機能させるかという―

74
00:04:23,697 --> 00:04:26,567
メンタルモデルがあったからです

75
00:04:27,301 --> 00:04:30,103
皆さんもモデルを作りましょう

76
00:04:30,237 --> 00:04:31,305
そのために

77
00:04:31,405 --> 00:04:34,908
クライアントコードを
見ていきます

78
00:04:35,008 --> 00:04:38,946
同時にその問題点も明らかにします

79
00:04:39,179 --> 00:04:42,549
多くのアプリケーションを
見てきた中で

80
00:04:42,649 --> 00:04:47,788
最もよく起こるだろう問題を
取り上げます

81
00:04:47,888 --> 00:04:52,626
同じ問題を抱えていない方も
ぜひご覧ください

82
00:04:52,726 --> 00:04:56,363
新しい知識が得られるはずです

83
00:04:56,930 --> 00:04:58,765
では 始めます

84
00:04:59,700 --> 00:05:03,136
このレイアウトを作ります

85
00:04:59,700 --> 00:05:03,136
このレイアウトを作ります

86
00:05:03,537 --> 00:05:04,905
とてもシンプルです

87
00:05:05,005 --> 00:05:08,442
皆さん Interface Builderで
作るでしょう

88
00:05:08,709 --> 00:05:11,345
賢明なアイデアです

89
00:05:11,445 --> 00:05:14,781
これから起こる問題を回避できます

90
00:05:15,849 --> 00:05:17,651
(笑い声)

91
00:05:17,751 --> 00:05:21,221
でも ここではコードを使います

92
00:05:23,357 --> 00:05:28,061
解析する前に
コードの意味を説明します

93
00:05:28,795 --> 00:05:30,464
まず UIViewの―

94
00:05:30,564 --> 00:05:33,534
“updateConstraints”を
オーバーライドしています

95
00:05:33,800 --> 00:05:36,603
詳しくは 後ほど説明します

96
00:05:37,771 --> 00:05:42,643
次に“myConstraints”という
インスタンス変数があります

97
00:05:42,743 --> 00:05:48,015
その変数で
すべての制約を無効にします

98
00:05:48,482 --> 00:05:52,753
それから制約を作成し
レイアウトを実装します

99
00:05:52,920 --> 00:05:55,856
Visual Format Languageを使った
単純なものです

100
00:05:56,156 --> 00:05:59,026
これらの制約を有効にし
インストールして

101
00:05:59,126 --> 00:06:03,463
“super.updateConstraints”を
忘れずに呼び出します

102
00:05:59,126 --> 00:06:03,463
“super.updateConstraints”を
忘れずに呼び出します

103
00:06:03,564 --> 00:06:07,968
なぜならこれで
UIViewの実装が完了するからです

104
00:06:09,069 --> 00:06:12,673
以上が基本的な構造です

105
00:06:12,773 --> 00:06:15,642
もちろん実際に機能しています

106
00:06:15,876 --> 00:06:17,711
ここからは具体的に―

107
00:06:17,811 --> 00:06:21,548
パフォーマンスを
理解していきましょう

108
00:06:21,915 --> 00:06:24,785
今 オーバーライドしていたのが

109
00:06:24,885 --> 00:06:27,287
“updateConstraints”という
メソッドです

110
00:06:28,555 --> 00:06:30,991
これは Render Loopの
コンポーネントの１つです

111
00:06:31,525 --> 00:06:36,830
Render Loopとは 毎秒120回走る
潜在力のあるプロセスで

112
00:06:37,130 --> 00:06:40,968
コンテンツを各フレームに
確実に表示させます

113
00:06:41,535 --> 00:06:44,071
３つのフェーズで
構成されています

114
00:06:44,171 --> 00:06:46,740
updateConstraints
Layout Displayの３つです

115
00:06:47,074 --> 00:06:48,475
すべてのビューは

116
00:06:48,575 --> 00:06:51,245
“updateConstraints”を
受け取ります

117
00:06:51,545 --> 00:06:56,150
そしてウィンドウに向かって
ビュー階層を上っていきます

118
00:06:56,550 --> 00:06:59,152
次にレイアウトのサブビューを
受け取ります

119
00:06:59,253 --> 00:07:02,923
これはウィンドウから
下へと逆方向に動きます

120
00:06:59,253 --> 00:07:02,923
これはウィンドウから
下へと逆方向に動きます

121
00:07:03,056 --> 00:07:07,461
最後に必要ならば
表示を受け取ります

122
00:07:08,562 --> 00:07:12,599
さて これらは
何のためにあるのでしょう？

123
00:07:13,267 --> 00:07:15,669
これらは同じ目的を持った―

124
00:07:15,769 --> 00:07:18,539
パラレル処理される
メソッドのセットです

125
00:07:18,639 --> 00:07:21,942
その目的とは
“ムダな仕事を避ける”ことです

126
00:07:22,576 --> 00:07:24,344
例を使って説明します

127
00:07:24,745 --> 00:07:26,780
まず ラベルです

128
00:07:26,880 --> 00:07:30,484
UILabelは
テキストサイズを定義した―

129
00:07:30,584 --> 00:07:33,820
制約を持つ必要があります

130
00:07:33,921 --> 00:07:36,223
それに関するプロパティが
数多くあります

131
00:07:36,323 --> 00:07:38,125
テキストプロパティ

132
00:07:38,258 --> 00:07:39,426
フォント

133
00:07:39,526 --> 00:07:41,728
テキストサイズなど

134
00:07:42,896 --> 00:07:45,332
プロパティを変更する度に

135
00:07:45,432 --> 00:07:48,001
テキストを
再測定する方法があります

136
00:07:48,468 --> 00:07:51,538
しかし
連続して変更する場合には

137
00:07:51,638 --> 00:07:54,007
かなり非効率です

138
00:07:54,107 --> 00:07:55,442
ラベル設定時に―

139
00:07:55,542 --> 00:07:57,811
プロパティセッターを
呼び出すでしょう

140
00:07:57,911 --> 00:08:00,214
そこで １つずつ
再測定するとしたら？

141
00:07:57,911 --> 00:08:00,214
そこで １つずつ
再測定するとしたら？

142
00:08:00,414 --> 00:08:03,650
それまでの作業が
すべてムダになります

143
00:08:03,750 --> 00:08:05,652
そこで Render Loopを使います

144
00:08:05,819 --> 00:08:09,756
そうすれば
セットフォントの中で

145
00:08:09,857 --> 00:08:12,926
“setNeedsUpdateConstraints”を
呼び出すだけです

146
00:08:13,260 --> 00:08:16,463
それで フレームが
画面に表示される前に

147
00:08:16,563 --> 00:08:19,132
制約が確実に更新されます

148
00:08:19,733 --> 00:08:20,901
それが狙いです

149
00:08:21,368 --> 00:08:25,005
先に進む前におさらいをします

150
00:08:25,105 --> 00:08:27,975
まず
“毎秒120フレームの高速動作”

151
00:08:28,308 --> 00:08:30,544
次に“パラレル処理”

152
00:08:30,644 --> 00:08:32,546
直感で使えます

153
00:08:32,645 --> 00:08:35,948
もし レイアウトパスが
理解できているなら―

154
00:08:36,116 --> 00:08:39,586
“updateConstraints”も
同じように使えます

155
00:08:40,053 --> 00:08:45,459
最後が すべての目的である
“ムダな作業の回避”

156
00:08:45,726 --> 00:08:48,395
作業を延期か省略できます

157
00:08:49,363 --> 00:08:50,030
いいですね

158
00:08:51,064 --> 00:08:56,503
では 今から
このメソッドの解析に入ります

159
00:08:56,803 --> 00:08:58,872
毎回 私たちは―

160
00:08:58,972 --> 00:09:04,311
制約を無効にしてから
新しい設定を再度有効にします

161
00:08:58,972 --> 00:09:04,311
制約を無効にしてから
新しい設定を再度有効にします

162
00:09:05,345 --> 00:09:07,548
これは layoutSubviewsと
似ています

163
00:09:07,648 --> 00:09:12,753
そこで まったく同じコードを
layoutSubviewsで書くとします

164
00:09:12,853 --> 00:09:19,326
それは毎回 layoutSubviewsを呼び
サブビューを壊し―

165
00:09:19,660 --> 00:09:22,629
作り直して再度追加しているのと
同じです

166
00:09:23,330 --> 00:09:27,301
皆さんの多くが
こう感じるでしょう

167
00:09:27,401 --> 00:09:29,136
“よい性能は期待できない”

168
00:09:30,671 --> 00:09:33,407
そのとおりです

169
00:09:33,507 --> 00:09:37,911
それは“updateConstraints”にも
当てはまります

170
00:09:38,011 --> 00:09:41,348
制約を外したら作業が増えました

171
00:09:42,349 --> 00:09:43,617
どう修正しますか？

172
00:09:43,750 --> 00:09:46,353
先ほど言ったように

173
00:09:46,453 --> 00:09:50,924
同じことを２度やらないためには
作業の延期です

174
00:09:51,391 --> 00:09:55,329
その作業を
すでに行っているなら―

175
00:09:55,529 --> 00:09:58,098
もう何もしないことです

176
00:09:58,198 --> 00:10:01,335
まだなら
その制約を１度設定します

177
00:09:58,198 --> 00:10:01,335
まだなら
その制約を１度設定します

178
00:10:01,668 --> 00:10:03,971
これでうまく機能します

179
00:10:04,071 --> 00:10:05,539
繰り返しますが―

180
00:10:05,639 --> 00:10:09,643
これがクライアントコードにおける
一番の問題です

181
00:10:09,743 --> 00:10:12,346
不必要に
制約を外したり戻すことを

182
00:10:12,746 --> 00:10:15,048
“衝突”と呼んでいます

183
00:10:16,049 --> 00:10:17,618
いいですね

184
00:10:18,018 --> 00:10:19,786
先に進む前に―

185
00:10:19,887 --> 00:10:23,290
Render Loopについて
もう少し話します

186
00:10:24,525 --> 00:10:27,728
不必要な作業を避けたい時に

187
00:10:27,828 --> 00:10:31,465
Render Loopは大変便利です

188
00:10:32,032 --> 00:10:33,467
一方 危険もあります

189
00:10:33,567 --> 00:10:37,371
頻繁に走っているので
注意が必要です

190
00:10:38,305 --> 00:10:42,276
このようなコードを書く時は

191
00:10:42,409 --> 00:10:44,511
慎重さが求められます

192
00:10:44,611 --> 00:10:47,614
また 回数を最小限にすべきです

193
00:10:47,714 --> 00:10:50,984
失敗するのが明らかですから

194
00:10:53,253 --> 00:10:56,690
次のように考えてみましょう

195
00:10:56,790 --> 00:10:58,358
“一度でできないか？”

196
00:10:58,458 --> 00:11:01,128
“updateConstraintsに
置かない方法はないか？”

197
00:10:58,458 --> 00:11:01,128
“updateConstraintsに
置かない方法はないか？”

198
00:11:01,228 --> 00:11:02,162
そんな時は―

199
00:11:02,262 --> 00:11:06,833
Interface Builderを使うのが
一番です

200
00:11:07,401 --> 00:11:10,137
あらゆる作業が楽になります

201
00:11:11,438 --> 00:11:13,307
さて いいでしょう

202
00:11:13,407 --> 00:11:17,911
これでよく起こる問題点が
理解できましたね

203
00:11:18,011 --> 00:11:20,581
似たケースでも参考になります

204
00:11:21,215 --> 00:11:23,650
でも目的は別にあります

205
00:11:23,750 --> 00:11:26,320
“これが悪い”ではなく―

206
00:11:26,420 --> 00:11:30,090
そのプロセスを理解したいのです

207
00:11:30,290 --> 00:11:34,061
そこで 覆いをすべて取り去り―

208
00:11:34,161 --> 00:11:37,331
何が起きているのかを見ます

209
00:11:38,866 --> 00:11:44,037
“制約を有効にする時”と
“制約を追加する時”

210
00:11:44,438 --> 00:11:46,006
それぞれ何が起きるでしょう？

211
00:11:46,807 --> 00:11:48,408
ハイレベルの図にします

212
00:11:48,509 --> 00:11:52,312
これが制約を加えたビューです

213
00:11:53,080 --> 00:11:54,481
ウィンドウの中にあります

214
00:11:55,616 --> 00:11:58,485
そこからつり下がる
内部オブジェクトは―

215
00:11:58,652 --> 00:12:00,454
“エンジン”と呼ばれます

216
00:11:58,652 --> 00:12:00,454
“エンジン”と呼ばれます

217
00:12:00,821 --> 00:12:03,624
これが Auto Layoutの心臓部です

218
00:12:04,892 --> 00:12:07,628
制約が加えられると―

219
00:12:07,728 --> 00:12:10,898
等式が作られます

220
00:12:10,998 --> 00:12:12,833
それは制約に対応するもので

221
00:12:12,933 --> 00:12:15,536
エンジンに加えられます

222
00:12:16,737 --> 00:12:18,872
最後のポイントは―

223
00:12:18,972 --> 00:12:22,442
この等式が変数に関わる点です

224
00:12:22,709 --> 00:12:27,247
等式を用いて
“X”の値を求める場合―

225
00:12:27,381 --> 00:12:28,649
“X”が変数になります

226
00:12:29,283 --> 00:12:32,186
この場合 私たちが求めるのは

227
00:12:32,286 --> 00:12:34,955
ビューのフレームデータです

228
00:12:35,055 --> 00:12:37,157
変数は次の４つです

229
00:12:37,257 --> 00:12:39,893
minX minY 幅 高さ

230
00:12:41,028 --> 00:12:41,762
いいですね

231
00:12:42,129 --> 00:12:44,064
では 進めましょう

232
00:12:44,164 --> 00:12:45,732
このレイアウトを作ります

233
00:12:45,833 --> 00:12:48,836
横方向の制約に焦点を当てますが

234
00:12:48,936 --> 00:12:50,771
すべてに共通のプロセスです

235
00:12:51,271 --> 00:12:55,843
まず最初に
このような等式ができます

236
00:12:57,044 --> 00:12:58,479
とてもシンプルです

237
00:12:58,579 --> 00:13:02,816
一番興味深いのは
テキストフィールドの間隔です

238
00:12:58,579 --> 00:13:02,816
一番興味深いのは
テキストフィールドの間隔です

239
00:13:03,016 --> 00:13:08,222
２つの間隔は 制約の定義と
とても似ています

240
00:13:08,322 --> 00:13:12,025
でも 変数なので
制約よりローレベルです

241
00:13:13,293 --> 00:13:14,895
次に進みます

242
00:13:15,329 --> 00:13:18,699
それぞれの等式が
エンジンに加えられます

243
00:13:19,500 --> 00:13:22,069
プロセスに沿って進みます

244
00:13:22,169 --> 00:13:25,506
目的はもちろん
パフォーマンス向上ですが―

245
00:13:26,206 --> 00:13:29,243
それで何が起こるでしょうか

246
00:13:29,743 --> 00:13:32,813
エンジンは これらの変数を
解こうとしています

247
00:13:33,180 --> 00:13:36,483
代数でやっていたことと

248
00:13:36,583 --> 00:13:38,385
ほぼ同じです

249
00:13:38,619 --> 00:13:40,287
それに従いましょう

250
00:13:40,387 --> 00:13:45,025
最初のフィールドを
“text１.minX = ８”とします

251
00:13:45,993 --> 00:13:48,195
幅は“text１.width = 100”

252
00:13:48,362 --> 00:13:50,364
次のフィールドです

253
00:13:50,497 --> 00:13:54,902
“text２.minX =
text１.minX + text１.width + 20”

254
00:13:55,035 --> 00:14:00,073
これらの変数を
代数でどう解きますか？

255
00:13:55,035 --> 00:14:00,073
これらの変数を
代数でどう解きますか？

256
00:14:00,841 --> 00:14:03,977
すでにある値を代入するでしょう

257
00:14:04,077 --> 00:14:05,913
そのとおりです

258
00:14:06,547 --> 00:14:10,984
分析すると
エンジンのメソッドが見えてきます

259
00:14:11,084 --> 00:14:14,621
文字列置換と
長いメソッド名です

260
00:14:14,721 --> 00:14:15,923
Cocoaなので

261
00:14:16,456 --> 00:14:17,958
(笑い声)

262
00:14:18,325 --> 00:14:21,395
つまり そういうことです

263
00:14:22,162 --> 00:14:24,765
最後の等式が来ました

264
00:14:24,865 --> 00:14:26,900
これで完了です

265
00:14:27,000 --> 00:14:30,437
少なくとも
このケースで発生した作業は

266
00:14:30,537 --> 00:14:33,140
変数を解くことです

267
00:14:33,373 --> 00:14:37,978
これが 現段階で
理解してほしいことです

268
00:14:38,078 --> 00:14:40,814
あまり複雑なことではなく―

269
00:14:40,914 --> 00:14:45,185
手作業でやるのと
ほぼ同じプロセスです

270
00:14:46,487 --> 00:14:48,055
工数もかかりません

271
00:14:48,155 --> 00:14:51,925
いわゆる“代入計算”にすぎません

272
00:14:52,526 --> 00:14:58,198
さて 変数を求めましたが
レイアウトは完成していません

273
00:14:58,298 --> 00:15:01,068
プロセスを完了させましょう

274
00:14:58,298 --> 00:15:01,068
プロセスを完了させましょう

275
00:15:01,902 --> 00:15:07,474
次に エンジンが
これらの変数に値を与えます

276
00:15:07,574 --> 00:15:12,346
そして ビューに
変更された変数が伝えられます

277
00:15:13,480 --> 00:15:15,449
どう返すでしょう？

278
00:15:16,450 --> 00:15:20,587
少し考えて Superviewを呼んで
こう言います

279
00:15:20,687 --> 00:15:22,022
“setNeedsLayout”

280
00:15:22,189 --> 00:15:24,091
動く必要があるからです

281
00:15:25,159 --> 00:15:30,664
これが updateConstraintsで
起こることです

282
00:15:31,031 --> 00:15:35,936
“setNeedsLayout”を受け取り
Layoutに移ります

283
00:15:36,603 --> 00:15:38,639
では 次に行きます

284
00:15:38,739 --> 00:15:43,310
最後に UIViewが
“layoutSubviews”を受け取ります

285
00:15:43,610 --> 00:15:45,779
UIViewのlayoutSubviewsは―

286
00:15:45,879 --> 00:15:49,483
データをエンジンから
フレームにコピーします

287
00:15:50,250 --> 00:15:54,221
エンジンに
“変数の値は？”と聞きます

288
00:15:54,321 --> 00:15:58,358
エンジンは それに答えて
Superviewから―

289
00:15:58,458 --> 00:16:02,396
“setBounds”と“setCenter”を
呼びます

290
00:15:58,458 --> 00:16:02,396
“setBounds”と“setCenter”を
呼びます

291
00:16:03,197 --> 00:16:04,965
これで完了です

292
00:16:05,999 --> 00:16:08,235
少し戻りましょう

293
00:16:08,335 --> 00:16:11,104
これがレイアウトのプロセスです

294
00:16:11,205 --> 00:16:13,974
この概念を習得できれば―

295
00:16:14,074 --> 00:16:19,780
パフォーマンスへの理解が
ずっと高まっていきます

296
00:16:20,380 --> 00:16:22,683
実際に見てみましょう

297
00:16:22,783 --> 00:16:27,421
これは 先ほど
私たちが見てきたメソッドで

298
00:16:27,521 --> 00:16:30,891
制約を無効にしてから
再び有効にしています

299
00:16:30,991 --> 00:16:34,495
ここで エンジンが
何をしているか見ましょう

300
00:16:35,562 --> 00:16:36,997
これです

301
00:16:40,367 --> 00:16:42,402
再び“衝突”です

302
00:16:42,503 --> 00:16:46,540
複雑なオペレーションでは
ありません

303
00:16:46,640 --> 00:16:48,408
ただし大量です

304
00:16:48,742 --> 00:16:52,446
必要のないムダな作業と言えます

305
00:16:52,613 --> 00:16:57,851
こういったことが
感覚として理解できれば

306
00:16:57,951 --> 00:17:00,154
失敗を避けられます

307
00:16:57,951 --> 00:17:00,154
失敗を避けられます

308
00:17:00,254 --> 00:17:03,790
私たちと同じような
パフォーマンスを

309
00:17:03,891 --> 00:17:05,826
皆さんも得られます

310
00:17:06,593 --> 00:17:09,229
さあ いいですね

311
00:17:11,598 --> 00:17:15,102
もう１つ重要なトピックがあります

312
00:17:15,202 --> 00:17:17,204
高いパフォーマンスを求めるなら

313
00:17:17,304 --> 00:17:21,942
必要な時だけ
Auto Layoutを使ってください

314
00:17:22,041 --> 00:17:26,079
どういうことか
次の事例で説明します

315
00:17:26,180 --> 00:17:29,349
今回は 前より複雑で―

316
00:17:29,449 --> 00:17:33,487
２つの階層の中に
４つのフィールドがあります

317
00:17:34,388 --> 00:17:39,793
この場合
階層を横断する制約を作ります

318
00:17:39,993 --> 00:17:41,862
こうです

319
00:17:42,062 --> 00:17:46,934
同じSuperviewを持ちませんが
text１とtext３をそろえます

320
00:17:48,068 --> 00:17:53,373
こんな心配をする方もいるでしょう

321
00:17:53,474 --> 00:17:56,877
“スピードが
かなり遅くなるのではないか”

322
00:17:56,977 --> 00:17:59,546
“常に何かが影響し合い―”

323
00:17:59,646 --> 00:18:03,717
“大きな泥のボールみたいで
パフォーマンスは最低だ”

324
00:17:59,646 --> 00:18:03,717
“大きな泥のボールみたいで
パフォーマンスは最低だ”

325
00:18:04,985 --> 00:18:10,490
では 一般的なケースで
何が起こるのか見ましょう

326
00:18:10,591 --> 00:18:12,392
これは貴重です

327
00:18:12,493 --> 00:18:15,262
ビューは ほとんどの時間―

328
00:18:15,362 --> 00:18:19,500
親や兄弟の制約だけを
受けるからです

329
00:18:19,600 --> 00:18:24,905
ここに ２つの独立した
ブロックがあります

330
00:18:25,105 --> 00:18:29,776
エンジンの中には
２つの代数のブロックがあり―

331
00:18:29,877 --> 00:18:33,981
それぞれの干渉や重複はありません

332
00:18:35,249 --> 00:18:39,887
これらが
互いに影響し合うこともありません

333
00:18:39,987 --> 00:18:44,091
１つ処理をするのに
一定の時間がかかります

334
00:18:44,191 --> 00:18:48,829
もちろん ２つの場合は
２倍の時間がかかります

335
00:18:49,129 --> 00:18:51,131
３つなら３倍です

336
00:18:51,231 --> 00:18:53,534
ポイントはこのライン

337
00:18:53,667 --> 00:18:55,402
リニアなパフォーマンスです

338
00:18:56,837 --> 00:19:01,408
これがパフォーマンスを知る
ベストな指標です

339
00:18:56,837 --> 00:19:01,408
これがパフォーマンスを知る
ベストな指標です

340
00:19:02,476 --> 00:19:08,182
それぞれが独立しているため
この直線が生まれます

341
00:19:08,382 --> 00:19:13,053
依存性を確保したければ
等式のブロックをつなぎます

342
00:19:13,220 --> 00:19:17,458
より多くの
コンピュータ処理になりますが

343
00:19:17,558 --> 00:19:20,194
必要な時だけ行ってください

344
00:19:20,294 --> 00:19:23,163
同じようなことを手作業でやれば

345
00:19:23,263 --> 00:19:27,668
より複雑になる分
少し大変になります

346
00:19:27,768 --> 00:19:29,603
Cocoaの狙いは―

347
00:19:29,703 --> 00:19:35,109
“シンプルなことをシンプルに
複雑なことを可能に”

348
00:19:35,209 --> 00:19:39,880
必要がない時は
工数をかけなくてもよいのです

349
00:19:40,747 --> 00:19:45,853
エンジンを直感的に捉えると―

350
00:19:46,153 --> 00:19:50,824
レイアウトキャッシュと
依存トラッカーと言えます

351
00:19:51,191 --> 00:19:55,362
どの制約がどのビューに
影響を与えるか明確です

352
00:19:55,462 --> 00:20:00,167
変更を加えると
必要な部分だけ更新されます

353
00:19:55,462 --> 00:20:00,167
変更を加えると
必要な部分だけ更新されます

354
00:20:01,401 --> 00:20:04,004
また コードにも影響を与えます

355
00:20:04,671 --> 00:20:06,607
時々 目にするのは―

356
00:20:06,707 --> 00:20:12,079
何とか制約を作らないように
苦心する人々です

357
00:20:12,179 --> 00:20:15,816
面倒な作業になる
印象があるからです

358
00:20:16,617 --> 00:20:18,318
確かにそうですが―

359
00:20:18,418 --> 00:20:23,223
それは 問題と密接に関わる
制約を作る時だけです

360
00:20:23,390 --> 00:20:27,928
それを避ければ
多くのメリットを得られます

361
00:20:28,028 --> 00:20:32,900
人は時々 複雑な測定をして
足し算をして―

362
00:20:33,000 --> 00:20:36,370
情報を抜き出したり
戻したりします

363
00:20:36,470 --> 00:20:38,272
それが大変なのです

364
00:20:38,372 --> 00:20:41,608
制約で表現すれば
よりシンプルです

365
00:20:42,509 --> 00:20:44,711
一方 逆もあります

366
00:20:45,078 --> 00:20:47,581
時々 このような階層を―

367
00:20:47,681 --> 00:20:50,417
目にすることがあります

368
00:20:50,517 --> 00:20:53,787
多くの制約と優先度があって

369
00:20:53,887 --> 00:20:55,556
全容が分かりません

370
00:20:55,656 --> 00:20:57,357
これは―

371
00:20:57,458 --> 00:21:00,994
まさにそういった事例です

372
00:20:57,458 --> 00:21:00,994
まさにそういった事例です

373
00:21:01,094 --> 00:21:05,165
２つの完全に切り離された
レイアウトです

374
00:21:05,265 --> 00:21:09,603
それらを１セットの制約にまとめて

375
00:21:09,703 --> 00:21:11,672
統合しようと考えています

376
00:21:11,772 --> 00:21:14,074
でも懸念があります

377
00:21:14,174 --> 00:21:16,043
２つの間に―

378
00:21:16,510 --> 00:21:21,348
関係性があるかのような
ニセの依存を作り出しています

379
00:21:21,448 --> 00:21:25,018
それに気付けなければ
デバッグも不可能です

380
00:21:26,153 --> 00:21:29,990
全体的なアドバイスとしては

381
00:21:30,124 --> 00:21:32,593
問題をモデル化することです

382
00:21:32,693 --> 00:21:37,798
後ほど カシアがレイアウトの
切り替えについて詳しく説明します

383
00:21:38,131 --> 00:21:41,969
問題のモデル化は
一般的なアドバイスとして

384
00:21:42,069 --> 00:21:45,505
パフォーマンス向上に役立ちます

385
00:21:47,207 --> 00:21:48,575
さて―

386
00:21:49,576 --> 00:21:51,011
以上が要点です

387
00:21:51,111 --> 00:21:55,516
でも 私たちはレイアウトの
メンタルモデルを作りたいので

388
00:21:55,616 --> 00:21:59,720
主要な特性について
すべて触れておきましょう

389
00:22:00,053 --> 00:22:01,889
まだ できることがあります

390
00:22:02,589 --> 00:22:04,391
それを説明します

391
00:22:04,491 --> 00:22:08,262
“幅100ポイント以上”の
ビューが必要な場合

392
00:22:08,362 --> 00:22:09,730
不等式を使えます

393
00:22:10,030 --> 00:22:11,165
大変でしょうか

394
00:22:11,665 --> 00:22:15,135
“幅100ポイント”にするより
ずっと簡単です

395
00:22:15,335 --> 00:22:20,040
説明したとおり
変数が１つ増えます

396
00:22:20,140 --> 00:22:20,941
それだけです

397
00:22:22,409 --> 00:22:24,211
“set constant”も呼び出せます

398
00:22:24,344 --> 00:22:26,813
次のようなケースです

399
00:22:26,914 --> 00:22:30,851
私にはジェスチャ認識があり
ビューをドラッグしようとします

400
00:22:30,951 --> 00:22:35,789
そしてジェスチャ認識から
毎回コールを受け取り―

401
00:22:35,889 --> 00:22:37,958
それを翻訳しようとします

402
00:22:38,091 --> 00:22:41,628
そして 翻訳した値が入った
“set constant”を呼び出し

403
00:22:41,728 --> 00:22:46,300
制約に投入しようとしています

404
00:22:46,500 --> 00:22:47,267
いいですね

405
00:22:47,367 --> 00:22:48,435
そして―

406
00:22:48,535 --> 00:22:52,139
エンジンは どのように
依存関係をトラックするか？

407
00:22:52,239 --> 00:22:55,309
このメソッドが
最大限に活用されます

408
00:22:55,542 --> 00:23:00,047
制約の変更で
変えなければならないことを

409
00:22:55,542 --> 00:23:00,047
制約の変更で
変えなければならないことを

410
00:23:00,147 --> 00:23:04,418
１回の更新で
すべて完了させるのです

411
00:23:04,818 --> 00:23:09,289
パフォーマンスを最適化する
“set constant”のメソッドです

412
00:23:09,590 --> 00:23:11,792
最後は優先度についてです

413
00:23:12,359 --> 00:23:14,361
例えば こう言います

414
00:23:14,461 --> 00:23:18,198
“このビューは
幅100ポイントが理想だ”

415
00:23:18,298 --> 00:23:22,503
でも できるだけ狭くという
要件があったら―

416
00:23:22,903 --> 00:23:26,540
より多くの作業が発生します

417
00:23:26,640 --> 00:23:30,110
このような場合もあります

418
00:23:30,210 --> 00:23:34,882
“このビューは
幅100ポイント前後にしたい”

419
00:23:34,982 --> 00:23:36,984
“エラーはできるだけ小さく”

420
00:23:37,317 --> 00:23:38,786
こういった要件です

421
00:23:39,586 --> 00:23:43,323
エラーを最小限にする方法は？

422
00:23:43,423 --> 00:23:48,662
ビューがlayoutSubviewsの
一部としてエンジンに言います

423
00:23:48,762 --> 00:23:50,464
“変数の値は？”

424
00:23:50,564 --> 00:23:54,835
エンジンは最初に
エラーが最小限か確認します

425
00:23:55,302 --> 00:23:59,239
この部分の詳細については省き

426
00:23:59,339 --> 00:24:01,742
パフォーマンス特性について
説明します

427
00:23:59,339 --> 00:24:01,742
パフォーマンス特性について
説明します

428
00:24:01,842 --> 00:24:03,911
“超スゴイ”です

429
00:24:04,411 --> 00:24:06,180
興味が湧きましたか？

430
00:24:06,280 --> 00:24:09,683
単純な Xアルゴリズムを使います

431
00:24:09,783 --> 00:24:13,387
第二次世界大戦中に
書かれたものです

432
00:24:13,487 --> 00:24:15,289
コンピュータ発明以前です

433
00:24:17,324 --> 00:24:21,828
当時 このような
計算をする人々のことを

434
00:24:21,929 --> 00:24:23,831
“コンピュータ”と呼んでいました

435
00:24:23,931 --> 00:24:25,099
彼らは手計算です

436
00:24:25,199 --> 00:24:28,168
これが パフォーマンス特性です

437
00:24:28,268 --> 00:24:31,205
手計算でも早くできます

438
00:24:32,239 --> 00:24:35,509
“やっていることの本質は同じ”

439
00:24:35,642 --> 00:24:37,377
そう考えてください

440
00:24:38,145 --> 00:24:40,447
優先度を調整する場合―

441
00:24:40,547 --> 00:24:43,417
その程度の工数が発生します

442
00:24:44,084 --> 00:24:46,353
それ以外は同じです

443
00:24:47,855 --> 00:24:50,557
大切な話をしてきました

444
00:24:50,657 --> 00:24:54,394
Auto Layoutの
パフォーマンス特性を

445
00:24:54,495 --> 00:24:57,364
直感的に理解する上で重要です

446
00:24:57,498 --> 00:25:00,033
ここで要点を整理します

447
00:24:57,498 --> 00:25:00,033
ここで要点を整理します

448
00:25:00,134 --> 00:25:02,102
制約を“衝突”させない

449
00:25:02,202 --> 00:25:04,905
不必要な作業は意味がないので

450
00:25:05,005 --> 00:25:06,039
やめてください

451
00:25:06,273 --> 00:25:10,077
制約は
基礎代数を解くようなものです

452
00:25:10,177 --> 00:25:13,781
制約を追加したり
取り除いたり―

453
00:25:13,881 --> 00:25:17,751
“set constant”を呼ぶ時が
まさにそうです

454
00:25:18,385 --> 00:25:22,623
エラーを最小限にしたい時も
同様です

455
00:25:25,459 --> 00:25:29,196
Auto Layoutの機能は
レイアウトのキャッシュと同じです

456
00:25:29,296 --> 00:25:32,466
エンジンには
すべての値が保存されていて

457
00:25:32,566 --> 00:25:34,134
依存関係をトラックしています

458
00:25:34,234 --> 00:25:35,769
そのため変更があると

459
00:25:35,869 --> 00:25:39,573
その値だけを
的確に更新できます

460
00:25:39,773 --> 00:25:41,074
最後は―

461
00:25:41,175 --> 00:25:44,545
自分が必要な機能のみ
使ってください

462
00:25:45,145 --> 00:25:48,849
これまでの話は 直感の部分です

463
00:25:48,949 --> 00:25:52,786
残りの時間は
カシアに引き継ぎます

464
00:25:52,886 --> 00:25:56,690
直感だけに頼っては
うまくいかないからです

465
00:25:56,790 --> 00:25:59,193
いくつか分析を行い―

466
00:25:59,293 --> 00:26:02,296
直感を実践に結び付けます

467
00:25:59,293 --> 00:26:02,296
直感を実践に結び付けます

468
00:26:02,396 --> 00:26:04,331
お楽しみください

469
00:26:04,464 --> 00:26:11,305
(拍手)

470
00:26:11,405 --> 00:26:13,507
スライドをお願いします

471
00:26:14,007 --> 00:26:14,842
ありがとう

472
00:26:14,942 --> 00:26:19,947
私は iOS Keyboardsチームの
カシア･ヴァーヴァです

473
00:26:20,047 --> 00:26:25,419
今日は効率的な
レイアウト構築について説明します

474
00:26:26,186 --> 00:26:28,889
制約の衝突に戻ります

475
00:26:29,022 --> 00:26:32,326
制約を変更する時に
衝突が起こりますが

476
00:26:32,426 --> 00:26:34,962
実際のビューは
動かす必要がありません

477
00:26:35,095 --> 00:26:39,500
エンジンに余計な負荷がかかり
パフォーマンスに影響が出ます

478
00:26:39,600 --> 00:26:41,068
避けたい事態です

479
00:26:41,935 --> 00:26:46,907
この問題の要因と
回避方法を説明します

480
00:26:47,708 --> 00:26:51,245
これは
SNSのアプリケーションです

481
00:26:51,478 --> 00:26:54,014
アバタービューがあります

482
00:26:54,114 --> 00:26:55,849
そして タイトルと日付

483
00:26:55,949 --> 00:26:57,618
ログのエントリビュー

484
00:26:58,418 --> 00:27:00,954
ここにスペースが必要です

485
00:26:58,418 --> 00:27:00,954
ここにスペースが必要です

486
00:27:01,054 --> 00:27:04,858
サイズを決めて
いくらか調整も必要でしょう

487
00:27:05,492 --> 00:27:09,096
でもこれは
純粋なSNSではなく

488
00:27:09,196 --> 00:27:13,734
シェアするかどうかを
選ぶことができます

489
00:27:14,368 --> 00:27:18,305
そのため
オプションのビューがあります

490
00:27:18,839 --> 00:27:23,377
もちろん ネコの写真を
シェアできなくてはいけません

491
00:27:23,877 --> 00:27:26,213
そのためのレイアウトが必要です

492
00:27:26,713 --> 00:27:31,018
でも かわいい写真を
一人で楽しみたい人もいます

493
00:27:32,019 --> 00:27:35,656
そこで４つの似たレイアウトを
用意しました

494
00:27:35,756 --> 00:27:39,259
テーブルビューのセルを
画面に表示させたいので

495
00:27:39,359 --> 00:27:41,428
いくらか調整が必要です

496
00:27:41,929 --> 00:27:45,732
今 パフォーマンス改善に
取り組んでいるとします

497
00:27:45,833 --> 00:27:48,902
現在のスクロールの
パフォーマンスです

498
00:27:50,270 --> 00:27:53,874
下から上の動きに
引っかかりがあります

499
00:27:53,974 --> 00:27:58,078
このような場合
どうやって改善しますか？

500
00:27:58,545 --> 00:28:03,717
今日は 現在開発中の
新しい方法を紹介します

501
00:27:58,545 --> 00:28:03,717
今日は 現在開発中の
新しい方法を紹介します

502
00:28:03,817 --> 00:28:05,986
ベータ版では使えません

503
00:28:06,553 --> 00:28:07,855
でもご安心を

504
00:28:07,955 --> 00:28:10,724
あるツールを紹介します

505
00:28:11,959 --> 00:28:13,360
いいですね

506
00:28:13,460 --> 00:28:18,999
(拍手)

507
00:28:19,099 --> 00:28:22,369
喜んでもらえてうれしいです

508
00:28:22,469 --> 00:28:24,938
では 見てください

509
00:28:25,372 --> 00:28:29,309
最上段はCPUの使用量を示し

510
00:28:29,409 --> 00:28:31,745
問題の兆候を知らせます

511
00:28:31,845 --> 00:28:33,313
ここに山が多い場合は

512
00:28:33,413 --> 00:28:37,251
レイアウトに問題があると
示唆しています

513
00:28:37,484 --> 00:28:39,019
平らな場合は

514
00:28:39,119 --> 00:28:41,822
パフォーマンスの問題は
他にあるはずです

515
00:28:42,489 --> 00:28:46,126
この部分が
制約の衝突を知らせています

516
00:28:46,326 --> 00:28:48,395
このバーの高さが

517
00:28:48,495 --> 00:28:52,933
衝突の影響を受けている
ビューの数です

518
00:28:53,467 --> 00:28:56,537
その高さで影響度が分かります

519
00:28:57,838 --> 00:29:02,743
次が 制約の破棄と
変更の状況について

520
00:28:57,838 --> 00:29:02,743
次が 制約の破棄と
変更の状況について

521
00:29:03,143 --> 00:29:06,713
最後が UILabelと
テキストビューのサイズです

522
00:29:06,813 --> 00:29:09,616
ここでは UILabelと―

523
00:29:09,850 --> 00:29:12,553
別タイプのテキストビューも
分析しています

524
00:29:13,654 --> 00:29:17,224
先ほどのアプリケーションの
動きについて―

525
00:29:17,591 --> 00:29:18,992
何が分かるでしょうか

526
00:29:19,092 --> 00:29:23,363
CPUビューにある
いくつかの山の中で

527
00:29:23,464 --> 00:29:24,665
ここに注目します

528
00:29:24,765 --> 00:29:27,701
制約の衝突が
跳ね上がっているので

529
00:29:27,801 --> 00:29:29,236
問題がありそうです

530
00:29:29,870 --> 00:29:34,608
このビューの詳細が
下の画面で確認できます

531
00:29:34,708 --> 00:29:39,112
衝突の影響を受けている
ビューのリストです

532
00:29:39,513 --> 00:29:44,251
Superviewでグループ化すると
テーブルビューのセルの中で

533
00:29:44,351 --> 00:29:50,424
特定のコンテクストにおいて
衝突が起こっていると分かります

534
00:29:50,991 --> 00:29:56,330
この場合 アバタービューと
３つのラベルが衝突しています

535
00:29:57,197 --> 00:30:01,135
私がこの解析ツールを
走らせているので

536
00:29:57,197 --> 00:30:01,135
私がこの解析ツールを
走らせているので

537
00:30:01,235 --> 00:30:06,006
この３つが“タイトル”“日付”
“ログエントリ”だと分かります

538
00:30:06,940 --> 00:30:09,543
セルのビューの大部分です

539
00:30:09,710 --> 00:30:12,513
何が起きているのか見てみましょう

540
00:30:13,680 --> 00:30:15,749
この画面に戻ります

541
00:30:16,250 --> 00:30:18,418
コードを調べて

542
00:30:18,519 --> 00:30:21,922
updateConstraintsの
オーバーライドを確認します

543
00:30:22,389 --> 00:30:27,694
何か変更した時や
updateConstraintsの動作中は

544
00:30:27,795 --> 00:30:32,633
すべての制約を破棄し
必要に応じて戻します

545
00:30:33,767 --> 00:30:37,471
すべてを元の場所に戻しました

546
00:30:37,571 --> 00:30:41,942
一度破棄したことで
パフォーマンスが上がりました

547
00:30:42,409 --> 00:30:45,812
このインスタンスでは
ソーシャルアバターが―

548
00:30:45,913 --> 00:30:48,849
追加され 破棄されました

549
00:30:48,949 --> 00:30:50,918
あとは必要ありません

550
00:30:51,685 --> 00:30:54,054
この制約のビューを見ると

551
00:30:54,354 --> 00:30:59,193
このビュー以外には
影響がないと分かります

552
00:30:59,426 --> 00:31:01,762
ご存知だと思いますが―

553
00:30:59,426 --> 00:31:01,762
ご存知だと思いますが―

554
00:31:02,095 --> 00:31:05,165
これが“setHidden”と
呼ばれるものです

555
00:31:05,365 --> 00:31:09,303
周りのビューに
影響を与えないので

556
00:31:09,403 --> 00:31:11,472
制約はそのままです

557
00:31:11,572 --> 00:31:15,909
これはビューの表示を変更する
一番楽な方法です

558
00:31:16,009 --> 00:31:20,013
ビュー階層からやるより簡単です

559
00:31:20,114 --> 00:31:22,850
一方 画像ビューは
どうでしょう？

560
00:31:23,350 --> 00:31:24,985
説明しましょう

561
00:31:25,085 --> 00:31:28,422
こちらも
一度すべての制約を破棄して

562
00:31:28,522 --> 00:31:31,258
元々あった画像ビューを加えます

563
00:31:31,792 --> 00:31:35,662
すべて元の場所に戻るので
衝突が発生します

564
00:31:36,463 --> 00:31:38,031
このような状況では

565
00:31:38,131 --> 00:31:41,502
制約をグループ化して
考えてください

566
00:31:42,135 --> 00:31:45,005
緑線の部分が１グループです

567
00:31:46,106 --> 00:31:49,943
これらの制約は
すべてのレイアウト共通です

568
00:31:50,377 --> 00:31:53,914
変更しなくてよいビューで
表示を切り替えても

569
00:31:54,014 --> 00:31:55,616
アバタービューは動きません

570
00:31:55,716 --> 00:31:58,452
ログエントリのラベルが
長くなることを除いて

571
00:31:58,552 --> 00:32:01,155
他のラベルは動きません

572
00:31:58,552 --> 00:32:01,155
他のラベルは動きません

573
00:32:01,588 --> 00:32:05,692
緑線の制約は
ビュー作成時に追加して

574
00:32:06,126 --> 00:32:08,362
そのままにします

575
00:32:08,462 --> 00:32:10,931
触ってはいけません

576
00:32:11,899 --> 00:32:15,769
ここに 画像ビューに関する
４つの制約があります

577
00:32:15,869 --> 00:32:18,672
それらを配列に入れます

578
00:32:19,673 --> 00:32:23,944
画像がない時の制約も
入れましょう

579
00:32:24,044 --> 00:32:27,247
“imageConstraints”と
“noImageConstraints”で

580
00:32:27,347 --> 00:32:29,016
区別してください

581
00:32:29,183 --> 00:32:30,951
そして 次に―

582
00:32:31,051 --> 00:32:35,656
画像ビューを
入れたり外したりします

583
00:32:35,756 --> 00:32:37,858
レイアウトはどうなったでしょう

584
00:32:37,991 --> 00:32:40,861
画像が必要なければ
“noImageConstraints”

585
00:32:40,994 --> 00:32:43,096
必要なら“imageConstraints”を
有効にします

586
00:32:44,331 --> 00:32:45,866
画像がない場合

587
00:32:45,966 --> 00:32:49,970
他はすでに有効なので
追加する制約は１つです

588
00:32:50,070 --> 00:32:53,474
１つの制約ですが
両方の配列に入れます

589
00:32:53,574 --> 00:32:55,542
コードをシンプルにしたいからです

590
00:32:55,642 --> 00:32:59,012
配列か制約か
確認する必要がなく―

591
00:32:59,113 --> 00:33:01,115
常に制約の配列を扱います

592
00:32:59,113 --> 00:33:01,115
常に制約の配列を扱います

593
00:33:01,782 --> 00:33:02,916
よい方法です

594
00:33:03,951 --> 00:33:06,086
メリットを教えます

595
00:33:06,186 --> 00:33:10,023
このように制約を分析していて

596
00:33:10,124 --> 00:33:14,261
ユーザの前に画像を
ライブで出したいとします

597
00:33:14,728 --> 00:33:18,432
その場合
“imageConstraints”を有効にして

598
00:33:18,532 --> 00:33:21,401
アニメーションブロック内に
Layoutを呼び出せます

599
00:33:21,502 --> 00:33:23,670
するとアニメーションが動きます

600
00:33:24,037 --> 00:33:27,508
制約をすべて無効にして
それを戻しながら試せば―

601
00:33:28,542 --> 00:33:31,078
とても面白そうです

602
00:33:31,778 --> 00:33:37,050
さて デバッグが終わり
制約のグループを改修しています

603
00:33:37,151 --> 00:33:41,021
これは 先ほど見た画面です

604
00:33:41,622 --> 00:33:42,790
スクロールします

605
00:33:43,590 --> 00:33:44,258
ダメですね

606
00:33:44,358 --> 00:33:47,361
これが デバッグ後の画面です

607
00:33:48,862 --> 00:33:50,464
とてもスムーズです

608
00:33:51,432 --> 00:33:52,099
ありがとう

609
00:33:52,399 --> 00:33:53,967
(拍手)

610
00:33:54,068 --> 00:33:55,302
他にもあります

611
00:33:56,136 --> 00:33:58,272
これは iOS 11の映像です

612
00:33:58,739 --> 00:34:03,377
iOS 12の改良の影響は
受けていません

613
00:33:58,739 --> 00:34:03,377
iOS 12の改良の影響は
受けていません

614
00:34:03,710 --> 00:34:07,881
クライアントコードを
改善した結果です

615
00:34:08,215 --> 00:34:09,983
iOS 12でも すてきです

616
00:34:12,786 --> 00:34:14,888
本当にすばらしい

617
00:34:14,987 --> 00:34:15,822
(笑い声)

618
00:34:15,922 --> 00:34:16,924
(拍手)

619
00:34:17,024 --> 00:34:17,858
最高です

620
00:34:17,958 --> 00:34:20,226
(拍手)

621
00:34:20,327 --> 00:34:22,396
制約の衝突を回避するには？

622
00:34:23,096 --> 00:34:24,898
“制約をすべて削除しない”

623
00:34:24,998 --> 00:34:28,768
そうしないと
大量の制約を戻すことになります

624
00:34:28,869 --> 00:34:31,972
それにより
必要のないフレームや―

625
00:34:32,072 --> 00:34:35,976
再び表示されないビューに
中継することになります

626
00:34:36,743 --> 00:34:41,181
アプリケーションに共通の
制約のセットがあれば

627
00:34:41,281 --> 00:34:46,053
一度追加して動かさないことが
Interface Builderを使うコツです

628
00:34:46,587 --> 00:34:50,290
“制約の変更を不必要に行わない”

629
00:34:50,858 --> 00:34:52,793
これが大切です

630
00:34:52,893 --> 00:34:55,963
あと ビューを隠すという
裏ワザがあります

631
00:34:56,362 --> 00:34:58,732
削除するより合理的です

632
00:34:59,366 --> 00:35:01,435
ツールの
“Constraint churning”の下に

633
00:34:59,366 --> 00:35:01,435
ツールの
“Constraint churning”の下に

634
00:35:01,535 --> 00:35:04,571
“UILabel sizing”という
ビューがあります

635
00:35:05,105 --> 00:35:10,344
これはラベルが寸法の計測に
要する時間を示します

636
00:35:10,444 --> 00:35:12,512
今から“固有の寸法”について
説明します

637
00:35:13,814 --> 00:35:15,682
少し移動します

638
00:35:15,782 --> 00:35:19,419
すべてのビューに
固有の寸法が必要ではありません

639
00:35:20,621 --> 00:35:23,624
不可視の背景がある
ビューの場合は―

640
00:35:23,824 --> 00:35:28,262
その固有の寸法を返すため必要です

641
00:35:28,362 --> 00:35:29,830
２つ例をあげます

642
00:35:29,930 --> 00:35:33,434
まず UIImageViewは
画像サイズを使って

643
00:35:33,534 --> 00:35:35,636
画像の固有の寸法を測ります

644
00:35:35,736 --> 00:35:38,472
また UILabelは
テキストを計測し―

645
00:35:38,572 --> 00:35:41,241
その固有の寸法を返します

646
00:35:41,775 --> 00:35:45,279
固有の寸法は
魔法のようなものではなく

647
00:35:45,379 --> 00:35:48,282
UIViewから
制約を生成するために使います

648
00:35:48,382 --> 00:35:51,218
寸法の制約を作るだけです

649
00:35:51,485 --> 00:35:54,288
寸法をすべて制約で定義して

650
00:35:54,388 --> 00:35:55,923
面倒なことを省略できます

651
00:35:56,356 --> 00:35:59,626
まれに
オーバーライドされますが

652
00:35:59,727 --> 00:36:04,131
UIViewのサブクラス内で
起こることと同様です

653
00:35:59,727 --> 00:36:04,131
UIViewのサブクラス内で
起こることと同様です

654
00:36:04,231 --> 00:36:09,570
通常 スピードや正確性向上のため
オーバーライドされますが

655
00:36:09,670 --> 00:36:11,438
この場合は違います

656
00:36:12,005 --> 00:36:14,308
しかし オーバーライドが

657
00:36:14,408 --> 00:36:16,944
パフォーマンス向上に
貢献する場合があります

658
00:36:18,112 --> 00:36:20,214
テキスト測定は
時々工数がかかります

659
00:36:21,081 --> 00:36:23,984
でも このアプリケーションでは

660
00:36:24,084 --> 00:36:27,688
それほど時間がかかりませんでした

661
00:36:27,788 --> 00:36:31,458
だから その部分を
いじる必要はありません

662
00:36:31,558 --> 00:36:33,460
しかし テキストが多い場合は

663
00:36:33,560 --> 00:36:37,164
UILabelのテキスト測定に
時間がかかります

664
00:36:37,331 --> 00:36:40,200
それは 他のツールでも同じです

665
00:36:40,300 --> 00:36:43,871
何か情報があれば
役に立つかもしれません

666
00:36:45,038 --> 00:36:49,376
もし 計測しなくても
必要なサイズが分かれば

667
00:36:49,476 --> 00:36:52,179
そのサイズと
固有の寸法を返せます

668
00:36:52,646 --> 00:36:56,483
あるいは
ビューを画面に置こうとする時

669
00:36:56,583 --> 00:37:00,754
そのテキストのサイズを
制約が完全に定義します

670
00:36:56,583 --> 00:37:00,754
そのテキストのサイズを
制約が完全に定義します

671
00:37:00,854 --> 00:37:05,125
例えば テキストは
常に実際より長く定義されます

672
00:37:05,426 --> 00:37:07,427
そのため 幅と高さに対して

673
00:37:07,528 --> 00:37:10,898
固有の寸法を返す必要がありません

674
00:37:11,031 --> 00:37:12,666
親にこう言うのです

675
00:37:12,766 --> 00:37:16,169
“わざわざ寸法を
測らなくていいよ”

676
00:37:16,737 --> 00:37:20,240
自分で測定しない場合だけ
有効ですが―

677
00:37:20,708 --> 00:37:23,477
パフォーマンス改善に役立つ
可能性があります

678
00:37:23,577 --> 00:37:26,113
裏ワザとして知っておいてください

679
00:37:26,647 --> 00:37:31,618
“systemLayoutSizeFitting”も
忘れるわけにはいきません

680
00:37:32,653 --> 00:37:34,688
これらは相反するものですが―

681
00:37:35,355 --> 00:37:38,325
多くの人が混同して考えています

682
00:37:38,692 --> 00:37:40,828
“固有の寸法”は

683
00:37:40,928 --> 00:37:44,598
エンジンにサイズ情報を伝える
手段です

684
00:37:45,132 --> 00:37:46,934
“systemLayoutSizeFitting”は

685
00:37:47,034 --> 00:37:50,204
エンジンからサイズ情報を
受け取る手段です

686
00:37:50,304 --> 00:37:51,505
まさに正反対です

687
00:37:52,472 --> 00:37:55,409
これは 混合型レイアウトで
使われます

688
00:37:55,509 --> 00:37:58,011
Auto Layoutを使って
サブビューを操るビューから―

689
00:37:58,112 --> 00:38:00,981
フレーム情報を得る時などに
使います

690
00:37:58,112 --> 00:38:00,981
フレーム情報を得る時などに
使います

691
00:38:01,749 --> 00:38:05,552
頻繁でなくても
必要な時に使えます

692
00:38:05,686 --> 00:38:08,355
この使い方を教えます

693
00:38:08,555 --> 00:38:10,691
意外と厄介です

694
00:38:11,625 --> 00:38:14,194
“systemLayoutSizeFitting”を
呼び出すと

695
00:38:14,361 --> 00:38:15,829
エンジンが生成されます

696
00:38:16,029 --> 00:38:19,266
制約がエンジンに追加され
レイアウトができます

697
00:38:19,433 --> 00:38:22,770
トップビューフレームの
サイズが返されて―

698
00:38:23,303 --> 00:38:24,938
エンジンが破棄されます

699
00:38:25,572 --> 00:38:29,243
このメソッドでは 毎回エンジンが
生成され破棄されます

700
00:38:29,777 --> 00:38:33,080
これを何回もやっているなら―

701
00:38:33,180 --> 00:38:35,482
ロスタイムになっているかも
知れません

702
00:38:35,582 --> 00:38:38,986
“systemLayoutSizeFitting”を
呼ぶ時は気を付けてください

703
00:38:39,520 --> 00:38:45,426
時々 セルフサイジングセルや
テーブルビューのセルから

704
00:38:45,526 --> 00:38:48,095
コンテンツビューに
コールを転送している人がいます

705
00:38:48,262 --> 00:38:54,201
その場合 スクロールの最適化が
オーバーライドされていて

706
00:38:54,301 --> 00:38:56,036
余分なエンジンを追加しています

707
00:38:56,203 --> 00:39:00,374
スクロールに問題がある方は
確認してください

708
00:38:56,203 --> 00:39:00,374
スクロールに問題がある方は
確認してください

709
00:39:01,108 --> 00:39:03,644
次は 私の大好きなトピックです

710
00:39:03,744 --> 00:39:05,446
“Unsatisfiable Constraints”

711
00:39:06,146 --> 00:39:07,014
さて―

712
00:39:07,848 --> 00:39:10,117
“満足できない制約”とは？

713
00:39:10,217 --> 00:39:14,321
知らない方のために
どんな時に起こるか説明します

714
00:39:14,421 --> 00:39:17,324
“このビューの幅は50ポイント”

715
00:39:17,424 --> 00:39:19,326
“同時に200ポイントにもしたい”

716
00:39:19,793 --> 00:39:22,062
もちろん不可能です

717
00:39:22,162 --> 00:39:24,631
量子電話は存在しませんから

718
00:39:25,232 --> 00:39:27,267
未来は分かりませんけど

719
00:39:28,602 --> 00:39:33,374
そこで エンジンは
無効なレイアウトを計算して

720
00:39:33,474 --> 00:39:37,878
正しく生成するために
制約を破らなければなりません

721
00:39:38,512 --> 00:39:44,051
エンジンは 制約を破ると
詳細なログを送ってきて―

722
00:39:44,318 --> 00:39:45,619
こう言います

723
00:39:45,752 --> 00:39:49,022
“この制約が無効だから破ったよ”

724
00:39:49,356 --> 00:39:52,593
“この部分に影響が出たよ”

725
00:39:53,160 --> 00:39:55,162
パフォーマンスの低下や

726
00:39:55,262 --> 00:39:57,865
他の問題を
起こしているかもしれません

727
00:39:57,965 --> 00:39:59,933
デバッグが必要です

728
00:40:00,100 --> 00:40:03,570
Mysteries of Auto Layout,
Part ２に有益な情報があるので

729
00:40:03,771 --> 00:40:08,542
問題解決のために
ぜひ参考にしてください

730
00:40:09,677 --> 00:40:11,378
これで卒業です

731
00:40:11,478 --> 00:40:14,214
皆さんは
Auto Layoutのエキスパートです

732
00:40:14,648 --> 00:40:19,520
内部の動作について
楽しく学んでいただけたと思います

733
00:40:19,620 --> 00:40:23,090
制約の更新やプロセスについても

734
00:40:23,190 --> 00:40:25,225
理解が深まったでしょう

735
00:40:25,325 --> 00:40:29,329
サイズや優先度や不等式についても
学びました

736
00:40:29,463 --> 00:40:33,066
iOS 12では
レイアウトが高速になりました

737
00:40:33,367 --> 00:40:35,202
明日はラボにいます

738
00:40:35,302 --> 00:40:36,737
ご質問のある方はどうぞ

739
00:40:36,904 --> 00:40:39,973
こちらのリンクから
情報にアクセスできます

740
00:40:40,174 --> 00:40:41,575
この後もお楽しみください

741
00:40:41,675 --> 00:40:45,612
(拍手)