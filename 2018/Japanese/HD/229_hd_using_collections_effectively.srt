
1
00:00:07,074 --> 00:00:16,015
(音楽)

2
00:00:17,050 --> 00:00:21,221
(拍手)

3
00:00:21,922 --> 00:00:22,890
どうも

4
00:00:23,957 --> 00:00:27,961
私はコレクションの開発チームの
マイケルです

5
00:00:28,962 --> 00:00:32,131
今日はSwiftで
コレクションを使う際に

6
00:00:32,232 --> 00:00:35,936
知っておくべきポイントを
お話しします

7
00:00:37,070 --> 00:00:39,239
Swiftで使えるコレクションの

8
00:00:39,339 --> 00:00:43,644
いろいろな側面を
詳しく見ていきます

9
00:00:43,777 --> 00:00:47,948
よくある落とし穴や
その防ぎ方も紹介し

10
00:00:48,048 --> 00:00:52,886
コレクションを使う際の
特別なアドバイスもします

11
00:00:53,187 --> 00:00:53,887
始めましょう

12
00:00:54,988 --> 00:00:59,793
コレクションのない世界を
想像してください

13
00:01:01,795 --> 00:01:05,833
配列も存在しませんが
クマのbearはいます

14
00:01:07,067 --> 00:01:08,902
しかしbearごとに―

15
00:01:09,770 --> 00:01:15,375
自分で新しい変数を
定義しなければなりません

16
00:01:16,210 --> 00:01:17,511
大変ですね？

17
00:01:18,478 --> 00:01:21,748
さらに辞書もありません

18
00:01:22,416 --> 00:01:26,553
しかし関数を
回避策に使えます

19
00:01:26,787 --> 00:01:30,057
１回ずつ定義すればいいのです

20
00:01:30,657 --> 00:01:33,460
機能は辞書とほぼ同じです

21
00:01:33,560 --> 00:01:38,265
可変性はありませんが
可変状態は嫌ですよね

22
00:01:38,866 --> 00:01:41,602
しかし 現実は違います

23
00:01:42,302 --> 00:01:47,774
bearとコレクションが存在し
シンタックスもあります

24
00:01:49,543 --> 00:01:56,216
APIを使い 要素の反復や取得で
作業の繰り返しを避けられます

25
00:01:57,551 --> 00:02:01,488
コレクションは
Swiftの共通のプロトコルに

26
00:01:57,551 --> 00:02:01,488
コレクションは
Swiftの共通のプロトコルに

27
00:02:01,588 --> 00:02:03,857
すべて適合しています

28
00:02:04,992 --> 00:02:07,294
その名もコレクション

29
00:02:08,127 --> 00:02:12,266
要素が複数回 走査できる
シーケンスで

30
00:02:12,366 --> 00:02:16,036
サブスクリプトによって
アクセスできます

31
00:02:17,771 --> 00:02:21,942
どのように使うか
イメージで見ていきましょう

32
00:02:22,943 --> 00:02:27,948
これを ハッシュテーブルや
赤黒木などで定義された―

33
00:02:28,782 --> 00:02:31,118
配列としましょう

34
00:02:31,418 --> 00:02:35,856
これは開始インデックスの
サポートをします

35
00:02:36,757 --> 00:02:40,027
最初の要素にアクセスします

36
00:02:40,494 --> 00:02:43,630
終わりを示す
終了インデックスがあり

37
00:02:44,131 --> 00:02:48,602
最初から最後までの
反復機能をサポートします

38
00:02:49,403 --> 00:02:51,338
何度も使えるのです

39
00:02:51,438 --> 00:02:56,276
コレクションの要素を
検索するのにも役立ちます

40
00:02:57,411 --> 00:02:58,812
コードを見てみましょう

41
00:02:59,680 --> 00:03:04,117
要素のシーケンスとして
宣言されています

42
00:02:59,680 --> 00:03:04,117
要素のシーケンスとして
宣言されています

43
00:03:04,785 --> 00:03:09,256
また追加の関連型が
インデックスとされています

44
00:03:10,457 --> 00:03:14,361
これでサブスクリプトが
要素を読み出せ

45
00:03:14,661 --> 00:03:18,799
開始と終了のインデックスを
定義できます

46
00:03:18,899 --> 00:03:25,005
最後に index(after:)で
他のインデックスへ移動できます

47
00:03:25,539 --> 00:03:27,741
この機能は重要です

48
00:03:27,841 --> 00:03:30,244
標準ライブラリが

49
00:03:30,344 --> 00:03:35,315
プロトコル拡張を伴う 有用な
デフォルト動作を定義できます

50
00:03:35,415 --> 00:03:36,750
例をお見せします

51
00:03:38,385 --> 00:03:42,523
コレクションに適合すると
機能が増えます

52
00:03:42,623 --> 00:03:46,226
最初と最後の要素が得られたり

53
00:03:46,326 --> 00:03:50,097
カウントや空かどうかの
確認ができます

54
00:03:50,397 --> 00:03:54,635
4nシンタックスで反復できる
APIも使えます

55
00:03:55,302 --> 00:03:58,605
mapやfilter
reduceも使えるようになります

56
00:03:59,139 --> 00:04:02,809
では 独自のExtensionで
よりパワフルにしましょう

57
00:03:59,139 --> 00:04:02,809
では 独自のExtensionで
よりパワフルにしましょう

58
00:04:03,944 --> 00:04:06,647
コレクションで
要素の反復ができますが

59
00:04:06,747 --> 00:04:12,753
いくつかの要素をスキップして
１つおきに反復させたいとします

60
00:04:13,453 --> 00:04:15,889
これは拡張することで可能です

61
00:04:15,989 --> 00:04:17,658
メソッドシグネチャです

62
00:04:18,125 --> 00:04:23,530
１つおきに関数を呼び
要素をクロージャとします

63
00:04:24,064 --> 00:04:27,901
反復の範囲を決め
他の変数を求めます

64
00:04:28,001 --> 00:04:31,205
これを“start”で始めます

65
00:04:32,105 --> 00:04:35,509
現在の要素のクロージャを呼び

66
00:04:35,742 --> 00:04:37,811
次のインデックスへ進みます

67
00:04:37,911 --> 00:04:43,150
この時点でインデックスが
無効になっているか確認し

68
00:04:43,250 --> 00:04:46,220
もう一度インデックスを進めると

69
00:04:46,353 --> 00:04:48,255
要素を飛ばせます

70
00:04:48,355 --> 00:04:51,959
１から10までのレンジで実行すると

71
00:04:52,059 --> 00:04:54,495
飛ばしたのは偶数です

72
00:04:55,896 --> 00:04:59,433
これがコレクションの
すばらしい機能ですが

73
00:05:00,133 --> 00:05:03,871
我々には
別のプロトコルもあります

74
00:05:03,971 --> 00:05:07,574
Swiftでは様々なプロトコルが使え

75
00:05:07,674 --> 00:05:11,378
それぞれが進化を遂げています

76
00:05:11,678 --> 00:05:13,514
いくつか紹介しましょう

77
00:05:14,648 --> 00:05:18,685
インデックスを進める
コレクション以外に

78
00:05:19,586 --> 00:05:23,257
二方向性のコレクションがあります

79
00:05:24,825 --> 00:05:27,895
二方向性も
コレクションではあるので

80
00:05:27,995 --> 00:05:30,063
反復はできます

81
00:05:31,532 --> 00:05:35,269
無作為アクセスの
コレクションもあります

82
00:05:35,369 --> 00:05:40,007
これは 一定時間で
インデックス間の計算や

83
00:05:40,107 --> 00:05:44,244
その距離を計算する
要件を追加します

84
00:05:44,378 --> 00:05:50,083
コンパイラはこれを実行しないので
無作為アクセスに適合する時は

85
00:05:50,484 --> 00:05:52,686
自分で対応します

86
00:05:52,786 --> 00:05:57,558
どのインデックスにも
一定時間でアクセスできます

87
00:05:57,958 --> 00:06:00,294
もちろん無作為アクセスは残り

88
00:05:57,958 --> 00:06:00,294
もちろん無作為アクセスは残り

89
00:06:00,394 --> 00:06:02,963
前後に反復できます

90
00:06:04,298 --> 00:06:08,769
これらのプロトコルに適合した
便利なコレクションが多数あります

91
00:06:10,170 --> 00:06:12,439
配列や集合 辞書です

92
00:06:13,974 --> 00:06:17,044
この多目的な
プロトコルのおかげで

93
00:06:17,144 --> 00:06:21,815
データやレンジ
文字列などにも適合します

94
00:06:22,850 --> 00:06:26,520
コレクションに適合するだけで

95
00:06:26,620 --> 00:06:29,256
豊富な機能が使えるのです

96
00:06:29,356 --> 00:06:36,230
１つの型の使い方が分かったら
他の型にも当てはめられるのです

97
00:06:37,164 --> 00:06:40,801
では 型をコレクションに適合し

98
00:06:40,901 --> 00:06:44,538
インデックス化する方法について

99
00:06:46,340 --> 00:06:48,675
各コレクションのインデックスは

100
00:06:49,810 --> 00:06:51,645
Comparableである
必要があります

101
00:06:52,212 --> 00:06:56,517
配列のような場合は
整数の形を取りますが

102
00:06:56,617 --> 00:07:00,754
整数のように扱う必要はありません

103
00:06:56,617 --> 00:07:00,754
整数のように扱う必要はありません

104
00:07:01,355 --> 00:07:04,725
驚きの事実を
いくつか教えましょう

105
00:07:05,058 --> 00:07:07,528
まずは 配列の最初の要素です

106
00:07:08,562 --> 00:07:12,766
列をサブゼロにする人が
多いと思います

107
00:07:12,900 --> 00:07:14,568
インデックスはIntです

108
00:07:14,668 --> 00:07:19,506
この方法は使えますが
ベストではありません

109
00:07:19,640 --> 00:07:23,544
同じことを
違うコレクションでやりましょう

110
00:07:25,078 --> 00:07:26,713
集合の最初の要素は？

111
00:07:26,914 --> 00:07:30,684
変な質問ですね
集合に順番はないからです

112
00:07:30,951 --> 00:07:34,288
同時に 反復可能な
コレクションで

113
00:07:34,388 --> 00:07:37,591
反復する際は
１つの要素から始めます

114
00:07:37,691 --> 00:07:39,927
つまり質問はこうです

115
00:07:40,828 --> 00:07:42,362
サブゼロは使えますか？

116
00:07:42,963 --> 00:07:48,535
インデックス型はIntなので
コンパイラには却下され

117
00:07:48,902 --> 00:07:51,772
正しい型を要求されます

118
00:07:52,906 --> 00:07:54,608
すでにコレクションでの

119
00:07:54,708 --> 00:07:57,678
開始インデックスの付け方は
ご存知ですね

120
00:07:57,778 --> 00:08:01,315
これは すべてのコレクションで
使えます

121
00:07:57,778 --> 00:08:01,315
これは すべてのコレクションで
使えます

122
00:08:01,415 --> 00:08:06,720
開始インデックスは
反復の際に 最初に現れる要素です

123
00:08:06,920 --> 00:08:11,658
しかし これを利用する際の
注意点があります

124
00:08:12,926 --> 00:08:15,429
クラッシュの危険性です

125
00:08:16,063 --> 00:08:19,399
コレクションに中身がなければ

126
00:08:19,500 --> 00:08:22,736
インデックスを付けても
中は空です

127
00:08:23,504 --> 00:08:29,510
最初の要素に行くのは
もっといい方法があります

128
00:08:30,978 --> 00:08:32,513
firstを呼ぶだけです

129
00:08:32,846 --> 00:08:37,116
戻り型が任意で
この方が安全です

130
00:08:37,217 --> 00:08:40,320
最初の要素がない場合も使えます

131
00:08:42,389 --> 00:08:43,724
別の質問です

132
00:08:44,591 --> 00:08:46,293
２番目の要素は？

133
00:08:46,393 --> 00:08:48,095
今話しているのは

134
00:08:48,195 --> 00:08:52,032
配列でも集合でも
どのコレクションでもいいです

135
00:08:52,833 --> 00:08:56,770
拡張のプロパティを加え
secondとします

136
00:08:56,870 --> 00:09:01,275
firstの場合と同様 戻りは任意です

137
00:08:56,870 --> 00:09:01,275
firstの場合と同様 戻りは任意です

138
00:09:02,109 --> 00:09:06,613
では サブスクリプトの“１”と
しましょう

139
00:09:06,713 --> 00:09:12,352
しかし ０オリジンでは使えず
コンパイラに注意されます

140
00:09:13,820 --> 00:09:18,458
すべてのコレクションで
このコードを使いたければ

141
00:09:18,926 --> 00:09:20,627
別のやり方をします

142
00:09:21,161 --> 00:09:24,198
startIndex + 1ですが

143
00:09:25,599 --> 00:09:28,235
コンパイラに引っかかります

144
00:09:29,036 --> 00:09:34,408
不透明のインデックスに
“１”は付けられません

145
00:09:35,576 --> 00:09:40,280
APIを使ってこれを可能にします

146
00:09:40,380 --> 00:09:41,748
やってみましょう

147
00:09:42,616 --> 00:09:47,020
２番目の要素を
見つける指示をしました

148
00:09:47,154 --> 00:09:50,591
まずはコレクションが空かを
確認します

149
00:09:51,024 --> 00:09:54,695
開始と終了インデックスが
等しい時は空です

150
00:09:54,795 --> 00:09:56,997
そしてnilを返します

151
00:09:57,397 --> 00:10:01,268
２番目の要素がないからです

152
00:09:57,397 --> 00:10:01,268
２番目の要素がないからです

153
00:10:03,103 --> 00:10:06,473
このコレクションには
要素が１つしかありません

154
00:10:07,774 --> 00:10:11,445
２つ目の要素があれば
インデックスが使えます

155
00:10:11,545 --> 00:10:15,115
インデックスが有効か
確認すべきです

156
00:10:15,215 --> 00:10:19,720
しかし要素が１つの場合
無効なインデックスになり

157
00:10:19,820 --> 00:10:23,457
前のように
致命的なエラーになります

158
00:10:23,557 --> 00:10:26,093
そのため 有効にする前に

159
00:10:26,193 --> 00:10:30,430
前と同じ手順で確認し
nilを返します

160
00:10:30,531 --> 00:10:35,502
要素が１つのコレクションは
２番目の要素がないからです

161
00:10:35,969 --> 00:10:40,274
コレクションに
２つ以上の要素があれば

162
00:10:40,374 --> 00:10:43,143
安全にこのインデックスが使えます

163
00:10:43,844 --> 00:10:45,646
そして値も取得できます

164
00:10:47,147 --> 00:10:50,017
長いコードのようですが

165
00:10:50,117 --> 00:10:54,188
これは すべてのコレクションで
使えます

166
00:10:54,288 --> 00:10:58,492
しかし Swiftでは
もっといい方法があります

167
00:10:58,826 --> 00:11:00,494
それがスライスです

168
00:10:58,826 --> 00:11:00,494
それがスライスです

169
00:11:00,594 --> 00:11:05,532
まずは それがどういうものか
説明します

170
00:11:08,168 --> 00:11:12,306
スライスはコレクションの一部を
切り取る型です

171
00:11:13,173 --> 00:11:16,810
開始と終了インデックスがあり

172
00:11:17,077 --> 00:11:21,281
元のコレクションとは
別個に存在します

173
00:11:21,448 --> 00:11:27,020
スライスは容量を取らない
元のコレクションの参照です

174
00:11:27,754 --> 00:11:31,992
スライスは元のバッファを
読み込みます

175
00:11:32,759 --> 00:11:37,364
コレクションと同じインデックスを
使っているからです

176
00:11:37,464 --> 00:11:40,000
機能の仕方を見ましょう

177
00:11:40,100 --> 00:11:46,640
まず 最初の要素を落とし
要素が１つ少ないスライスにします

178
00:11:47,107 --> 00:11:51,645
開始インデックスの
次に進むよう指示すると

179
00:11:51,745 --> 00:11:55,382
それが２番目の
インデックスになります

180
00:11:55,482 --> 00:11:57,117
確かに同じですね

181
00:11:58,452 --> 00:12:03,156
dropFirstで簡単に
２番目の要素に行けます

182
00:11:58,452 --> 00:12:03,156
dropFirstで簡単に
２番目の要素に行けます

183
00:12:03,690 --> 00:12:07,461
では スライスがどれほど便利か
見てみましょう

184
00:12:08,629 --> 00:12:11,865
かつては複雑なコードが必要でした

185
00:12:12,766 --> 00:12:17,671
長いインデックスを
dropFirstで置き換えられます

186
00:12:17,938 --> 00:12:20,040
最初の戻りは任意なので

187
00:12:20,874 --> 00:12:24,745
空や１つの要素のコレクションでも
使えます

188
00:12:25,045 --> 00:12:26,713
結果を見てみましょう

189
00:12:27,614 --> 00:12:31,485
配列の最初の要素を
切り落としました

190
00:12:32,352 --> 00:12:35,189
そしてスライス内に記述し

191
00:12:35,622 --> 00:12:39,793
コレクションから
要素を取り出しました

192
00:12:39,893 --> 00:12:42,796
断然この方が楽ですよね

193
00:12:44,865 --> 00:12:48,402
スライスは 型ごとに
定義付けられます

194
00:12:48,602 --> 00:12:50,270
例えば 配列では

195
00:12:50,370 --> 00:12:54,775
最も一般的な
ArraySliceを定義します

196
00:12:54,875 --> 00:12:58,712
文字列も同様に―

197
00:12:58,946 --> 00:13:02,649
最も一般的なSubstringです

198
00:12:58,946 --> 00:13:02,649
最も一般的なSubstringです

199
00:13:03,283 --> 00:13:05,552
集合のような型では

200
00:13:05,953 --> 00:13:09,189
一般的なスライスの型を使います

201
00:13:09,289 --> 00:13:11,658
集合には順番がないからです

202
00:13:11,758 --> 00:13:16,163
基本的に開始と終了インデックスが
必要です

203
00:13:16,830 --> 00:13:20,133
データやレンジには
独自のスライスがあり

204
00:13:20,267 --> 00:13:22,636
選択肢は様々です

205
00:13:22,903 --> 00:13:26,173
スライスについて もう１つ

206
00:13:27,674 --> 00:13:32,446
何千もの要素がある
巨大なコレクションから

207
00:13:33,113 --> 00:13:35,749
いくつかをスライスで切り出します

208
00:13:36,583 --> 00:13:43,457
ただし スライスをしても
元のコレクションは生きています

209
00:13:43,557 --> 00:13:46,693
そのために問題も起きます

210
00:13:48,061 --> 00:13:51,431
例えば dropLastを使った―

211
00:13:51,532 --> 00:13:55,502
配列の前半を戻す
Extensionがあるとします

212
00:13:55,836 --> 00:14:00,841
８つの数字の配列があり
Extensionを呼びスライスします

213
00:13:55,836 --> 00:14:00,841
８つの数字の配列があり
Extensionを呼びスライスします

214
00:14:00,941 --> 00:14:04,011
そして元の
８つのストレージを消して

215
00:14:04,111 --> 00:14:06,380
この配列を空にします

216
00:14:07,481 --> 00:14:13,120
最初の要素を求めると
興味深いことが起きます

217
00:14:13,487 --> 00:14:17,424
元のストレージを
空にしたにもかかわらず

218
00:14:17,524 --> 00:14:19,393
１を返せるのです

219
00:14:19,493 --> 00:14:22,629
コピーされたのでしょうか

220
00:14:23,230 --> 00:14:30,070
バッファを消去したかったのに
残っていたとしたら 魔法ですね

221
00:14:30,170 --> 00:14:35,375
完全に消去するには
スライスから配列をコピーします

222
00:14:35,809 --> 00:14:40,614
そのスライスを空にしても
コピーは成立します

223
00:14:41,381 --> 00:14:42,482
見てみましょう

224
00:14:43,183 --> 00:14:47,588
まずは配列の
前半をスライスします

225
00:14:49,823 --> 00:14:53,760
コピーをした上で配列を空にします

226
00:14:53,861 --> 00:14:56,730
そしてスライスも空にします

227
00:14:57,731 --> 00:14:59,466
元のストレージが消えました

228
00:15:01,134 --> 00:15:04,104
遅延コピーと似ています

229
00:15:04,204 --> 00:15:07,741
コピーのタイミングを
指定できるのです

230
00:15:08,242 --> 00:15:14,414
このように遅延であることが
別のところで役立ちます

231
00:15:15,482 --> 00:15:17,818
例えば関数の呼び出しです

232
00:15:18,719 --> 00:15:21,622
Swiftでは先行となります

233
00:15:21,989 --> 00:15:26,393
出入力があると
すぐに処理されるのです

234
00:15:27,227 --> 00:15:30,531
この例では
１から4000のレンジから始めます

235
00:15:30,631 --> 00:15:33,734
非常に簡潔な数字の表示方法で

236
00:15:33,834 --> 00:15:37,004
最初と最後を指定するだけです

237
00:15:37,237 --> 00:15:39,640
各要素に２を掛けて
マッピングすると

238
00:15:39,740 --> 00:15:42,609
4000の要素に割り当てられます

239
00:15:42,709 --> 00:15:45,913
各要素がマッピングされました

240
00:15:46,346 --> 00:15:48,415
４つの要素にフィルタします

241
00:15:48,782 --> 00:15:52,753
4004が
割り当てられたことになります

242
00:15:53,187 --> 00:15:55,255
4004の要素分の容量ですが―

243
00:15:56,123 --> 00:15:58,025
必要なのは４つだけです

244
00:16:00,394 --> 00:16:04,331
これには面倒な計算が介在します

245
00:16:04,698 --> 00:16:08,602
必要最低限に抑えられれば
一番いいですね

246
00:16:10,270 --> 00:16:13,440
Swiftではlazyを使います

247
00:16:14,708 --> 00:16:19,780
先ほどのようにレンジを選び
lazyにします

248
00:16:19,880 --> 00:16:25,786
lazyのコレクションで
元のコレクションをラップしました

249
00:16:25,919 --> 00:16:30,791
そして 演算を実行すると
またラップするのです

250
00:16:30,891 --> 00:16:34,228
これをマップしても できません

251
00:16:34,328 --> 00:16:38,031
このクロージャは
手を加えられません

252
00:16:38,465 --> 00:16:43,704
lazyのマップコレクションは
フィルタしてもラップされるだけ

253
00:16:43,804 --> 00:16:46,740
あとで 要求時に
フィルタされます

254
00:16:47,774 --> 00:16:51,778
このLazyFilterCollectionの
要素は？

255
00:16:55,482 --> 00:17:00,387
まず LazyFilterCollectionに
最初の要素を要求します

256
00:16:55,482 --> 00:17:00,387
まず LazyFilterCollectionに
最初の要素を要求します

257
00:17:00,654 --> 00:17:02,456
しかし認識しません

258
00:17:02,890 --> 00:17:06,460
そこでLazyMapCollectionに
同じ要求をしますが

259
00:17:06,560 --> 00:17:10,030
これも最初の要素を認識しません

260
00:17:10,130 --> 00:17:14,134
しかしコレクションのラップで
レンジが認識します

261
00:17:14,835 --> 00:17:17,404
最初の要素である値“１”を

262
00:17:17,503 --> 00:17:19,573
LazyMapCollectionに返します

263
00:17:19,673 --> 00:17:25,279
クロージャを実行し
値“２”が計算できるようになり

264
00:17:25,378 --> 00:17:29,082
LazyFilterCollectionに
最初の要素を返せます

265
00:17:29,249 --> 00:17:32,286
幸いなことに
２は10より小さいので

266
00:17:32,386 --> 00:17:35,889
最初の要素を見つけられるのです

267
00:17:36,223 --> 00:17:37,758
これを発信元に戻します

268
00:17:38,959 --> 00:17:40,961
計算だらけですね

269
00:17:41,395 --> 00:17:45,766
lazyは要求時にのみ
計算しますが

270
00:17:45,966 --> 00:17:48,969
中間ストレージを作成しません

271
00:17:49,369 --> 00:17:50,904
例を見せましょう

272
00:17:52,306 --> 00:17:54,741
様々なクマがいる配列です

273
00:17:55,242 --> 00:17:59,046
中にはクマが重複しています

274
00:17:59,379 --> 00:18:02,349
クマだと繰り返す必要はありません

275
00:17:59,379 --> 00:18:02,349
クマだと繰り返す必要はありません

276
00:18:03,283 --> 00:18:09,723
重複したクマ見つけるため
lazy.filterを使うと

277
00:18:10,791 --> 00:18:16,430
文字列をラップする
lazyFilterCollectionができます

278
00:18:16,663 --> 00:18:22,169
反復させたいクマを出力し
条件を確認します

279
00:18:22,269 --> 00:18:26,206
firstというフィルタを使います

280
00:18:26,306 --> 00:18:29,176
この際 lazyFilterCollectionに
従います

281
00:18:30,144 --> 00:18:34,882
lazyFilterCollectionは
元のストレージに従い

282
00:18:36,383 --> 00:18:38,151
“Grizzly”を出力します

283
00:18:40,587 --> 00:18:46,393
“Grizzly”に“bear”は含まれず
falseなので

284
00:18:47,261 --> 00:18:48,428
“Panda”に進みます

285
00:18:50,764 --> 00:18:53,233
“Panda”を出力し

286
00:18:53,834 --> 00:18:57,237
“bear”を含むか確認し
“Spectacled”に進みます

287
00:18:57,938 --> 00:19:03,043
“Spectacled”もないので
“Gummy Bears”に進みます

288
00:18:57,938 --> 00:19:03,043
“Spectacled”もないので
“Gummy Bears”に進みます

289
00:19:03,544 --> 00:19:05,979
これは含まれていました

290
00:19:06,613 --> 00:19:10,951
lazyFilterCollectionは
発信元に返します

291
00:19:11,952 --> 00:19:14,154
firstをまた呼んだら？

292
00:19:15,189 --> 00:19:15,889
すると―

293
00:19:17,558 --> 00:19:20,460
同様に
lazyFilterCollectionが

294
00:19:20,561 --> 00:19:26,166
元のコレクションに従って
計算を繰り返します

295
00:19:27,935 --> 00:19:34,208
このように 計算を
繰り返させる必要がある場合は

296
00:19:34,508 --> 00:19:36,743
反復を１度にできます

297
00:19:37,844 --> 00:19:43,951
nonlazyのコレクションを作れば
反復は１度になります

298
00:19:44,351 --> 00:19:47,554
同じくlazyのコレクションに
従いますが

299
00:19:47,654 --> 00:19:52,059
反復は元のコレクション全体で
行われます

300
00:19:53,727 --> 00:19:57,598
そしてnonlazy版ができます

301
00:19:57,931 --> 00:20:01,068
“Gummy Bears”を含む
配列に行き

302
00:19:57,931 --> 00:20:01,068
“Gummy Bears”を含む
配列に行き

303
00:20:01,468 --> 00:20:03,470
最初の要素を選びます

304
00:20:03,570 --> 00:20:06,073
クロージャを参照しなくてよく

305
00:20:06,173 --> 00:20:09,643
遅延ではなく
先行の配列となります

306
00:20:11,845 --> 00:20:13,313
では遅延の利点は？

307
00:20:14,081 --> 00:20:18,485
マップやフィルタの
オーバーヘッドを避けられます

308
00:20:18,585 --> 00:20:22,656
コレクションの計算の
一部が欲しい時に便利です

309
00:20:23,257 --> 00:20:27,060
クロージャに
影響がある場合は

310
00:20:27,161 --> 00:20:29,296
使うのは避けましょう

311
00:20:29,797 --> 00:20:31,732
APIの範囲をまたぐ時は

312
00:20:31,832 --> 00:20:35,903
標準的なコレクションに
落とし込みましょう

313
00:20:36,103 --> 00:20:38,405
lazyは実装の詳細なのです

314
00:20:39,973 --> 00:20:43,877
可変コレクションで
様々なことが可能でしたが

315
00:20:44,945 --> 00:20:47,948
Swiftは
コレクションも可変的にします

316
00:20:49,049 --> 00:20:52,152
さらに２種類の
コレクションを紹介します

317
00:20:53,120 --> 00:20:55,289
まずは可変コレクション

318
00:20:55,956 --> 00:21:00,260
セッターを加えると
長さを変えず 一定時間で

319
00:20:55,956 --> 00:21:00,260
セッターを加えると
長さを変えず 一定時間で

320
00:21:00,360 --> 00:21:02,396
中身を変えられます

321
00:21:05,566 --> 00:21:10,404
次はレンジ交換可能コレクション

322
00:21:10,504 --> 00:21:14,541
要素を外したり
挿入する際に使います

323
00:21:16,043 --> 00:21:18,946
いつも聞かれる質問があります

324
00:21:20,347 --> 00:21:23,083
完璧なコードが
なぜクラッシュするのか？

325
00:21:23,784 --> 00:21:27,521
いい問いには 質問で返します

326
00:21:28,322 --> 00:21:30,991
“何をしようとしたのか？”

327
00:21:31,792 --> 00:21:34,962
“コレクションを
どう使ったのか？”

328
00:21:35,062 --> 00:21:38,766
“複数のスレッドから
アクセスしなかったか？”

329
00:21:38,966 --> 00:21:41,668
これらの質問の回答が―

330
00:21:42,402 --> 00:21:45,239
問題の根につながっています

331
00:21:45,973 --> 00:21:50,744
まず スレッドが原因でない場合を
検討しましょう

332
00:21:52,079 --> 00:21:53,680
ここに配列があり

333
00:21:53,781 --> 00:21:58,452
要素“E”の
インデックスがあります

334
00:21:58,652 --> 00:22:01,488
最初の要素を取り
コレクションを変更します

335
00:21:58,652 --> 00:22:01,488
最初の要素を取り
コレクションを変更します

336
00:22:02,623 --> 00:22:05,859
関連する要素を出力します

337
00:22:06,260 --> 00:22:10,397
これは 致命的なエラーになります

338
00:22:11,999 --> 00:22:13,133
インデックスは

339
00:22:13,233 --> 00:22:17,304
コレクションを変更した時点で
無効になります

340
00:22:18,906 --> 00:22:22,176
最初にコレクションを変更してから

341
00:22:22,276 --> 00:22:24,745
インデックスをするべきです

342
00:22:26,513 --> 00:22:30,684
変更でインデックスが
無効になるからです

343
00:22:31,051 --> 00:22:34,221
辞書ではどうなるか見ましょう

344
00:22:34,955 --> 00:22:38,325
クマの好物の辞書があるとします

345
00:22:39,092 --> 00:22:44,164
好きな食べ物を出力し
魚のsalmonだと確認します

346
00:22:45,199 --> 00:22:50,771
さらに好物を加えても
salmonのままとします

347
00:22:51,138 --> 00:22:55,542
しかし 冬眠の
hybernationになってしまいました

348
00:22:57,077 --> 00:23:00,848
インデックスが無効になったのです

349
00:22:57,077 --> 00:23:00,848
インデックスが無効になったのです

350
00:23:01,381 --> 00:23:04,218
コードがクラッシュします

351
00:23:05,085 --> 00:23:06,720
では修正方法は？

352
00:23:07,654 --> 00:23:13,627
配列と同じで 変更のあと
インデックスを計算し直すのです

353
00:23:14,194 --> 00:23:18,766
注意すべきは 再計算は
時に高くつくことです

354
00:23:18,866 --> 00:23:22,002
インデックスによって
サーチは線形時間なので

355
00:23:22,336 --> 00:23:25,205
必要な箇所のみをサーチしましょう

356
00:23:26,807 --> 00:23:30,177
そこで 私からのアドバイスです

357
00:23:30,377 --> 00:23:33,814
“変更でインデックスが無効”

358
00:23:33,914 --> 00:23:40,087
これを鉄則として覚えておけば
落ち着いて対応できます

359
00:23:40,854 --> 00:23:43,490
またスライスは
変更があっても

360
00:23:43,590 --> 00:23:46,793
元のコレクションを引き継ぎます

361
00:23:46,894 --> 00:23:52,866
可変コレクションの際は
くれぐれも注意しましょう

362
00:23:53,767 --> 00:23:58,138
またインデックスの計算は
時に時間がかかるので

363
00:23:59,139 --> 00:24:01,708
必要な箇所だけにしましょう

364
00:23:59,139 --> 00:24:01,708
必要な箇所だけにしましょう

365
00:24:02,976 --> 00:24:05,579
次にスレッドの話です

366
00:24:05,746 --> 00:24:10,617
あなたのスレッドは
複数のスレッドから見えますか？

367
00:24:11,652 --> 00:24:16,657
我々のコレクションは
１つのスレッドを想定しています

368
00:24:17,591 --> 00:24:20,260
パフォーマンス面で有利だからです

369
00:24:20,627 --> 00:24:23,864
単独スレッドなら
ロックなどの―

370
00:24:23,964 --> 00:24:29,403
排他制御による負担を
心配することはありません

371
00:24:30,204 --> 00:24:35,375
コレクションのデベロッパのみが
ロックや直列キューで

372
00:24:35,475 --> 00:24:36,910
スレッドを制御できます

373
00:24:37,010 --> 00:24:41,248
フレームワークより
高い抽象化レベルでです

374
00:24:42,616 --> 00:24:44,685
この問題を見てみましょう

375
00:24:45,452 --> 00:24:48,689
sleepingBearsで配列を
埋めるとします

376
00:24:49,256 --> 00:24:55,362
各クマを独自のクマとし
DispatchQueueにアクセスします

377
00:24:56,196 --> 00:24:58,298
クマに寝るよう指示します

378
00:24:58,899 --> 00:25:03,771
並列なのでコードが
同時に走ってるとイメージできます

379
00:24:58,899 --> 00:25:03,771
並列なのでコードが
同時に走ってるとイメージできます

380
00:25:03,871 --> 00:25:06,306
横に並べてシミュレートします

381
00:25:07,107 --> 00:25:10,144
アプリケーションで
クマを確認しましょう

382
00:25:11,211 --> 00:25:14,781
みんなが眠ってるかもしれませんし

383
00:25:15,048 --> 00:25:18,886
Grandpaより
Cubが先に寝るのかも

384
00:25:19,386 --> 00:25:22,523
Grandpaだけが
寝てる時もあります

385
00:25:23,791 --> 00:25:25,792
Cubだけの時も

386
00:25:26,560 --> 00:25:30,597
クラッシュした時は
誰も寝ていません

387
00:25:32,132 --> 00:25:35,002
これは競合状態がある可能性を示し

388
00:25:35,102 --> 00:25:40,507
関係あるすべてのスレッドが
関わっているようです

389
00:25:41,074 --> 00:25:45,445
確かめるには
XcodeにあるTSanが使えます

390
00:25:45,612 --> 00:25:49,216
アウトプットはこのようになります

391
00:25:49,750 --> 00:25:56,857
TSanが競合を割り出し
関連するスレッドを教えてくれます

392
00:25:57,558 --> 00:26:01,528
どの列から手をつければいいか
教えます

393
00:25:57,558 --> 00:26:01,528
どの列から手をつければいいか
教えます

394
00:26:02,329 --> 00:26:06,800
バグを見つけるのに
とても便利です

395
00:26:06,900 --> 00:26:11,538
バグの箇所に関して
TSanはウソをつきません

396
00:26:12,639 --> 00:26:16,743
クマが同時に寝る条件を消すのを

397
00:26:16,844 --> 00:26:18,912
直列ディスパッチキューで行います

398
00:26:19,746 --> 00:26:21,748
順番に寝るようになりました

399
00:26:21,949 --> 00:26:27,187
キューの並びに注意しながら
sleepingBearsを見にいくと

400
00:26:27,955 --> 00:26:32,426
GranpaとCubが
仲良く寝ています

401
00:26:34,161 --> 00:26:40,234
単独のスレッドからだけ見えるよう
データを隔離しましょう

402
00:26:40,467 --> 00:26:44,571
それができない場合は
排他制御をしましょう

403
00:26:44,671 --> 00:26:47,074
直列ディスパッチキューや
ロックです

404
00:26:47,741 --> 00:26:50,644
そしてTSanで二重チェックします

405
00:26:50,744 --> 00:26:54,548
バグは リリース前に
発見すべきですよね

406
00:26:55,782 --> 00:26:58,385
さらに可変コレクションの話を

407
00:26:59,753 --> 00:27:03,791
できれば
可変状態の使用を避けましょう

408
00:26:59,753 --> 00:27:03,791
できれば
可変状態の使用を避けましょう

409
00:27:04,358 --> 00:27:08,729
今までお話しした面倒を
避けるためです

410
00:27:08,829 --> 00:27:13,400
可変コレクションを避けることで
まず回避できます

411
00:27:13,834 --> 00:27:18,405
スライスや
lazyのラップを使えば

412
00:27:18,639 --> 00:27:23,277
データを変更したかのように
処理できます

413
00:27:24,177 --> 00:27:30,484
可変状態になっている場合には
コンパイラが教えてくれます

414
00:27:32,686 --> 00:27:37,691
可変状態を使う際の
アドバイスをもう１つ

415
00:27:38,826 --> 00:27:40,427
新規のコレクション作成で

416
00:27:40,527 --> 00:27:44,231
先に 要素の正確な数
または―

417
00:27:44,565 --> 00:27:47,601
おおよその数が
分かれば便利です

418
00:27:47,701 --> 00:27:51,038
APIの多くはそのヒントをくれ

419
00:27:51,138 --> 00:27:54,274
正確なサイズを教えてくれるのです

420
00:27:54,374 --> 00:27:57,611
他にも同様のツールがあり

421
00:27:58,011 --> 00:27:59,580
様々なケースで使えます

422
00:27:59,680 --> 00:28:05,552
要素を追加したい時
容量を超えることがありますが

423
00:27:59,680 --> 00:28:05,552
要素を追加したい時
容量を超えることがありますが

424
00:28:06,120 --> 00:28:09,356
多めに見積もらなくても済みます

425
00:28:09,456 --> 00:28:13,660
いつ容量を増やすべきかが
分かるからです

426
00:28:14,995 --> 00:28:17,731
今日最後の話題に移ります

427
00:28:18,832 --> 00:28:25,472
広範囲なコレクションが
Foundationで可能になります

428
00:28:27,274 --> 00:28:30,144
Foundationをインポートすれば

429
00:28:30,244 --> 00:28:35,349
従来からあるObjective-Cの
参照型が使えるようになります

430
00:28:36,316 --> 00:28:38,652
多くはSwiftに適応し

431
00:28:38,752 --> 00:28:41,989
他のコレクションと
同様に機能します

432
00:28:42,256 --> 00:28:44,691
いくつか注意点があります

433
00:28:45,993 --> 00:28:50,430
まずは これらが
参照型であることです

434
00:28:50,531 --> 00:28:53,000
例を挙げましょう

435
00:28:53,600 --> 00:28:57,871
値型と参照型を決め
両方で同じことをします

436
00:28:58,305 --> 00:29:01,775
この値型“x”は文字列の配列で

437
00:28:58,305 --> 00:29:01,775
この値型“x”は文字列の配列で

438
00:29:02,409 --> 00:29:04,845
空の配列“x”となります

439
00:29:04,945 --> 00:29:08,916
参照型では “x”が
空の配列を指しています

440
00:29:09,950 --> 00:29:14,488
次に インラインで
配列を値型に変更します

441
00:29:14,721 --> 00:29:18,091
参照型でも 参照される配列が

442
00:29:18,192 --> 00:29:20,861
インラインで変更されます

443
00:29:21,295 --> 00:29:25,365
別の変数を足すと
値型で何かが起こります

444
00:29:25,465 --> 00:29:27,234
コピーせずに

445
00:29:27,334 --> 00:29:31,805
このストレージが
“x”に属すと分かったのです

446
00:29:32,539 --> 00:29:36,243
参照型でも同じことが
起きるのでしょうか？

447
00:29:36,610 --> 00:29:41,949
参照型では違って
“y”は同じ配列を示すだけです

448
00:29:42,983 --> 00:29:46,019
次に“y”を違うクマに変えます

449
00:29:46,120 --> 00:29:52,092
値型では“y”に書き込むために
まずはコピーして―

450
00:29:53,227 --> 00:29:54,828
違うクマを挿入します

451
00:29:56,296 --> 00:30:01,301
参照型では 単純に配列を１つにし
パンダを入れます

452
00:29:56,296 --> 00:30:01,301
参照型では 単純に配列を１つにし
パンダを入れます

453
00:30:03,303 --> 00:30:09,042
FoundationをSwiftで使う際の
２つ目の注意点は

454
00:30:09,476 --> 00:30:14,915
Objective-CのAPIは
値型として現れることです

455
00:30:15,015 --> 00:30:20,454
おかげで両方の言語で
コードがうまく機能します

456
00:30:20,954 --> 00:30:25,292
実装方法が異なる
２言語間で機能できるのは

457
00:30:26,393 --> 00:30:29,163
ブリッジ機能があるからです

458
00:30:29,496 --> 00:30:33,033
２つの異なるランタイム表現を
変換します

459
00:30:33,133 --> 00:30:35,969
SwiftとObjective-Cとでは

460
00:30:36,270 --> 00:30:41,542
コンパイラもランタイムも
異なりますからね

461
00:30:42,342 --> 00:30:46,346
ブリッジ変換は最適化され
高速ですが―

462
00:30:46,447 --> 00:30:49,750
必ず その代償があります

463
00:30:50,884 --> 00:30:52,386
見てみましょう

464
00:30:52,820 --> 00:30:56,523
まず同等のストレージを確保します

465
00:30:56,623 --> 00:31:00,961
１言語で“n”であれば
もう１つでも“n”にします

466
00:30:56,623 --> 00:31:00,961
１言語で“n”であれば
もう１つでも“n”にします

467
00:31:01,094 --> 00:31:03,931
次に要素ごとに変換します

468
00:31:04,298 --> 00:31:07,468
このブリッジは
再帰的な時もあります

469
00:31:07,568 --> 00:31:12,706
文字列の配列ですと
先に配列 次に文字列を変換します

470
00:31:13,907 --> 00:31:17,644
２言語の境界での変換は
先行ブリッジと呼ばれ

471
00:31:18,779 --> 00:31:23,851
要素の変換が必要な際に
先行して行われます

472
00:31:24,084 --> 00:31:27,588
これは辞書で頻繁に起こります

473
00:31:28,755 --> 00:31:31,525
先行でなければ
遅延と呼びます

474
00:31:31,692 --> 00:31:36,296
要素の型自体が
変換されない場合です

475
00:31:36,463 --> 00:31:41,001
コレクションが使用されるまで
保留されます

476
00:31:41,401 --> 00:31:42,970
例で説明しましょう

477
00:31:43,604 --> 00:31:47,307
Objective-CのAPIで
NSArrayを書きます

478
00:31:47,775 --> 00:31:51,912
NSArrayは配列に
NSDataは値型に変換されます

479
00:31:52,012 --> 00:31:54,715
これらの変換は先行されます

480
00:31:55,649 --> 00:32:00,487
NSViewはSwiftに変換されないため

481
00:31:55,649 --> 00:32:00,487
NSViewはSwiftに変換されないため

482
00:32:00,587 --> 00:32:04,191
NSViewのNSArrayは
遅延変換となります

483
00:32:04,324 --> 00:32:08,462
最初のアクセスまで
ブリッジ変換されません

484
00:32:10,731 --> 00:32:16,603
NSDictionaryのキーが
NSStringなら先行です

485
00:32:17,337 --> 00:32:21,608
文字列はSwiftで
値型として認識されるからです

486
00:32:22,242 --> 00:32:27,681
ブリッジ変換を理解したところで
最も重要なことは

487
00:32:28,015 --> 00:32:33,554
アプリケーションに悪影響が
ある際に使うべきという点です

488
00:32:35,856 --> 00:32:38,458
Instrumentsの
Time Profilerなどを使う時

489
00:32:38,559 --> 00:32:44,364
言語間のどこで
コードが交わるかに注意しましょう

490
00:32:44,898 --> 00:32:47,434
ブリッジがあっても大丈夫です

491
00:32:47,534 --> 00:32:51,939
問題は bridgeを含む
自分が書いていないコードで

492
00:32:52,039 --> 00:32:55,409
膨大な時間を要している場合です

493
00:32:56,443 --> 00:32:57,978
例で説明します

494
00:32:58,779 --> 00:33:01,448
童話の原稿があって

495
00:32:58,779 --> 00:33:01,448
童話の原稿があって

496
00:33:01,548 --> 00:33:06,186
長いので一部だけ表示し
ポップさせます

497
00:33:07,120 --> 00:33:11,792
単語のインスタンスを
全部 茶色にし―

498
00:33:12,092 --> 00:33:14,828
最初の単語だけハイライトします

499
00:33:16,330 --> 00:33:18,665
NSMutableAttributedStringを使い

500
00:33:18,766 --> 00:33:21,768
ここに“story”を入れ込みます

501
00:33:21,869 --> 00:33:27,407
ネイティブインデックス型の
レンジを作るよう その文字列で

502
00:33:27,508 --> 00:33:30,477
茶色のレンジを要求します

503
00:33:31,311 --> 00:33:36,083
去年発表した
簡易イニシャライザで

504
00:33:36,183 --> 00:33:38,752
NSRangeに変換します

505
00:33:38,852 --> 00:33:44,258
再びAttributedStringの
プロパティで変換し

506
00:33:44,358 --> 00:33:46,627
最初の単語を茶色にします

507
00:33:47,127 --> 00:33:49,863
コードの実行が遅いので

508
00:33:50,831 --> 00:33:53,133
プロファイルします

509
00:33:53,467 --> 00:33:56,270
茶色になるかと思っていたのに

510
00:33:56,370 --> 00:33:59,173
インデックスを
数えていただけでした

511
00:34:00,674 --> 00:34:04,411
文字列を複数回
変換していたのです

512
00:34:04,511 --> 00:34:08,014
AttributedStringは
Objective-Cのもので

513
00:34:08,114 --> 00:34:12,652
NSStringを文字列に
変換していたのです

514
00:34:13,719 --> 00:34:16,822
これを
最初のレンジを計算する時と

515
00:34:16,924 --> 00:34:19,525
NSRangeに変換する時の
２度やっています

516
00:34:20,694 --> 00:34:25,232
これをループしたら
かなりの時間を費やします

517
00:34:25,466 --> 00:34:27,301
なぜこれが起こるか？

518
00:34:27,501 --> 00:34:31,405
Swift側で
text.stringを呼び出しますが

519
00:34:31,705 --> 00:34:34,875
NSMutableAttributedStringの
実行はObjective-C側です

520
00:34:34,975 --> 00:34:39,478
オリジナルの実装を
確認しないといけません

521
00:34:40,681 --> 00:34:43,016
オリジナルがNSStringを返し

522
00:34:43,283 --> 00:34:47,187
これは参照型なので
ブリッジが必要になります

523
00:34:47,521 --> 00:34:52,059
クラスタごと 文字ごとに
変換します

524
00:34:52,793 --> 00:34:58,398
戻り型でもパラメータでも
ブリッジ変換が発生します

525
00:35:01,235 --> 00:35:06,273
事情が分かったところで
状況を改善させましょう

526
00:35:06,373 --> 00:35:07,908
もう１度ブリッジします

527
00:35:08,675 --> 00:35:13,580
コードを再計算すると
時間が半減されています

528
00:35:13,680 --> 00:35:16,116
今年はもう少し改善されました

529
00:35:16,617 --> 00:35:19,319
このブリッジもしません

530
00:35:19,419 --> 00:35:21,421
良くなっているんです

531
00:35:21,688 --> 00:35:27,494
text.string as NSStringとして
変数を得ると

532
00:35:27,594 --> 00:35:29,563
ブリッジは起こりません

533
00:35:30,564 --> 00:35:34,868
今後は そうすることで
NSStringに対し

534
00:35:34,968 --> 00:35:38,539
プロパティのレンジを呼ぶと
NSRangeが自動で出て

535
00:35:39,406 --> 00:35:43,444
Swiftのネイティブ型と
NSRangeの変換が不要になります

536
00:35:44,545 --> 00:35:46,480
とても便利ですね

537
00:35:46,580 --> 00:35:49,016
このコードを計算してみます

538
00:35:49,116 --> 00:35:54,488
先ほどの800ミリ秒より
かなり速くなりました

539
00:35:55,422 --> 00:36:00,728
しかし わずかですが
まだブリッジしています

540
00:35:55,422 --> 00:36:00,728
しかし わずかですが
まだブリッジしています

541
00:36:01,361 --> 00:36:04,264
この茶色はSwiftの値型です

542
00:36:04,965 --> 00:36:09,670
Objective-Cの
APIレンジを呼ぶたびに

543
00:36:09,770 --> 00:36:14,074
その文字列を
NSStringに再変換しています

544
00:36:14,875 --> 00:36:17,077
１度でいいので低負荷です

545
00:36:17,177 --> 00:36:21,348
しかしループでは
小規模でも何度も行います

546
00:36:21,849 --> 00:36:25,352
小さくてもブリッジは
避けて―

547
00:36:25,452 --> 00:36:28,489
最適化を行う前に
必ず計算しましょう

548
00:36:29,690 --> 00:36:34,528
ブリッジ変換の詳細を
理解した上での助言です

549
00:36:35,596 --> 00:36:39,833
参照セマンティクスに
明示的に使いましょう

550
00:36:40,500 --> 00:36:43,837
自分で書かなくても
多数そろっています

551
00:36:44,238 --> 00:36:46,874
また 参照型の時に使いましょう

552
00:36:46,974 --> 00:36:49,943
NSプロキシや
Core Data管理のオブジェクトです

553
00:36:51,078 --> 00:36:57,084
Objective-Cの
ラウンドトリップ時にもお勧めです

554
00:36:57,317 --> 00:37:02,289
ブリッジが原因で
遅くなっている場合はです

555
00:36:57,317 --> 00:37:02,289
ブリッジが原因で
遅くなっている場合はです

556
00:37:03,657 --> 00:37:09,263
Swiftのコレクションの
パワフルさが分かりましたか？

557
00:37:09,630 --> 00:37:13,867
ご自分の使い方を
見直してみてください

558
00:37:13,967 --> 00:37:18,672
インデックスやスライスで
コードを向上させましょう

559
00:37:18,872 --> 00:37:23,344
速さを測り
遅延やブリッジの調整を―

560
00:37:24,411 --> 00:37:26,179
検討しましょう

561
00:37:26,914 --> 00:37:30,050
TSanで可変状態の監視もです

562
00:37:30,517 --> 00:37:37,024
Playgroundやご自分のAppで
スキルを向上させましょう

563
00:37:37,791 --> 00:37:42,196
今後のラボにも
参加してみてください

564
00:37:42,596 --> 00:37:45,332
本日は ありがとうございました

565
00:37:45,432 --> 00:37:47,134
(拍手)