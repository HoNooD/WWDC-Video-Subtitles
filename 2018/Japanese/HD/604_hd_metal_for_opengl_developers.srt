
1
00:00:07,040 --> 00:00:16,650
（音楽）

2
00:00:20,487 --> 00:00:27,961
（拍手）

3
00:00:28,061 --> 00:00:29,096
ありがとうございます

4
00:00:29,196 --> 00:00:33,267
Metalエコシステムチームの
ダン･オマーチです

5
00:00:33,500 --> 00:00:36,970
Metalで最高の体験を
していただけるよう―

6
00:00:37,070 --> 00:00:39,006
デベロッパを支援しています

7
00:00:39,406 --> 00:00:42,276
AppleのOpenGLや

8
00:00:42,376 --> 00:00:44,945
OpenGL ESに
長年携わってきました

9
00:00:45,045 --> 00:00:46,413
Apple入社以前から

10
00:00:46,513 --> 00:00:49,316
OpenGLの開発に
関わっています

11
00:00:50,817 --> 00:00:54,621
これまでOpenGLで
成し遂げたことを

12
00:00:54,721 --> 00:00:57,024
誇りに思っています

13
00:00:57,457 --> 00:01:01,895
またMetalの新たな
方向性にわくわくします

14
00:00:57,457 --> 00:01:01,895
またMetalの新たな
方向性にわくわくします

15
00:01:03,096 --> 00:01:07,267
本日は同僚の
スカーニャ･スドゥーグと

16
00:01:07,367 --> 00:01:09,136
Metalを簡潔に紹介します

17
00:01:09,236 --> 00:01:11,939
OpenGLアプリケーションを
簡単に移植できるよう―

18
00:01:12,039 --> 00:01:14,107
ガイダンスを提供します

19
00:01:15,209 --> 00:01:17,911
今年は特に重要です

20
00:01:18,011 --> 00:01:21,615
“State of the Union”で
発表したとおり

21
00:01:21,715 --> 00:01:25,819
OpenGL OpenGL ES OpenCLは
非推奨化されます

22
00:01:26,153 --> 00:01:30,424
現行および近々発表される
アプリケーションは当面―

23
00:01:30,524 --> 00:01:34,394
OpenGL ESを
tvOSやiOS12で

24
00:01:34,494 --> 00:01:38,131
そしてOpenGLとOpenCLは

25
00:01:38,232 --> 00:01:41,502
macOS 10.14 Mojaveで
使えます

26
00:01:42,002 --> 00:01:46,173
ただ新規の
アプリケーションはMetalを

27
00:01:46,807 --> 00:01:50,744
前提にすべきでしょう

28
00:01:50,844 --> 00:01:54,515
Metalに馴染みがなければ
そろそろ準備しましょう

29
00:01:55,649 --> 00:01:58,785
OpenGLコードをMetalに
移植する前に

30
00:01:58,886 --> 00:02:00,721
いくつかの選択肢があります

31
00:01:58,886 --> 00:02:00,721
いくつかの選択肢があります

32
00:02:01,255 --> 00:02:05,192
Appleのレンダリング用
フレームワークは

33
00:02:05,292 --> 00:02:09,729
2D用SpriteKitや
3D用SceneKit

34
00:02:09,830 --> 00:02:12,399
エフェクト用
Core Imageなどです

35
00:02:13,333 --> 00:02:16,703
また大手サードパーティーの
ゲームエンジンに

36
00:02:16,803 --> 00:02:19,873
Metalが主要レンダラとして
既に使われていますが

37
00:02:20,607 --> 00:02:24,511
これらの方策はご希望と
異なるかもしれません

38
00:02:24,611 --> 00:02:29,216
本日は皆さんによるMetalの
活用について解説します

39
00:02:30,384 --> 00:02:32,319
ではMetalのデザインと

40
00:02:32,419 --> 00:02:34,421
基本コンセプトから
始めましょう

41
00:02:35,355 --> 00:02:39,626
25年前にデザインされた
OpenGLの中心には

42
00:02:39,726 --> 00:02:43,664
ハードウェア高速化3Dの
源流が反映されています

43
00:02:44,498 --> 00:02:47,267
新バージョンや
拡張によるアップデートは

44
00:02:47,367 --> 00:02:52,139
GPUの特性や性能技術を
浮き彫りにしました

45
00:02:52,606 --> 00:02:55,843
しかし基本のデザインには

46
00:02:55,943 --> 00:02:58,779
現在のハードウェアに
そぐわない部分があります

47
00:03:01,081 --> 00:03:04,017
完全な機能固定型だった
OpenGLパイプラインは

48
00:03:04,117 --> 00:03:08,288
現在プログラミング可能な
パイプラインをサポートしています

49
00:03:08,388 --> 00:03:11,725
しかし最新のGPUとは
なめらかに合致しません

50
00:03:12,860 --> 00:03:17,197
非同期処理はAPIの
中核的な特性ではありません

51
00:03:17,297 --> 00:03:19,867
GPU特性の大半は
見えない形で―

52
00:03:19,967 --> 00:03:22,970
アプリケーションと
並列的に機能しています

53
00:03:24,137 --> 00:03:26,773
25年前のマルチコアは

54
00:03:26,874 --> 00:03:29,343
高額なワークステーションや
サーバーにしか実装されず

55
00:03:29,443 --> 00:03:32,079
その効率的な設計も

56
00:03:32,179 --> 00:03:33,614
重要視されませんでした

57
00:03:34,848 --> 00:03:37,784
2014年 GPU用の新たな--

58
00:03:37,885 --> 00:03:41,121
インターフェイスが
必要なのは明らかでした

59
00:03:41,522 --> 00:03:45,826
GPUの力を存分に活用する
インターフェイスです

60
00:03:46,360 --> 00:03:50,864
まずGPUを妨げないよう
CPUを離す必要があります

61
00:03:51,965 --> 00:03:54,168
しかしアプリケーションは

62
00:03:54,268 --> 00:03:58,605
レンダリングに
CPUを全部使用します

63
00:03:59,706 --> 00:04:02,409
デベロッパが落とし穴に
落下するのを防ぐには

64
00:03:59,706 --> 00:04:02,409
デベロッパが落とし穴に
落下するのを防ぐには

65
00:04:02,509 --> 00:04:07,114
インターフェイスは
予測可能であるべきです

66
00:04:08,015 --> 00:04:10,684
すべてのコールは
明確な結果をもたらし

67
00:04:10,784 --> 00:04:14,254
隠れた動作は
少なくすべきです

68
00:04:15,189 --> 00:04:19,493
予測するには
リソースの配置と

69
00:04:19,593 --> 00:04:22,763
必要に応じた
同期の制御が求められます

70
00:04:24,431 --> 00:04:27,167
Appleはさらに要件を
加えました

71
00:04:27,734 --> 00:04:30,370
ローレベル制御と
理解度を踏まえ

72
00:04:30,571 --> 00:04:34,975
身近なインターフェイスを
目指しました

73
00:04:35,075 --> 00:04:37,611
より簡単に理解できれば

74
00:04:37,711 --> 00:04:40,981
より効果的に
使用できるからです

75
00:04:41,882 --> 00:04:47,254
Metalは最新のGPUに
適合するよう設計しました

76
00:04:47,688 --> 00:04:51,325
開発途中の
ハードウェアの性能を

77
00:04:51,425 --> 00:04:53,627
引き出すソフトが必要でした

78
00:04:53,727 --> 00:04:56,196
Appleが設計したGPUの

79
00:04:56,296 --> 00:04:58,232
A11 bionicもそうです

80
00:05:00,100 --> 00:05:01,935
OpenGLと比べMetalでは

81
00:05:02,035 --> 00:05:06,440
高価なオペレーションが
減少します

82
00:05:06,907 --> 00:05:10,410
APIステートは
オブジェクト作成時に移動し

83
00:05:10,511 --> 00:05:14,248
GPUコマンドとして
パッケージ化されます

84
00:05:15,549 --> 00:05:19,753
これによりレンダリングの際
コストが大幅に減ります

85
00:05:20,420 --> 00:05:24,958
シェーダにも最新のGPUが
反映されています

86
00:05:25,526 --> 00:05:30,297
APIのGPUコマンドへの変換は
より安価になるのです

87
00:05:31,031 --> 00:05:36,336
とはいえパイプラインが
異なるのではありません

88
00:05:36,737 --> 00:05:40,474
Metalはパイプラインの
各段階をまとめ

89
00:05:40,574 --> 00:05:42,676
処理が効率的になります

90
00:05:42,776 --> 00:05:45,846
パイプライン自体は同じです

91
00:05:46,947 --> 00:05:51,084
マルチスレッド処理の
明確なモデルもあります

92
00:05:51,318 --> 00:05:54,621
アプリケーションはGPUを

93
00:05:54,721 --> 00:05:56,790
異なるスレッドから
駆動させます

94
00:05:56,890 --> 00:06:00,327
しかし方法は明確で
制約はないです

95
00:05:56,890 --> 00:06:00,327
しかし方法は明確で
制約はないです

96
00:06:00,894 --> 00:06:05,098
テクスチャ バッファ
シェーダなどもスレッド間で

97
00:06:05,199 --> 00:06:08,302
安全に効率的に使用できます

98
00:06:08,402 --> 00:06:12,372
またMetalは無効状態を
回避するための

99
00:06:12,472 --> 00:06:15,876
高価な内部ロック構成を
必要としません

100
00:06:17,678 --> 00:06:23,016
処理モデルがソフトと
GPUの関係を反映しています

101
00:06:23,116 --> 00:06:26,019
OpenGLの隠れた動作は

102
00:06:26,119 --> 00:06:29,523
Metalでは明示的になります

103
00:06:30,791 --> 00:06:34,728
これによりGPU活用に関して

104
00:06:34,828 --> 00:06:36,363
懸命な判断が下せます

105
00:06:36,797 --> 00:06:40,901
アプリケーションとGPU間の
ソフトも減ります

106
00:06:41,068 --> 00:06:44,171
Metalコールを直接受ける
GPUドライバですが

107
00:06:44,271 --> 00:06:48,408
APIコールの
GPUコマンドへの変換処理も

108
00:06:48,509 --> 00:06:49,843
少ない方がよいです

109
00:06:51,011 --> 00:06:53,146
順に見ましょう

110
00:06:54,081 --> 00:06:57,651
GLコールはすべてOpenGLです

111
00:06:57,751 --> 00:07:00,254
コンテキストで実行され

112
00:06:57,751 --> 00:07:00,254
コンテキストで実行され

113
00:07:00,354 --> 00:07:04,258
APIステートの追跡や
OpenGLオブジェクトのメモリ管理

114
00:07:04,358 --> 00:07:07,094
GPUコマンドの変換などを
担います

115
00:07:07,194 --> 00:07:10,063
Metalはこれらをさらに

116
00:07:10,164 --> 00:07:12,733
小さなオブジェクトに
分けます

117
00:07:14,401 --> 00:07:17,771
最初のオブジェクトは
Metalデバイスで

118
00:07:17,938 --> 00:07:22,075
物理GPUの
抽象的表示となります

119
00:07:23,243 --> 00:07:26,780
テクスチャやバッファ
またシェーダを含む―

120
00:07:26,880 --> 00:07:30,284
パイプラインオブジェクトを
作成します

121
00:07:30,818 --> 00:07:35,022
Metalコマンドキューという
オブジェクトも作成されます

122
00:07:36,190 --> 00:07:38,792
コマンドキューは
コマンドバッファの

123
00:07:38,892 --> 00:07:41,495
シーケンスを作成します

124
00:07:41,795 --> 00:07:43,831
コマンドバッファとは

125
00:07:43,931 --> 00:07:47,601
GPUに送信される
GPUコマンドのリストで

126
00:07:47,734 --> 00:07:50,537
アプリケーションにより
満たされます

127
00:07:50,971 --> 00:07:53,473
アプリケーションは
フレームあたり

128
00:07:53,574 --> 00:07:57,377
これを1つ作成しますが
２つ以上作成した方が

129
00:07:57,477 --> 00:07:59,947
理にかなう場合もあります

130
00:08:00,814 --> 00:08:03,884
直接コマンドバッファに
コマンドを書くのではなく

131
00:08:03,984 --> 00:08:06,987
Metalコマンドエンコーダが
作成されます

132
00:08:07,721 --> 00:08:11,658
エンコーダはAPIコールを
GPU指示命令へと変換し

133
00:08:11,758 --> 00:08:13,727
コマンドバッファに
書き込みます

134
00:08:14,194 --> 00:08:16,497
エンコーディングが
終了すると

135
00:08:16,597 --> 00:08:19,833
アプリケーションは
オブジェクトを放ちます

136
00:08:20,667 --> 00:08:23,904
また新しいエンコーダが
作成されることによって

137
00:08:24,004 --> 00:08:27,241
さらに多くのコマンドの
エンコードが可能になります

138
00:08:30,644 --> 00:08:32,145
重要なのは

139
00:08:32,246 --> 00:08:36,750
これまでGPUは
働いていない点です

140
00:08:36,917 --> 00:08:39,720
オブジェクトも
コマンドエンコードも

141
00:08:39,820 --> 00:08:41,554
すべてCPUで作成しています

142
00:08:41,688 --> 00:08:44,725
エンコーディングなどが

143
00:08:45,025 --> 00:08:46,693
終了してから―

144
00:08:47,227 --> 00:08:51,198
GPUはコマンド処理を
開始するのです

145
00:08:52,933 --> 00:08:55,702
複数のバッファへの

146
00:08:55,802 --> 00:08:58,238
並列エンコードも可能です

147
00:09:00,674 --> 00:09:05,412
コマンドキューはバッファの
シーケンスを―

148
00:09:06,013 --> 00:09:09,716
コマンドバッファは
エンコーダを作成します

149
00:09:10,017 --> 00:09:14,888
書き込み用エンコーダ
オブジェクトは

150
00:09:15,522 --> 00:09:17,524
３つのタイプがあります

151
00:09:17,925 --> 00:09:19,426
レンダコマンドエンコーダは

152
00:09:19,526 --> 00:09:22,129
オブジェクトを
設定し束ね―

153
00:09:22,229 --> 00:09:25,833
ドローコールを発行します

154
00:09:26,433 --> 00:09:29,336
ブリットコマンド
エンコーダはテクスチャや

155
00:09:29,436 --> 00:09:31,338
バッファコピーの
動作を発行し

156
00:09:31,438 --> 00:09:35,609
テクスチャ用
ミップマップの生成や

157
00:09:35,709 --> 00:09:40,647
バッファからピクセルデータの
移動にも使えます

158
00:09:42,249 --> 00:09:45,252
コンピュートコマンド
エンコーダは

159
00:09:45,352 --> 00:09:48,322
コンピュートカーネルを
発送します

160
00:09:49,490 --> 00:09:52,926
レンダコマンドが一番身近な
エンコーダになるでしょう

161
00:09:53,026 --> 00:09:55,796
画像アプリケーションの

162
00:09:55,896 --> 00:09:58,499
大半の動作を担うからです

163
00:09:59,133 --> 00:10:01,668
ここにエンコードされた
コマンドは

164
00:09:59,133 --> 00:10:01,668
ここにエンコードされた
コマンドは

165
00:10:01,768 --> 00:10:04,638
レンダパスと称されます

166
00:10:05,239 --> 00:10:08,976
レンダオブジェクトを
セットアップしたり

167
00:10:09,076 --> 00:10:11,945
描画コマンドを発行します

168
00:10:12,045 --> 00:10:15,315
これにはglDrawArraysや
glDrawElementsなど

169
00:10:15,482 --> 00:10:19,987
他のOpenGL描画コマンドに
似た操作が含まれます

170
00:10:20,821 --> 00:10:22,289
各レンダコマンダは

171
00:10:22,389 --> 00:10:25,626
レンダターゲットセットと
強く結びついています

172
00:10:26,827 --> 00:10:30,597
レンダターゲットは
描画できるテクスチャで

173
00:10:30,697 --> 00:10:35,669
色 深度 ステンシル
テクスチャなどが含まれます

174
00:10:36,270 --> 00:10:39,673
レンダコマンド
エンコーダ作成時にバッファより

175
00:10:39,773 --> 00:10:41,475
ターゲットを指定します

176
00:10:42,342 --> 00:10:45,245
描画コマンドはこれらの

177
00:10:45,345 --> 00:10:47,481
ターゲットに向けられます

178
00:10:48,315 --> 00:10:52,886
新たなターゲットセットに
コマンドを向けるには

179
00:10:52,986 --> 00:10:56,623
現行エンコーダを終了し
新エンコーダを作成します

180
00:10:57,057 --> 00:10:59,827
これにより異なるターゲットに
向けられた

181
00:10:59,927 --> 00:11:03,997
コマンド間の線引きが
明確になります

182
00:10:59,927 --> 00:11:03,997
コマンド間の線引きが
明確になります

183
00:11:05,132 --> 00:11:08,635
レンダリングで使用される
オブジェクトをみましょう

184
00:11:09,236 --> 00:11:11,672
MetalにはOpenGLに似た―

185
00:11:11,772 --> 00:11:16,210
テクスチャ バッファ sampler

186
00:11:16,810 --> 00:11:18,145
パイプラインステート
オブジェクトなどの

187
00:11:18,245 --> 00:11:20,981
オブジェクトがあります

188
00:11:21,114 --> 00:11:24,885
またOpenGLにコンテナとして
存在している―

189
00:11:24,985 --> 00:11:29,756
深度ステンシルステート
オブジェクトもあります

190
00:11:31,325 --> 00:11:35,596
OpenGLとMetalオブジェクトの
最大の違いは

191
00:11:35,696 --> 00:11:38,298
作成過程と
管理方法にあります

192
00:11:38,999 --> 00:11:41,468
オブジェクトはすべて
デバイスオブジェクトから成り

193
00:11:41,568 --> 00:11:43,971
1つのGPUに関連しています

194
00:11:44,538 --> 00:11:47,241
オブジェクトステートは作成時に

195
00:11:47,341 --> 00:11:51,111
ディスクリプタ内のプロパティを
指定しながら設定します

196
00:11:51,745 --> 00:11:54,748
オブジェクト作成時の
ステートは固定され

197
00:11:54,848 --> 00:11:55,983
変更できません

198
00:11:56,783 --> 00:12:00,854
テクスチャとバッファは
固定されていますが

199
00:11:56,783 --> 00:12:00,854
テクスチャとバッファは
固定されていますが

200
00:12:00,954 --> 00:12:04,358
これらオブジェクト内の
データは変更できます

201
00:12:05,893 --> 00:12:08,195
Metalは
オブジェクト作成時に

202
00:12:08,295 --> 00:12:09,897
高価なセットアップを
すべて実行できます

203
00:12:10,230 --> 00:12:13,100
OpenGLは可変モデルなので

204
00:12:13,200 --> 00:12:16,169
アプリケーションが
ステートに触れると

205
00:12:16,670 --> 00:12:19,740
オブジェクト再コンパイルが
生じるかもしれません

206
00:12:19,840 --> 00:12:22,976
またOpenGLは描画前に
ステート確認のため

207
00:12:23,076 --> 00:12:27,748
フラグ階層の
チェックが必要です

208
00:12:27,948 --> 00:12:31,785
変更不可のMetalは
ステート変更を

209
00:12:31,885 --> 00:12:35,756
チェックする必要がなく
ドローコールが速くなるのです

210
00:12:37,391 --> 00:12:41,261
オブジェクトはスレッド間で
効率的に使用できます

211
00:12:41,361 --> 00:12:44,998
他のスレッド内の変更による
無効化を防ぐために

212
00:12:45,098 --> 00:12:47,034
オブジェクトを
ロックする必要もありません

213
00:12:51,138 --> 00:12:53,240
次は移植についてです

214
00:12:54,508 --> 00:12:58,212
レンダリング
アプリケーションの

215
00:12:58,312 --> 00:13:00,614
典型的なフェーズです

216
00:12:58,312 --> 00:13:00,614
典型的なフェーズです

217
00:13:00,881 --> 00:13:04,318
ソースをコンパイルし
アセットをバンドルします

218
00:13:04,518 --> 00:13:07,454
起動 初期化
アセットの読み込み―

219
00:13:07,554 --> 00:13:12,392
アプリケーションに恒常的な
オブジェクトの初期化―

220
00:13:13,060 --> 00:13:15,128
そしてレンダを繰り返しながら

221
00:13:15,229 --> 00:13:17,831
ステート設定やドローコール

222
00:13:17,931 --> 00:13:20,534
フレームを提示していきます

223
00:13:22,269 --> 00:13:24,071
まずはMetal向けの

224
00:13:24,171 --> 00:13:27,141
アプリケーション稼動
初期段階についてです

225
00:13:28,442 --> 00:13:32,579
シェーダのオフライン構築や
オブジェクト初期化の生成―

226
00:13:33,046 --> 00:13:37,017
さらにスカーニャがレンダリング
コード移植を解説します

227
00:13:38,452 --> 00:13:41,154
まずはシェーダが
コンパイルされる―

228
00:13:41,255 --> 00:13:44,358
アプリケーション
ビルドタイムからです

229
00:13:44,758 --> 00:13:47,394
まずシェーディング言語です

230
00:13:47,694 --> 00:13:50,664
MetalではC++に基づきます

231
00:13:50,764 --> 00:13:55,369
クラス テンプレート
ストラクチャ enumや

232
00:13:55,469 --> 00:13:57,805
名前空間の
定義づけなどができます

233
00:13:58,272 --> 00:14:02,109
組み込み型
ベクタ マトリクスタイプや

234
00:13:58,272 --> 00:14:02,109
組み込み型
ベクタ マトリクスタイプや

235
00:14:02,543 --> 00:14:06,813
グラフィックスに汎用される
機能や動作があります

236
00:14:07,681 --> 00:14:12,085
samplerやテクスチャを
特定するクラスもあります

237
00:14:12,786 --> 00:14:15,122
言語はこうなります

238
00:14:15,222 --> 00:14:18,258
頂点と
フラグメントシェーダです

239
00:14:19,159 --> 00:14:20,494
上部のキーワードが

240
00:14:20,594 --> 00:14:24,798
機能は頂点シェーダである
と提示し

241
00:14:24,898 --> 00:14:28,669
下部にはフラグメント機能の
キーワードがあります

242
00:14:29,536 --> 00:14:34,474
カスタム名が付与されている点に
ご注意ください

243
00:14:34,575 --> 00:14:38,946
多数のシェーダを作成し
その機能を識別するために

244
00:14:39,046 --> 00:14:41,849
名前を付けられます

245
00:14:42,883 --> 00:14:45,786
アプリケーションから
移されるものすべてが

246
00:14:45,886 --> 00:14:47,487
シェーダには引数となります

247
00:14:47,754 --> 00:14:51,692
GLSLのような機能外の
緩い変数はありません

248
00:14:52,259 --> 00:14:55,796
各パラメータの隣に
名称が括弧内に入っています

249
00:14:56,063 --> 00:14:58,031
これらは属性指定子で

250
00:14:58,131 --> 00:15:02,569
特別な変数を示し
C++から延長したものです

251
00:14:58,131 --> 00:15:02,569
特別な変数を示し
C++から延長したものです

252
00:15:03,237 --> 00:15:07,708
このVID属性は頂点処理の際―

253
00:15:07,808 --> 00:15:13,146
現行の頂点インデックスを
含ませることを示しています

254
00:15:13,814 --> 00:15:18,118
この２か所でも
頂点が配列されています

255
00:15:19,386 --> 00:15:22,389
バッファ属性指定子のついた
これらのパラメータは

256
00:15:22,489 --> 00:15:28,161
変数がMetalAPI内の
バッファオブジェクトによって

257
00:15:28,362 --> 00:15:31,965
満たされていることを
示しています

258
00:15:32,099 --> 00:15:35,502
まずここでの
使用タイプを見ましょう

259
00:15:35,903 --> 00:15:39,740
ご自身で定義する
カスタムタイプです

260
00:15:40,240 --> 00:15:44,178
この頂点パラメータは
頂点タイプのポインタで

261
00:15:44,311 --> 00:15:46,313
その定義はこちらです

262
00:15:46,513 --> 00:15:48,482
モデル位置と

263
00:15:48,582 --> 00:15:52,085
テクスチャ座標の
２つのメンバからなります

264
00:15:52,252 --> 00:15:56,223
頂点配列における配置や
メモリを定義し

265
00:15:56,323 --> 00:15:58,559
頂点シェーダへ移行します

266
00:15:59,626 --> 00:16:03,497
頂点シェーダから返送された
頂点出力タイプを見ましょう

267
00:15:59,626 --> 00:16:03,497
頂点シェーダから返送された
頂点出力タイプを見ましょう

268
00:16:04,798 --> 00:16:07,267
ラスタライズとその後の

269
00:16:07,367 --> 00:16:11,071
フラグメントプログラムに
流れるものを定義しています

270
00:16:13,073 --> 00:16:16,143
浮動小数点メンバである
clipPosの隣に

271
00:16:16,243 --> 00:16:19,012
座標属性指定子があります

272
00:16:19,112 --> 00:16:24,117
頂点シェーダの出力座標を
担うことを示しています

273
00:16:24,852 --> 00:16:28,288
属性指定子のないtexCoordは

274
00:16:28,388 --> 00:16:31,258
ラスタライズされた三角形を
定義する―

275
00:16:31,358 --> 00:16:34,661
他の頂点の
テクスチャ座標値で

276
00:16:34,761 --> 00:16:40,367
補間された変数が
デフォルトとなります

277
00:16:41,401 --> 00:16:44,438
フラグメントシェーダの
パラメータを見ましょう

278
00:16:44,938 --> 00:16:48,375
先ほどのvertexOutputは

279
00:16:48,609 --> 00:16:52,045
フラグメントシェーダへの
入力として使用します

280
00:16:52,146 --> 00:16:57,751
頂点シェーダで構築した―
補間されたテクスチャ座標を

281
00:16:58,318 --> 00:17:01,355
テクスチャからのサンプル操作に
使用しています

282
00:16:58,318 --> 00:17:01,355
テクスチャからのサンプル操作に
使用しています

283
00:17:02,890 --> 00:17:05,659
オブジェクトをシェーダ
パラメータへマップする場合

284
00:17:05,759 --> 00:17:10,597
レンダコマンドエンコーダを
アプリケーションコードに使います

285
00:17:13,066 --> 00:17:16,703
各コールのインデックス引数は
OpenGL属性や

286
00:17:16,803 --> 00:17:20,907
頂点属性インデックスや
テクスチャユニットに似ています

287
00:17:21,141 --> 00:17:26,246
シェーダパラメータに向かう
インデックスを特定します

288
00:17:26,780 --> 00:17:31,652
インデックス３でエンコーダを
コールした結果―

289
00:17:31,752 --> 00:17:34,721
ユニフォームバッファ
オブジェクトが

290
00:17:34,855 --> 00:17:39,459
シェーダのユニフォーム
パラメータへマップされました

291
00:17:40,794 --> 00:17:43,397
テクスチャや
samplerオブジェクトの設定でも

292
00:17:43,664 --> 00:17:45,299
同様のコールを作成します

293
00:17:50,204 --> 00:17:52,706
シェーダ開発に特に有用な

294
00:17:52,806 --> 00:17:55,442
ライブラリについて
お話します

295
00:17:57,411 --> 00:17:58,946
SIMDです

296
00:17:59,079 --> 00:18:02,082
Metalから離れた
ライブラリですが

297
00:17:59,079 --> 00:18:02,082
Metalから離れた
ライブラリですが

298
00:18:02,182 --> 00:18:05,485
多数の直交フレームワークで
使用されています

299
00:18:05,853 --> 00:18:08,121
しかしMetalを念頭に
作成されました

300
00:18:08,722 --> 00:18:11,058
SIMDはグラフィック
アルゴリズムの適用に使う―

301
00:18:11,158 --> 00:18:14,461
ベクタやマトリクスを
定義します

302
00:18:14,561 --> 00:18:17,231
３および４成分のベクタや

303
00:18:17,331 --> 00:18:20,467
３×３ ４×４マトリクスが
含まれます

304
00:18:23,504 --> 00:18:29,476
このライブラリを使って
アプリケーションコードと

305
00:18:30,077 --> 00:18:34,715
シェーディング言語コードを
共有できるのです

306
00:18:35,716 --> 00:18:40,654
これを使いアプリケーションから
シェーダへのデータの―

307
00:18:40,754 --> 00:18:43,824
レイアウトを定義できます

308
00:18:43,924 --> 00:18:45,192
こういうことです

309
00:18:45,826 --> 00:18:48,362
アプリケーションから
シェーダに流す―

310
00:18:48,462 --> 00:18:50,597
データ入り構造体を作ります

311
00:18:50,697 --> 00:18:53,600
モデルビュー射影行列と

312
00:18:53,700 --> 00:18:57,538
一次光源の位置を伝える場合
SIMDタイプを

313
00:18:57,638 --> 00:19:00,541
ストラクチャに
使用することができます

314
00:18:57,638 --> 00:19:00,541
ストラクチャに
使用することができます

315
00:19:01,742 --> 00:19:04,244
アプリケーションコードと
Metalファイルの

316
00:19:04,778 --> 00:19:08,749
両方にストラクチャの定義を
ヘッダー内に設定します

317
00:19:08,849 --> 00:19:11,852
同じタイプを使っているので
シェーダが使う―

318
00:19:11,985 --> 00:19:15,756
データレイアウトと
コードが合致します

319
00:19:16,490 --> 00:19:20,494
レイアウトの不一致によるバグが
ずっと少なくなります

320
00:19:23,730 --> 00:19:27,301
Metalが効果的なのは

321
00:19:27,401 --> 00:19:30,804
作業を速めに
少なく実行するからです

322
00:19:31,171 --> 00:19:34,341
Metalシェーダファイルの
コンパイルには

323
00:19:34,441 --> 00:19:36,243
Xcodeを使います

324
00:19:36,810 --> 00:19:38,912
これで前端コンパイルが
実行され

325
00:19:39,012 --> 00:19:43,684
構文解析 シェーダ解析や
基本的な最適化が行われます

326
00:19:43,784 --> 00:19:47,454
コードはバイナリ中間表示へ
変換され

327
00:19:47,554 --> 00:19:49,957
あらゆるハードウェアで
使用できます

328
00:19:50,224 --> 00:19:55,195
アプリケーションが動くまで
実際のGPUコードは作られませんが

329
00:19:55,295 --> 00:19:59,900
アプリケーションが動く際の
コンパイル時間が半減します

330
00:20:01,502 --> 00:20:04,671
作成された
中間表示バイナリは

331
00:20:04,771 --> 00:20:08,308
Metalライブラリファイルに
保存されます

332
00:20:08,442 --> 00:20:13,213
Xcodeは
Metalシェーダソースファイルを

333
00:20:13,313 --> 00:20:15,782
変換して
Metalライブラリに入れて

334
00:20:15,883 --> 00:20:17,784
アプリケーションに収めます

335
00:20:19,186 --> 00:20:21,622
シェーダは
Xcodeで作ることもできれば

336
00:20:21,722 --> 00:20:25,025
アプリケーション稼働中でも
構築できます

337
00:20:25,893 --> 00:20:29,329
文字列の連結や
コード生成系などによって

338
00:20:29,429 --> 00:20:31,899
シェーダを構築する
OpenGLアプリケーションがあります

339
00:20:32,432 --> 00:20:36,270
稼動時に全シェーダを
集めるのは大変です

340
00:20:36,637 --> 00:20:39,807
アプリケーションによる
編集が無理でも

341
00:20:39,907 --> 00:20:41,542
OpenGLと同様にMetalは

342
00:20:41,642 --> 00:20:46,280
稼動時ソースからシェーダを
編集することができます

343
00:20:47,614 --> 00:20:51,552
ただしユーザーシステムから
この作業を切り離すことで

344
00:20:51,652 --> 00:20:55,355
性能の倹約を
あきらめなければなりません

345
00:20:55,989 --> 00:20:58,192
編集エラーは見えないので

346
00:20:58,292 --> 00:21:01,395
アプリケーション実行まで
判明しません

347
00:20:58,292 --> 00:21:01,395
アプリケーション実行まで
判明しません

348
00:21:01,728 --> 00:21:05,799
また稼動時はヘッダを
シェーダに含められないので

349
00:21:05,899 --> 00:21:10,003
アプリケーションコードと
シェーダ間でタイプは共有不可です

350
00:21:11,405 --> 00:21:15,209
シェア型の稼動編集を
使用するのであれば

351
00:21:15,309 --> 00:21:20,314
Xcodeでのシェーダ構築に
時間をかけることを勧めます

352
00:21:20,414 --> 00:21:23,417
実効性能の倹約により

353
00:21:23,517 --> 00:21:26,520
開発上の利便性を
享受できます

354
00:21:27,621 --> 00:21:31,925
次はMetalレンダラの
初期化についてです

355
00:21:32,025 --> 00:21:34,495
オブジェクトの作成も
関係しています

356
00:21:34,595 --> 00:21:38,198
まずはデバイスや
コマンドキューについて

357
00:21:38,298 --> 00:21:43,837
次にアセットのための
オブジェクト作成を解説します

358
00:21:44,838 --> 00:21:46,406
まずデバイスやキューです

359
00:21:47,541 --> 00:21:50,410
これらは最初に
作成するオブジェクトです

360
00:21:52,012 --> 00:21:55,249
デバイスはGPUの
抽象的表示なのです

361
00:21:56,016 --> 00:21:58,452
パイプラインオブジェクトや

362
00:21:58,552 --> 00:22:01,722
テクスチャ バッファなどの
オブジェクト作成を担います

363
00:21:58,552 --> 00:22:01,722
テクスチャ バッファなどの
オブジェクト作成を担います

364
00:22:02,589 --> 00:22:07,528
iOSはGPU１個で
デバイスも1つ限りですが

365
00:22:07,628 --> 00:22:11,131
macOSでは
内臓GPUと独立型GPU―

366
00:22:11,231 --> 00:22:16,370
マルチeGPUまで考慮すると
マルチデバイスも可能です

367
00:22:17,037 --> 00:22:18,806
通常既定デバイスだけで

368
00:22:18,906 --> 00:22:21,575
大半のアプリケーションは
間に合います

369
00:22:21,675 --> 00:22:24,545
あるシステムを
コールするだけで簡単です

370
00:22:24,645 --> 00:22:28,115
MTLCreateSystem
DefaultDeviceです

371
00:22:29,817 --> 00:22:34,421
デバイスではまず
コマンドキューを作ります

372
00:22:35,789 --> 00:22:38,325
コマンドバッファを
入手するためキューは

373
00:22:38,425 --> 00:22:40,460
アプリケーション
レンダループで使われますが

374
00:22:40,561 --> 00:22:44,231
コマンドキューは
初期化時に作りましょう

375
00:22:44,832 --> 00:22:47,968
通常キューは
ひとつで十分ですが

376
00:22:48,068 --> 00:22:52,539
並列タスクを実行する場合
マルチキューが必要です

377
00:22:53,040 --> 00:22:55,075
作成したデバイスによる
キューの作成も簡単で

378
00:22:55,175 --> 00:22:58,278
newCommandQueueを
コールするだけです

379
00:22:58,612 --> 00:23:02,716
これでコマンドバッファを
入手できるようになります

380
00:22:58,612 --> 00:23:02,716
これでコマンドバッファを
入手できるようになります

381
00:23:04,351 --> 00:23:08,121
レンダオブジェクトの作成を
見てみましょう

382
00:23:09,323 --> 00:23:12,459
レンダリングで使用する
３つのオブジェクト

383
00:23:12,559 --> 00:23:14,795
テクスチャ バッファ
パイプラインです

384
00:23:15,295 --> 00:23:16,697
まずはテクスチャです

385
00:23:17,898 --> 00:23:21,435
デバイスオブジェクトから
作りますが

386
00:23:22,236 --> 00:23:25,139
ディスクリプタ
オブジェクトを使います

387
00:23:25,372 --> 00:23:29,009
非常にシンプルな
オブジェクトです

388
00:23:29,109 --> 00:23:32,279
オブジェクトセットアップの
プロパティのみです

389
00:23:32,946 --> 00:23:36,650
テクスチャの作成には
ディスクリプタを使用します

390
00:23:36,884 --> 00:23:39,920
作成するテクスチャの
プロパティを指定します

391
00:23:40,020 --> 00:23:43,724
テクスチャタイプ
2D 3D キューブマップや

392
00:23:43,924 --> 00:23:46,960
ディメンション Mipmap数―

393
00:23:47,060 --> 00:23:50,497
データの
ピクセルフォーマットなどです

394
00:23:51,498 --> 00:23:55,002
プロパティの各値の設定後
メソッドをコールして

395
00:23:55,102 --> 00:23:59,172
使用可能な
テクスチャオブジェクトを作ります

396
00:24:00,941 --> 00:24:05,212
テクスチャイメージ用の
メモリが割り当てられます

397
00:24:05,879 --> 00:24:10,617
オブジェクト作成後
ディスクリプタは不要です

398
00:24:11,084 --> 00:24:14,822
ディスクリプタ内のプロパティは
ロックされ変えられません

399
00:24:15,556 --> 00:24:19,159
テクスチャイメージ内容は
変更できます

400
00:24:20,360 --> 00:24:23,530
テクスチャディスクリプタに
設定する次のプロパティは

401
00:24:23,630 --> 00:24:26,333
バッファ作成時にも
使います

402
00:24:26,433 --> 00:24:28,435
ストレージモードです

403
00:24:29,102 --> 00:24:33,807
Metalはオブジェクト作成時
メモリを割り当てます

404
00:24:33,907 --> 00:24:37,811
ストレージモードはMetalに
割り当てプールを指示します

405
00:24:38,378 --> 00:24:41,215
共有ストレージモードは

406
00:24:41,315 --> 00:24:44,318
CPU GPUの両方から
アクセスできます

407
00:24:44,418 --> 00:24:48,622
バッファはオブジェクトに使われる
メモリへのポインタを得ます

408
00:24:48,856 --> 00:24:54,528
プロテクタはテクスチャへの
データ検索を簡便にできます

409
00:24:55,562 --> 00:24:59,633
GPUアクセスのみの
プライベートモードもあります

410
00:24:59,733 --> 00:25:04,071
CPUが干渉しない最適化が

411
00:24:59,733 --> 00:25:04,071
CPUが干渉しない最適化が

412
00:25:04,171 --> 00:25:06,607
可能になります

413
00:25:06,707 --> 00:25:11,445
このタイプのテクスチャは
GPUだけが内容を満たせます

414
00:25:12,412 --> 00:25:17,785
ブリットエンコーダで
CPUから書き込みもできます

415
00:25:17,885 --> 00:25:21,388
共有ストレージを使った
中間リソースからコピーします

416
00:25:22,256 --> 00:25:24,291
専用ビデオメモリがある場合

417
00:25:24,391 --> 00:25:28,862
ストレージ設定でリソースは
ビデオメモリに割り当てられます

418
00:25:30,397 --> 00:25:35,068
macOSでは３つ目のストレージ
managed storageが使えます

419
00:25:35,502 --> 00:25:39,473
GPU CPU双方から
データアクセスできます

420
00:25:39,573 --> 00:25:41,608
専用ビデオメモリの場合

421
00:25:41,708 --> 00:25:47,047
Metalはミラードメモリを作成し
アクセスを効率化します

422
00:25:47,714 --> 00:25:51,818
GPU CPUのデータが
確実にシンクロするように

423
00:25:51,919 --> 00:25:54,521
コールははっきりして
いなければなりません

424
00:25:57,758 --> 00:26:00,828
テクスチャ作成の例です

425
00:25:57,758 --> 00:26:00,828
テクスチャ作成の例です

426
00:26:02,963 --> 00:26:05,332
テクスチャディスクリプタを
作成し

427
00:26:05,432 --> 00:26:09,036
ストレージモードなど
プロパティを設定します

428
00:26:10,637 --> 00:26:14,975
次にデバイスで
テクスチャを作成します

429
00:26:15,742 --> 00:26:19,479
イメージデータは
行単位でバイト数を計算し

430
00:26:19,680 --> 00:26:23,917
GLText同様にロード先の
リージョンを指定します

431
00:26:26,019 --> 00:26:29,523
次にreplace regionメソッドを
コールして

432
00:26:29,623 --> 00:26:33,927
ポインタからデータコピーし
テクスチャに収めます

433
00:26:36,830 --> 00:26:40,634
テクスチャオブジェクトは
いくつかの点で異なります

434
00:26:40,734 --> 00:26:44,104
OpenGLのsampler
オブジェクトは選択型ですが

435
00:26:44,204 --> 00:26:48,008
ラップモードやフィルタを
その中に設定できます

436
00:26:48,108 --> 00:26:50,878
Metalでは別途
samplerオブジェクトを作るか

437
00:26:50,978 --> 00:26:54,114
シェーダにsampler
パラメータ設定が必要です

438
00:26:55,582 --> 00:26:58,185
Metalではイメージデータは
反転しません

439
00:26:58,285 --> 00:27:02,923
OpenGLは左下原点で
Metalは左上原点を使います

440
00:26:58,285 --> 00:27:02,923
OpenGLは左下原点で
Metalは左上原点を使います

441
00:27:03,023 --> 00:27:06,660
テクスチャロード時に
注意が必要です

442
00:27:07,628 --> 00:27:11,432
デスクトップ型OpenGLは
内部フォーマットとは

443
00:27:11,532 --> 00:27:15,435
異なるデータを供給されると
変換を実施します

444
00:27:16,270 --> 00:27:19,506
Metalは変換しないので
アセットのフォーマットの

445
00:27:19,606 --> 00:27:22,843
適合性を確認するか―

446
00:27:22,943 --> 00:27:26,013
変換パスを導入します

447
00:27:28,882 --> 00:27:30,517
バッファに移ります

448
00:27:32,252 --> 00:27:35,789
Metalは非構造化データの
すべてにバッファを使います

449
00:27:41,261 --> 00:27:45,599
OpenGLの頂点 エレメント
ユニフォームバッファと似ています

450
00:27:45,699 --> 00:27:50,470
これらを使っているなら
移植は容易です

451
00:27:51,305 --> 00:27:55,309
デバイスで
newBufferWithLengthをコールし

452
00:27:55,409 --> 00:27:57,444
サイズを指定すると
バッファができます

453
00:27:57,644 --> 00:28:00,013
ストレージモードも
指定します

454
00:27:57,644 --> 00:28:00,013
ストレージモードも
指定します

455
00:28:00,814 --> 00:28:06,553
コンテンツプロパティを通じ
バッファをロードします

456
00:28:07,087 --> 00:28:10,657
Metalには
非構造化データであるため

457
00:28:10,757 --> 00:28:14,795
レイアウトもコードのシェアも
あなた次第です

458
00:28:14,895 --> 00:28:17,898
ここでSIMDタイプを
使うストラクチャに

459
00:28:17,998 --> 00:28:21,535
コンテンツポインタを
キャストしています

460
00:28:22,736 --> 00:28:25,806
バッファデータを満たす
ストラクチャのメンバを

461
00:28:25,906 --> 00:28:30,177
レイアウトかアプリケーションの
定義に従い設定します

462
00:28:31,111 --> 00:28:34,715
ストラクチャ定義は
アプリケーションと

463
00:28:34,815 --> 00:28:39,286
シェアコードで共有でき
レイアウトの一致は確約されます

464
00:28:41,655 --> 00:28:43,257
よく起きる間違いである―

465
00:28:43,524 --> 00:28:47,427
バッファデータとシェーダの
解釈の不一致は

466
00:28:47,528 --> 00:28:51,565
アライメントに関する
想定によるものです

467
00:28:51,999 --> 00:28:54,568
例えばシェーディング言語の

468
00:28:54,668 --> 00:28:57,971
float型３を
12バイトと想定します

469
00:28:58,071 --> 00:29:01,475
４バイトコンポーネントが
３つで12バイトです

470
00:28:58,071 --> 00:29:01,475
４バイトコンポーネントが
３つで12バイトです

471
00:29:01,775 --> 00:29:05,078
しかしシェーディング言語は
float型３が

472
00:29:05,179 --> 00:29:10,050
16バイト消費すると解釈し
問題が発生します

473
00:29:10,150 --> 00:29:14,454
これはCPU GPUの使用を
最適化するために

474
00:29:14,555 --> 00:29:17,157
より厳密なアライメントが
採用されているためです

475
00:29:17,791 --> 00:29:21,562
３×３のマトリクスでも
よく同様の問題が生じます

476
00:29:22,129 --> 00:29:27,034
隙のないデータを
パックするのであれば

477
00:29:27,768 --> 00:29:30,971
Metalシェーディング言語に
パックタイプがあります

478
00:29:31,071 --> 00:29:35,175
パックデータをバッファ内へ移し

479
00:29:35,275 --> 00:29:39,813
データ遂行前にパックデータを
レギュラーベクタへ―

480
00:29:39,913 --> 00:29:42,649
渡さなければなりません

481
00:29:43,517 --> 00:29:46,420
アプリケーション構築時には

482
00:29:46,720 --> 00:29:50,724
最も便利なストレージモードを
勧めます

483
00:29:51,225 --> 00:29:56,263
リソースへより簡単に
アクセスできます

484
00:29:56,830 --> 00:30:01,502
iOSではStorageModeSharedで
テクスチャとバッファを作ります

485
00:29:56,830 --> 00:30:01,502
iOSではStorageModeSharedで
テクスチャとバッファを作ります

486
00:30:02,135 --> 00:30:05,305
macOSではテクスチャに
StorageModeSharedは使えませんが

487
00:30:05,405 --> 00:30:08,675
StorageModeManagedにより
画像データへのアクセスが容易に

488
00:30:08,776 --> 00:30:11,311
ただプライベート
ストレージが最適です

489
00:30:15,349 --> 00:30:20,254
macOSでバッファに使う場合
注意が必要です

490
00:30:20,354 --> 00:30:22,289
CPU GPUの両方―

491
00:30:22,389 --> 00:30:28,161
またはGPUのみがアクセスする
データが混在していると

492
00:30:28,262 --> 00:30:34,368
別々のメモリプールに分けるのが
困難になるかもしれません

493
00:30:36,470 --> 00:30:40,040
テクスチャとバッファを
直接作成する方法に続き

494
00:30:40,140 --> 00:30:44,111
common file formatsから
簡単にテクスチャやバッファを

495
00:30:44,211 --> 00:30:46,880
作成できるMetalKitを
解説します

496
00:30:46,980 --> 00:30:50,784
テクスチャロードクラスや
Model I/Oでロードした

497
00:30:50,884 --> 00:30:54,288
Metalバッファを裏付けた
メッシュ作成機能などがあります

498
00:30:57,624 --> 00:31:01,662
まずこれらを含む
レンダパイプラインオブジェクト

499
00:30:57,624 --> 00:31:01,662
まずこれらを含む
レンダパイプラインオブジェクト

500
00:31:02,596 --> 00:31:04,565
パイプラインオブジェクトは

501
00:31:04,665 --> 00:31:07,601
レンダディスクリプタ
オブジェクトで作成します

502
00:31:08,268 --> 00:31:11,538
フラグメントシェーダと
頂点がペアで入っています

503
00:31:12,272 --> 00:31:16,009
頂点シェーダに供給する
頂点レイアウトも指定します

504
00:31:17,244 --> 00:31:20,447
またレンダターゲットの
ステートと

505
00:31:20,547 --> 00:31:24,518
ピクセルフォーマットを
混合します

506
00:31:25,452 --> 00:31:28,956
変更不可のレンダステート
パイプラインオブジェクトの

507
00:31:29,056 --> 00:31:32,726
作成デバイスに
メソッドをコールします

508
00:31:33,494 --> 00:31:37,931
ディスクリプターだけで
オブジェクトができます

509
00:31:39,066 --> 00:31:42,536
パイプラインステート
オブジェクト作成コードです

510
00:31:43,370 --> 00:31:45,105
パイプライン作成前に

511
00:31:45,205 --> 00:31:48,976
Metalライブラリから
シェーダを引き出します

512
00:31:49,076 --> 00:31:53,514
この行はXcodeで構築した
デフォルトMetalライブラリです

513
00:31:54,515 --> 00:31:58,852
機能名を活用し
ライブラリ用頂点と

514
00:31:58,952 --> 00:32:01,155
フラグメントシェーダを
入手できます

515
00:31:58,952 --> 00:32:01,155
フラグメントシェーダを
入手できます

516
00:32:01,755 --> 00:32:04,424
シェーディング機能設定や

517
00:32:04,525 --> 00:32:07,694
レンダターゲット
ピクセルフォーマットを指定する

518
00:32:07,795 --> 00:32:09,763
レンダパイプライン
ディスクリプタを作成します

519
00:32:10,097 --> 00:32:13,934
最後にパイプラインステート
オブジェクトを作成する―

520
00:32:14,034 --> 00:32:16,737
ディスクリプタオブジェクトと
共にデバイスを使用します

521
00:32:18,272 --> 00:32:22,643
OpenGLとMetalグラフィック
パイプラインの顕著な違いです

522
00:32:22,743 --> 00:32:24,545
OpenGLプログラム
オブジェクトは

523
00:32:24,645 --> 00:32:29,383
頂点とフラグメントシェーダの
ペアのみを含みます

524
00:32:29,483 --> 00:32:32,519
一方Metalは頂点レイアウトや
ブレンドステート

525
00:32:32,619 --> 00:32:35,255
レンダターゲットピクセル
フォーマットも含んでいます

526
00:32:35,355 --> 00:32:38,625
パイプライン構築前に
把握しましょう

527
00:32:39,860 --> 00:32:43,430
パイプラインステートが
より多くあるため

528
00:32:43,530 --> 00:32:47,835
MetalはGPUマシンコードに
シェーダを十分変換できます

529
00:32:47,935 --> 00:32:51,238
OpenGLのプログラム
オブジェクトではできません

530
00:32:51,505 --> 00:32:54,775
次にアプリケーション初期化時に
パイプライン作成を―

531
00:32:54,875 --> 00:32:56,677
可能にするシステムを
構築します

532
00:32:57,077 --> 00:32:59,446
カノニカル頂点レイアウト
または―

533
00:32:59,546 --> 00:33:01,882
レンダターゲットを
限定的に選択すれば

534
00:32:59,546 --> 00:33:01,882
レンダターゲットを
限定的に選択すれば

535
00:33:01,982 --> 00:33:04,118
アプリが使用するステートの
組み合わせや

536
00:33:04,218 --> 00:33:07,421
パイプラインオブジェクトを
減らせます

537
00:33:09,123 --> 00:33:12,960
どのパイプラインが必要か
分からない場合

538
00:33:13,060 --> 00:33:15,462
Metalへの移植では

539
00:33:15,562 --> 00:33:18,766
まず作成済みパイプラインの
辞書を設けます

540
00:33:19,099 --> 00:33:21,602
ステートの
新しい組み合わせは

541
00:33:21,702 --> 00:33:25,772
ディスクリプタをキーとして
パイプラインを構築し保存できます

542
00:33:26,440 --> 00:33:29,776
ある意味
改変のような操作なので

543
00:33:30,043 --> 00:33:32,112
付加したままの
出荷は避けましょう

544
00:33:32,212 --> 00:33:35,816
これらのオブジェクトの
作成が高価だからです

545
00:33:36,150 --> 00:33:37,618
パイプライン
オブジェクトを作ると

546
00:33:37,718 --> 00:33:41,054
GPUコンパイラが
シェーダバイナリ中間表示を

547
00:33:41,155 --> 00:33:44,992
マシンコードに変換し
最適化します

548
00:33:45,192 --> 00:33:49,496
レンダループ実行時にこれらを
アプリケーションが作成する場合

549
00:33:49,596 --> 00:33:54,334
フレームレートの低下が生じたり
一時停止状態になるでしょう

550
00:33:55,802 --> 00:33:59,740
テクスチャやバッファへの
メモリの割り当て作業も高価です

551
00:33:59,840 --> 00:34:04,111
リソースにデータを満たす
プロセシングもです

552
00:33:59,840 --> 00:34:04,111
リソースにデータを満たす
プロセシングもです

553
00:34:04,778 --> 00:34:08,649
しかし作成されたオブジェクトは
レンダループで使うと

554
00:34:08,748 --> 00:34:12,786
事前作業のおかげで
必要なCPUは減ります

555
00:34:14,321 --> 00:34:18,092
ではスカーニャがレンダループの
移植を解説します

556
00:34:18,192 --> 00:34:22,362
（拍手）

557
00:34:22,496 --> 00:34:27,167
GPUソフトウェアエンジニア
スカーニャ･スドゥーグです

558
00:34:27,601 --> 00:34:31,871
皆さんと移行作業を共有できて
うれしい限りです

559
00:34:31,972 --> 00:34:33,806
では移植を続けましょう

560
00:34:35,676 --> 00:34:38,411
先に解説したアプリケーション
セットアップにより

561
00:34:38,512 --> 00:34:41,380
すべてのシェーダが構築され

562
00:34:41,481 --> 00:34:43,150
フレーム生成のための

563
00:34:43,250 --> 00:34:46,620
オブジェクトが
作成されているはずです

564
00:34:47,021 --> 00:34:50,357
次は各フレームに動作する―

565
00:34:50,456 --> 00:34:53,293
アプリケーションの
レンダループです

566
00:34:53,960 --> 00:34:56,163
MetalではGPU処理の

567
00:34:56,263 --> 00:35:00,601
非同期的特性をレンダループで
明示的に管理します

568
00:34:56,263 --> 00:35:00,601
非同期的特性をレンダループで
明示的に管理します

569
00:35:00,701 --> 00:35:04,405
またコマンドバッファを取得し
GPUコマンドリストと共に

570
00:35:04,505 --> 00:35:07,407
それをGPUに供給します

571
00:35:08,108 --> 00:35:10,811
このようにリソースを
アップデートすれば

572
00:35:10,911 --> 00:35:14,281
GPUはレンダループの記述を

573
00:35:14,381 --> 00:35:16,517
非同期的に読み取ります

574
00:35:17,417 --> 00:35:19,787
またレンダコマンド
エンコーダを作り

575
00:35:19,887 --> 00:35:21,789
レンダパスを変換します

576
00:35:22,823 --> 00:35:26,226
そしてフレームを
ディスプレイに提示します

577
00:35:27,528 --> 00:35:30,731
さてコマンドバッファ
オブジェクトです

578
00:35:32,166 --> 00:35:35,369
OpenGLからの主な変更は

579
00:35:35,469 --> 00:35:38,906
Metalはコマンドバッファを
明示的に制御できるようになり

580
00:35:39,006 --> 00:35:41,475
コマンドバッファを作成し

581
00:35:41,575 --> 00:35:46,813
GPUによる処理を自分で
決められるようになった点です

582
00:35:47,514 --> 00:35:50,117
まずフレーム全体を
レンダリングする―

583
00:35:50,217 --> 00:35:53,487
コマンドバッファを
１つ作成します

584
00:35:53,787 --> 00:35:56,590
アプリケーション起動後―

585
00:35:56,690 --> 00:36:00,094
GPUにアイドル状態が
認められた場合

586
00:35:56,690 --> 00:36:00,094
GPUにアイドル状態が
認められた場合

587
00:36:00,260 --> 00:36:05,098
複数のコマンドバッファに
フレームを分けるといいです

588
00:36:05,566 --> 00:36:09,770
GPUが１つのコマンドバッファを
処理している間

589
00:36:09,937 --> 00:36:12,472
CPUは他を
エンコーディングします

590
00:36:13,273 --> 00:36:17,678
フレームエンコーディングを
複数のスレッドに分ける場合

591
00:36:17,778 --> 00:36:21,281
スレッドごとに
コマンドバッファを作成します

592
00:36:21,582 --> 00:36:27,121
しかし各コマンドバッファには
追加CPUコストが関わります

593
00:36:27,221 --> 00:36:30,390
可能な限り
少なくしたいところです

594
00:36:31,992 --> 00:36:36,630
Metalは完了コールバックを
登録するAPIを提供し

595
00:36:36,964 --> 00:36:41,535
GPUがコマンドバッファの処理を
完了した時に関与します

596
00:36:41,835 --> 00:36:45,072
稼動するAPIを
見てみましょう

597
00:36:46,740 --> 00:36:51,111
初期化メソッド内に
コマンドキューを作成しています

598
00:36:51,211 --> 00:36:54,348
これを用いて
commandBufferメソッドを

599
00:36:54,448 --> 00:36:57,718
コールして
コマンドバッファを入手します

600
00:36:58,752 --> 00:37:01,555
この中にコマンドを
エンコードします

601
00:36:58,752 --> 00:37:01,555
この中にコマンドを
エンコードします

602
00:37:01,655 --> 00:37:04,958
これについては
のちほど触れます

603
00:37:05,759 --> 00:37:10,264
エンコーディングの終了後
commitメソッドをコールし

604
00:37:10,464 --> 00:37:14,668
コマンドバッファは
GPUに送られ処理されます

605
00:37:15,903 --> 00:37:19,106
このコマンドバッファが
GPU処理されている間

606
00:37:19,206 --> 00:37:21,875
２つの選択肢があります

607
00:37:23,410 --> 00:37:27,414
OpenGLのglFinishに似た
waitUntilCompletedメソッドを

608
00:37:27,514 --> 00:37:30,184
コールして待機できます

609
00:37:30,784 --> 00:37:34,988
この同期的に待機するメソッドは
コマンドバッファの

610
00:37:35,088 --> 00:37:39,093
すべてのコマンドが
GPU処理されるまで戻りません

611
00:37:41,061 --> 00:37:46,667
またこのコマンドバッファを
GPUにゆだねる前に

612
00:37:46,767 --> 00:37:50,337
完了ハンドラを加えることができ
これはコマンドバッファの

613
00:37:50,504 --> 00:37:53,540
GPU処理が終了すると
呼び出されます

614
00:37:53,807 --> 00:37:58,011
これによってCPUとGPUの
並列処理が可能になります

615
00:37:58,312 --> 00:38:02,816
また毎フレームデータが変化する
共有リソースをトラックして

616
00:37:58,312 --> 00:38:02,816
また毎フレームデータが変化する
共有リソースをトラックして

617
00:38:02,916 --> 00:38:05,452
効率的なアップデートができます

618
00:38:06,820 --> 00:38:11,058
この完了ハンドラを用いた
リソースアップデートの―

619
00:38:11,158 --> 00:38:15,062
効率化を見てみましょう

620
00:38:16,630 --> 00:38:18,565
ほとんどの
アプリケーションは―

621
00:38:18,665 --> 00:38:21,702
新データを毎フレーム
GPUに押し出します

622
00:38:21,969 --> 00:38:25,939
例えばアニメーションに必要な
シェーダユニフォームなど

623
00:38:26,106 --> 00:38:30,944
MetalではGPUがアクセス中でも
CPUは同じメモリの―

624
00:38:31,044 --> 00:38:36,550
共有リソースに
書き込むことができます

625
00:38:37,184 --> 00:38:40,821
Metalはこのような
データ競合を保護しません

626
00:38:41,121 --> 00:38:46,493
OpenGLはGPUのワークロードが
終了するのを待つか

627
00:38:46,660 --> 00:38:52,399
追加コピーを取ってデフォルトで
データ競合を防止しますが

628
00:38:52,633 --> 00:38:55,736
アプリケーションには
最適ではないでしょう

629
00:38:56,069 --> 00:38:59,606
Metalではアプリケーションに
最も適合する―

630
00:38:59,707 --> 00:39:03,544
最適同期戦略を
採用できます

631
00:38:59,707 --> 00:39:03,544
最適同期戦略を
採用できます

632
00:39:04,077 --> 00:39:06,847
多くの場合
一番いい方法は

633
00:39:06,947 --> 00:39:11,752
CPUとGPUが同時に同じバッファに
アクセスしないよう―

634
00:39:11,852 --> 00:39:15,522
共有リソースにマルチバッファを
活用することです

635
00:39:17,624 --> 00:39:21,628
ここではOpenGLアプリケーションを
Metalに移植したところで

636
00:39:21,729 --> 00:39:28,202
これら動的データアップデートに
シングルバッファを用いています

637
00:39:28,535 --> 00:39:32,372
まだ同期メソッドを
アプリケーションに適用しておらず

638
00:39:32,472 --> 00:39:35,342
次のようなことが起きます

639
00:39:36,677 --> 00:39:41,381
アプリケーションは最初の
フレームのコマンドを生成しながら

640
00:39:41,481 --> 00:39:44,318
バッファに書き込み
これをGPUに送信します

641
00:39:45,152 --> 00:39:50,190
GPUはこのコマンドバッファを
読んで処理を進めます

642
00:39:51,959 --> 00:39:55,429
次のフレームのために
バッファを更新する一方

643
00:39:55,529 --> 00:39:58,732
GPUは まだそのバッファを
読んでいる状態です

644
00:39:59,767 --> 00:40:04,238
これは明らかに競合状態で
結果がどうなるか不明確です

645
00:39:59,767 --> 00:40:04,238
これは明らかに競合状態で
結果がどうなるか不明確です

646
00:40:05,172 --> 00:40:10,144
アプリケーションを
修整する方法がいくつかあります

647
00:40:11,511 --> 00:40:14,281
最も簡単な方法として
コマンドバッファの

648
00:40:14,381 --> 00:40:17,618
waitUntilCompletedメソッドを
各フレームの後にコールします

649
00:40:19,753 --> 00:40:23,490
しかし次のフレームのために
このバッファに上書きする前に

650
00:40:23,590 --> 00:40:28,395
GPUの読み込みが終わるまで
待たなければなりません

651
00:40:28,962 --> 00:40:34,468
このようにCPUとGPUの
使用効率が非常に悪く

652
00:40:34,568 --> 00:40:38,539
出荷コードでは
避けたいところです

653
00:40:38,772 --> 00:40:43,110
ただMetalアプリケーションを
起動しておくと非常に便利です

654
00:40:43,577 --> 00:40:50,050
このようなデータ競合を
検出することもできるのです

655
00:40:51,885 --> 00:40:57,191
リソースアップデートの同期は
マルチバッファで効率化できます

656
00:40:57,357 --> 00:41:02,429
動的データアップデートを
３つのバッファで行います

657
00:40:57,357 --> 00:41:02,429
動的データアップデートを
３つのバッファで行います

658
00:41:02,629 --> 00:41:07,901
まずフレーム１でバッファに書き
それをGPUが読みます

659
00:41:08,035 --> 00:41:12,906
フレーム２は別のバッファに書き
競合状態を回避します

660
00:41:13,140 --> 00:41:16,710
同様にフレーム３で３つ目の
バッファに書き込みます

661
00:41:18,178 --> 00:41:22,783
これで３つとも使い果たし
バッファプールが枯渇しました

662
00:41:23,350 --> 00:41:29,056
GPUがフレーム１を終えるまで
フレーム４に再利用できません

663
00:41:31,625 --> 00:41:34,595
ここで完了ハンドラの
出番となります

664
00:41:34,695 --> 00:41:38,699
GPUのフレーム処理の終了を
教えてくれます

665
00:41:38,932 --> 00:41:43,270
フレーム１が終わればバッファを
フレーム４に再利用できます

666
00:41:44,571 --> 00:41:45,772
以下同様です

667
00:41:47,107 --> 00:41:49,109
例を見てみましょう

668
00:41:50,911 --> 00:41:54,781
レンダリングループ外の
トリプルバッファ適用では

669
00:41:54,882 --> 00:41:58,152
３つのバッファに対し
まずFIFOキューを作成します

670
00:41:59,853 --> 00:42:04,825
またframeBoundarySemaphoreの
初期スタート値を３に設定します

671
00:41:59,853 --> 00:42:04,825
またframeBoundarySemaphoreの
初期スタート値を３に設定します

672
00:42:04,925 --> 00:42:09,329
これは各フレーム境界線で
セマフォが発信されることを表し

673
00:42:09,429 --> 00:42:12,833
それはGPUがフレーム処理を
終えたことを意味します

674
00:42:13,033 --> 00:42:15,936
CPUのバッファ再利用が
可能となるのです

675
00:42:17,337 --> 00:42:19,506
またバッファインデックスを

676
00:42:19,606 --> 00:42:22,743
カレントフレームのバッファに
ポイントするよう設定します

677
00:42:23,677 --> 00:42:29,083
レンダリングループにおいては
バッファの書き込み前に

678
00:42:29,183 --> 00:42:34,087
対応するフレームの
GPU処理終了の確認が必要です

679
00:42:34,188 --> 00:42:35,923
フレームの先頭で―

680
00:42:36,056 --> 00:42:38,992
frameBoundarySemaphoreを
待ちます

681
00:42:39,493 --> 00:42:42,162
カレントフレームが
GPU処理を―

682
00:42:42,262 --> 00:42:45,933
終えたことを知らせる
セマフォが発信されると…

683
00:42:47,634 --> 00:42:52,139
安全にバッファをつかみ
新しいデータに再利用できます

684
00:42:53,774 --> 00:42:58,145
このバッファをGPUに
関連付けるために

685
00:42:58,745 --> 00:43:02,583
いくつかのコマンドを
エンコードします

686
00:42:58,745 --> 00:43:02,583
いくつかのコマンドを
エンコードします

687
00:43:02,683 --> 00:43:07,087
またフレームのコマンドバッファに
完了ハンドラを加えます

688
00:43:08,088 --> 00:43:12,259
そしてコマンドバッファを
GPUにゆだねます

689
00:43:12,760 --> 00:43:19,133
フレームのGPU処理が終了すると
完了ハンドラが発動され

690
00:43:19,233 --> 00:43:22,502
フレームセマフォに
信号を送ります

691
00:43:23,637 --> 00:43:28,342
これでCPUはエンコード用に
バッファを再利用できます

692
00:43:28,575 --> 00:43:31,511
このトリプルバッファ用法は

693
00:43:31,678 --> 00:43:36,250
あらゆる動的データリソースの
更新に活用できます

694
00:43:37,784 --> 00:43:43,056
さてコマンドバッファと
リソースアップデートに続いて

695
00:43:43,490 --> 00:43:46,393
ドローコードのエンコードに
使用する―

696
00:43:46,493 --> 00:43:50,130
レンダパスエンコーダについて
解説します

697
00:43:51,598 --> 00:43:56,870
先にダンが説明したように
コマンドエンコーダは

698
00:43:56,970 --> 00:44:00,274
コマンドバッファでAPIコールを
GPUコマンドに変換します

699
00:43:56,970 --> 00:44:00,274
コマンドバッファでAPIコールを
GPUコマンドに変換します

700
00:44:00,674 --> 00:44:04,478
典型的な画像APIを供給する
レンダコマンドバッファや

701
00:44:04,578 --> 00:44:08,982
パイプライン テクスチャバッファ
オブジェクトなどの設定―

702
00:44:09,083 --> 00:44:12,619
ドローコードの操作などを
お話しましょう

703
00:44:14,288 --> 00:44:19,159
エンコーダ作成に先立ち
レンダターゲットを設定します

704
00:44:19,259 --> 00:44:23,797
レンダターゲットを設定し
新しいエンコーダの作成を

705
00:44:23,897 --> 00:44:29,002
コマンドバッファに要請する
レンダパスディスクリプタです

706
00:44:29,236 --> 00:44:33,740
このエンコーダをドローコードの
エンコードに使用できます

707
00:44:34,942 --> 00:44:39,113
OpenGLとの大きな違いは
Metalではエンコーダ作成後

708
00:44:39,379 --> 00:44:43,984
レンダターゲットを
変更することはできません

709
00:44:44,084 --> 00:44:48,822
GPUは同じレンダターゲット
セットとレンダしている--

710
00:44:48,922 --> 00:44:53,460
最大のドローコールを見ると
働きがずっとよくなるからです

711
00:44:53,894 --> 00:44:58,932
Metal APIはレンダパスに
スタート エンドを明示して

712
00:44:59,032 --> 00:45:01,034
これを反映しています

713
00:44:59,032 --> 00:45:01,034
これを反映しています

714
00:45:01,135 --> 00:45:03,971
このエンコーダが
発行するドローは

715
00:45:04,071 --> 00:45:07,341
これらレンダターゲットに
レンダリングを行います

716
00:45:08,408 --> 00:45:11,378
別のレンダターゲットセットへの
ドローは―

717
00:45:11,478 --> 00:45:14,548
このレンダパスを終了し
新しいパスを開始します

718
00:45:17,084 --> 00:45:21,955
レンダパスディスクリプタや
色 深度アタッチメントが

719
00:45:22,055 --> 00:45:24,024
作成されたところです

720
00:45:24,992 --> 00:45:30,097
これでレンダコマンドエンコーダを
このディスクリプタで作れます

721
00:45:30,297 --> 00:45:32,699
このエンコーダが発行する
ドローは

722
00:45:32,800 --> 00:45:35,869
これらのターゲットに
レンダされます

723
00:45:37,371 --> 00:45:42,209
MetalではGPU帯域幅の
任意使用のために

724
00:45:42,309 --> 00:45:46,547
ロードやストア アクションを
供給することもできます

725
00:45:48,048 --> 00:45:52,753
これらのアクションは
テクスチャをレンダパスの前後で

726
00:45:52,886 --> 00:45:56,256
どのように扱うか制御します

727
00:45:56,490 --> 00:46:00,661
レンダパス用の色と深度の
アタッチメントです

728
00:45:56,490 --> 00:46:00,661
レンダパス用の色と深度の
アタッチメントです

729
00:46:01,895 --> 00:46:04,832
ロードアクションがクリアに
指定された場合

730
00:46:04,932 --> 00:46:10,237
GPUはまず両レンダターゲットの
コンテンツをクリアします

731
00:46:11,338 --> 00:46:16,577
次にGPUはレンダターゲットへの
コマンドを処理します

732
00:46:17,911 --> 00:46:22,316
レンダパスの最後に
ストアアクションを指定します

733
00:46:22,416 --> 00:46:26,854
ここでは色バッファへの
ストアアクション指示はストアで

734
00:46:26,954 --> 00:46:31,291
レンダパスの最後に
コンテンツは保存されます

735
00:46:31,391 --> 00:46:35,963
一方深度アタッチメントへの
ストアアクションはドントケアで

736
00:46:36,063 --> 00:46:38,132
コンテンツは廃棄されます

737
00:46:38,865 --> 00:46:44,538
ロード ストアはメモリ帯域幅を
消費する高価なGPU動作です

738
00:46:44,805 --> 00:46:48,709
クリア ドントケアを
可能な限り指定しましょう

739
00:46:50,177 --> 00:46:52,246
アクションの設定方法です

740
00:46:52,346 --> 00:46:58,318
ロードアクションをクリアにして
クリアカラーを設定しています

741
00:46:59,119 --> 00:47:01,588
ストアアクションはストアに
設定しています

742
00:46:59,119 --> 00:47:01,588
ストアアクションはストアに
設定しています

743
00:47:01,688 --> 00:47:06,226
ロード ストアアクションは
レンダパスディスクリプタ内の

744
00:47:06,326 --> 00:47:08,695
レンダターゲットに
指定できます

745
00:47:08,795 --> 00:47:13,233
レンダターゲットを
以上のように構成します

746
00:47:14,668 --> 00:47:18,338
このディスクリプタから
エンコーダを作成して―

747
00:47:18,438 --> 00:47:20,974
ドローコールを
エンコードします

748
00:47:21,708 --> 00:47:25,279
その前にOpenGLコマンドと

749
00:47:25,379 --> 00:47:28,549
それに相当するMetal版を
紹介します

750
00:47:29,950 --> 00:47:32,953
典型的な
OpenGLドローシーケンスです

751
00:47:33,987 --> 00:47:37,491
まず すべての
レンダターゲットを設定する―

752
00:47:37,691 --> 00:47:40,194
フレームバッファを
バインドします

753
00:47:41,261 --> 00:47:45,432
頂点シェーダなどを含む
プログラムをバインドし

754
00:47:46,400 --> 00:47:50,070
そして頂点データを含む
頂点バッファをバインドします

755
00:47:51,438 --> 00:47:55,075
さらにすべてのユニフォーム
を含むバッファをバインドします

756
00:47:56,010 --> 00:47:58,946
またサンプルする
テクスチャを設定し

757
00:47:59,613 --> 00:48:01,348
最後にドローします

758
00:47:59,613 --> 00:48:01,348
最後にドローします

759
00:48:02,316 --> 00:48:05,853
こちらのMetal版は
より明示的であるため

760
00:48:05,953 --> 00:48:10,124
コード列が増えますが
OpenGLとよく似ています

761
00:48:10,724 --> 00:48:13,994
まずレンダターゲットを含む
パスディスクリプターで

762
00:48:14,094 --> 00:48:16,663
レンダコマンドエンコーダを
作成します

763
00:48:17,531 --> 00:48:21,001
シェーダを含むパイプライン
オブジェクトを設定します

764
00:48:22,002 --> 00:48:26,406
次は頂点シェーダにアクセスする
バッファの設定ですが

765
00:48:26,507 --> 00:48:29,476
ドローに使う頂点が
入っています

766
00:48:30,277 --> 00:48:33,213
Metalは頂点かユニフォームか
中身でバッファを区別しません

767
00:48:33,313 --> 00:48:37,484
Metalは頂点かユニフォームか
中身でバッファを区別しません

768
00:48:37,618 --> 00:48:41,789
なのでユニフォームバッファの
設定に同じAPIを使います

769
00:48:42,356 --> 00:48:45,759
最初のコールで頂点シェーダが
バッファアクセスをして

770
00:48:45,859 --> 00:48:49,096
次はフラグメントシェーダが
アクセスします

771
00:48:50,230 --> 00:48:54,268
さらにサンプルするフラグメント
シェーダのテクスチャを決めます

772
00:48:55,569 --> 00:48:56,937
そしてドローします

773
00:48:58,105 --> 00:49:01,542
最後にendEncodingをエンコーダ
オブジェクトにコールして

774
00:48:58,105 --> 00:49:01,542
最後にendEncodingをエンコーダ
オブジェクトにコールして

775
00:49:01,675 --> 00:49:05,679
エンコードコマンドの終了を
Metalに明示します

776
00:49:06,013 --> 00:49:09,717
簡単なMetalレンダパスの
一例でした

777
00:49:11,518 --> 00:49:14,254
完全なレンダパスを
手に入れたところで

778
00:49:14,388 --> 00:49:17,224
これらレンダリングの
ディスプレイ表示をしましょう

779
00:49:18,992 --> 00:49:23,163
OpenGLではレンダしたフレームを
スクリーン表示しますが

780
00:49:23,263 --> 00:49:27,134
ドローアブルと呼ばれる
システムのレンダバッファを

781
00:49:27,468 --> 00:49:29,503
明確に管理するわけでは
ありません

782
00:49:30,170 --> 00:49:34,608
Metalでコンテンツを
ディスプレイ表示するためには

783
00:49:34,708 --> 00:49:39,413
システムから特殊テクスチャの
ドローアブルをまず入手します

784
00:49:39,513 --> 00:49:43,650
MTKViewが各フレームの
ドローアブルテクスチャを

785
00:49:43,750 --> 00:49:45,118
供給します

786
00:49:45,219 --> 00:49:49,823
ドローアブルを入手すると
レンダパスをエンコードして

787
00:49:49,923 --> 00:49:54,862
他のテクスチャと同様に
ドローアブルにレンダできます

788
00:49:54,962 --> 00:50:00,667
ただ他のテクスチャと異なり
ドローアブルはビューへ示せます

789
00:49:54,962 --> 00:50:00,667
ただ他のテクスチャと異なり
ドローアブルはビューへ示せます

790
00:50:01,101 --> 00:50:03,303
コードの一例です

791
00:50:04,738 --> 00:50:09,943
ドローアブルは限定的な
シェードシステムリソースなので

792
00:50:10,043 --> 00:50:13,847
その保持は極力
短時間に留めるべきです

793
00:50:14,181 --> 00:50:18,619
そこでドローアブル取得前に
オフスクリーンレンダパスを

794
00:50:18,719 --> 00:50:20,954
エンコードしましょう

795
00:50:22,022 --> 00:50:26,260
MTKViewを作成し
このようにエンコーダ作成に

796
00:50:26,360 --> 00:50:31,431
直接使える完全実装のレンダパス
ディスクリプタを設定したり

797
00:50:31,531 --> 00:50:34,768
view.currentDrawableを使って

798
00:50:34,868 --> 00:50:40,174
特定のテクスチャを
要請することもできます

799
00:50:40,708 --> 00:50:44,812
レンダパスディスクリプタも
この周囲に構築できます

800
00:50:47,247 --> 00:50:49,516
フレームのエンコード終了後

801
00:50:49,616 --> 00:50:54,087
コマンドバッファの
drawableメソッドをコールすると

802
00:50:54,188 --> 00:50:58,458
GPUのコマンドバッファ処理後
ドローアブルが表示されます

803
00:50:58,826 --> 00:51:04,431
GPUのフレーム処理が終わると
フレームが表示されます

804
00:50:58,826 --> 00:51:04,431
GPUのフレーム処理が終わると
フレームが表示されます

805
00:51:05,532 --> 00:51:08,535
Metalでレンダリングを
ディスプレイ表示する方法を

806
00:51:08,635 --> 00:51:10,904
足早に紹介しました

807
00:51:12,373 --> 00:51:14,541
他にもいくつかコツがあります

808
00:51:15,208 --> 00:51:20,214
Metaにレンダパスを１つずつ
移植することは可能です

809
00:51:20,647 --> 00:51:24,284
IOSurfaceと
CVPixelBufferを使い

810
00:51:24,751 --> 00:51:29,490
OpenGLとMetalで共有できる
テクスチャが作成できます

811
00:51:30,190 --> 00:51:35,996
これによりOpenGLでテクスチャに
レンダしてそれをMetalで読む―

812
00:51:36,096 --> 00:51:37,598
またその逆が可能となります

813
00:51:38,198 --> 00:51:43,504
これを移植の増強や
OpenGL系プラグインの移植に

814
00:51:43,604 --> 00:51:46,773
活用できる
アプリケーションもあります

815
00:51:47,774 --> 00:51:50,477
この方法の参考として
サンプルコードが

816
00:51:50,577 --> 00:51:53,113
当セッションに
リンクされています

817
00:51:55,582 --> 00:52:00,354
Metalアプリケーションがあれば
その特性がすべて活用できます

818
00:51:55,582 --> 00:52:00,354
Metalアプリケーションがあれば
その特性がすべて活用できます

819
00:52:00,921 --> 00:52:04,525
CPU制約のあるアプリケーションは
エンコーディング動作を

820
00:52:04,625 --> 00:52:07,327
マルチスレッドにすると
効果的です

821
00:52:07,561 --> 00:52:10,898
別のスレッドに同時に
マルチコマンドバッファを

822
00:52:10,998 --> 00:52:12,533
エンコードできます

823
00:52:12,800 --> 00:52:17,104
並列レンダコマンドエンコーダを
使い 単一バッファコマンドを

824
00:52:17,237 --> 00:52:19,907
マルチスレッドに
分けることもできます

825
00:52:24,511 --> 00:52:28,615
また計画的API処理による
GPUコンピュートがMetalに

826
00:52:28,716 --> 00:52:30,484
組み込まれています

827
00:52:30,584 --> 00:52:33,754
GPUをまったく新しい方法で
活用できます

828
00:52:33,854 --> 00:52:37,758
CPUの代わりに
グラフィックGPUデータの生成に

829
00:52:37,858 --> 00:52:41,061
コンピュートパイプラインを
活用できます

830
00:52:41,195 --> 00:52:44,398
GPUが自ら
データを生成するので

831
00:52:44,498 --> 00:52:49,136
CPU使用と同期ポイントが
軽減されるだけでなく

832
00:52:49,236 --> 00:52:52,506
GPUにデータ帯域幅を
開放できます

833
00:52:53,006 --> 00:52:56,310
この高度帯域幅プロセッサで

834
00:52:56,410 --> 00:52:59,813
より複雑なアルゴリズムを
たくさん適用できます

835
00:53:03,183 --> 00:53:06,020
Metalはアプリケーションの
性能を向上させる―

836
00:53:06,120 --> 00:53:10,023
たくさんの優れた機能を
サポートしています

837
00:53:12,025 --> 00:53:16,463
さらに移植過程の一環として
Xcodeに統合された―

838
00:53:16,563 --> 00:53:20,667
Metalの強力なデバッグと
最適化ツールを

839
00:53:20,768 --> 00:53:23,737
使用するよう強く推奨します

840
00:53:24,204 --> 00:53:27,508
Metalには
優れたレイヤーがあり

841
00:53:27,608 --> 00:53:32,379
APIの不適切な使用に関する
詳しい情報をプリントしたり

842
00:53:32,479 --> 00:53:35,215
潜在的な修整を
示唆してくれます

843
00:53:36,783 --> 00:53:40,087
これはGPUデバッガで
Metalコールや

844
00:53:40,187 --> 00:53:46,160
フレームのレンダ状態を
ステップごとに確認できます

845
00:53:46,493 --> 00:53:50,531
フレームに関連した
リソースも見られます

846
00:53:50,698 --> 00:53:55,402
またリソースの使用に基づいて
専門的な助言も提供します

847
00:53:56,437 --> 00:54:00,607
今年は他の機能と同じように
シェーダ機能のバグを除去する―

848
00:53:56,437 --> 00:54:00,607
今年は他の機能と同じように
シェーダ機能のバグを除去する―

849
00:54:00,774 --> 00:54:04,244
シェーダデバッグ機能を
付加しました

850
00:54:05,712 --> 00:54:10,017
またシェーダに関連する多様な
性能メトリクスを提示する―

851
00:54:10,117 --> 00:54:12,419
シェーダプロファイラも
加えました

852
00:54:13,787 --> 00:54:17,524
さらにレンダパス間の
依存度を評価し

853
00:54:17,658 --> 00:54:22,596
アプリケーションの性能を
向上させるために

854
00:54:22,696 --> 00:54:28,368
重複するレンダパスを統合する
依存ビューアもあります

855
00:54:30,003 --> 00:54:32,806
最後に
Metalシステムトレースツールは

856
00:54:32,906 --> 00:54:35,742
デバイスにおける
アプリケーション動作や―

857
00:54:35,843 --> 00:54:39,179
性能をすべて
表示してくれます

858
00:54:39,346 --> 00:54:44,017
移植作業を軽減するためにも
これらのツールを推奨します

859
00:54:45,419 --> 00:54:49,923
OpenGLとOpenCLは
非推奨化されます

860
00:54:50,023 --> 00:54:54,528
まだ存在していますが
将来の使用には否定的です

861
00:54:54,628 --> 00:54:56,864
Metalを採用しましょう

862
00:54:57,064 --> 00:55:01,969
豊富な開発者ツールと経験により
我々は多くのチームを支援し

863
00:54:57,064 --> 00:55:01,969
豊富な開発者ツールと経験により
我々は多くのチームを支援し

864
00:55:02,069 --> 00:55:07,307
大幅な改善がもたらされ
成功を収めてきました

865
00:55:07,574 --> 00:55:12,813
本日の情報共有で 移植が
滞りなくできるよう願っています

866
00:55:13,881 --> 00:55:16,950
Metalとアプリケーションの
動作について―

867
00:55:17,051 --> 00:55:19,753
お話ができて光栄です

868
00:55:19,853 --> 00:55:24,525
明日“OpenGL to Metal
Porting Lab”でお会いしましょう

869
00:55:24,658 --> 00:55:27,728
Metal関連のセッションが
多数あります

870
00:55:27,828 --> 00:55:31,165
Metalとアプリケーションの
デバッグや―

871
00:55:31,265 --> 00:55:34,768
最適化に関するセッションに
ぜひご参加ください

872
00:55:35,903 --> 00:55:38,438
ご参加いただき
ありがとうございました

873
00:55:38,539 --> 00:55:41,108
よいお時間を
お過ごしください

874
00:55:41,241 --> 00:55:45,145
（拍手）